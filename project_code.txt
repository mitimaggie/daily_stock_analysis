User: è¿™é‡Œæ˜¯é¡¹ç›®çš„æ ¸å¿ƒä»£ç å†…å®¹ï¼š


#File: main.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Aè‚¡è‡ªé€‰è‚¡æ™ºèƒ½åˆ†æç³»ç»Ÿ - ä¸»è°ƒåº¦ç¨‹åº
===================================
"""
import os
from src.config import setup_env
setup_env()

# ä»£ç†é…ç½®
if os.getenv("GITHUB_ACTIONS") != "true" and os.getenv("USE_PROXY", "false").lower() == "true":
    proxy_host = os.getenv("PROXY_HOST", "127.0.0.1")
    proxy_port = os.getenv("PROXY_PORT", "10809")
    proxy_url = f"http://{proxy_host}:{proxy_port}"
    os.environ["http_proxy"] = proxy_url
    os.environ["https_proxy"] = proxy_url

import argparse
import logging
import sys
import time
import uuid
from datetime import datetime, timezone, timedelta
from logging.handlers import RotatingFileHandler
from pathlib import Path
from typing import List, Optional
from src.feishu_doc import FeishuDocManager

from src.config import get_config, Config
from src.notification import NotificationService
from src.core.pipeline import StockAnalysisPipeline
from src.core.market_review import run_market_review
from src.search_service import SearchService
from src.analyzer import GeminiAnalyzer

# é…ç½®æ—¥å¿—æ ¼å¼
LOG_FORMAT = '%(asctime)s | %(levelname)-8s | %(name)-20s | %(message)s'
LOG_DATE_FORMAT = '%Y-%m-%d %H:%M:%S'

def setup_logging(debug: bool = False, log_dir: str = "./logs") -> None:
    level = logging.DEBUG if debug else logging.INFO
    log_path = Path(log_dir)
    log_path.mkdir(parents=True, exist_ok=True)
    
    today_str = datetime.now().strftime('%Y%m%d')
    log_file = log_path / f"stock_analysis_{today_str}.log"
    debug_log_file = log_path / f"stock_analysis_debug_{today_str}.log"
    
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.DEBUG)
    
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(level)
    console_handler.setFormatter(logging.Formatter(LOG_FORMAT, LOG_DATE_FORMAT))
    root_logger.addHandler(console_handler)
    
    file_handler = RotatingFileHandler(log_file, maxBytes=10*1024*1024, backupCount=5, encoding='utf-8')
    file_handler.setLevel(logging.INFO)
    file_handler.setFormatter(logging.Formatter(LOG_FORMAT, LOG_DATE_FORMAT))
    root_logger.addHandler(file_handler)
    
    debug_handler = RotatingFileHandler(debug_log_file, maxBytes=50*1024*1024, backupCount=3, encoding='utf-8')
    debug_handler.setLevel(logging.DEBUG)
    debug_handler.setFormatter(logging.Formatter(LOG_FORMAT, LOG_DATE_FORMAT))
    root_logger.addHandler(debug_handler)
    
    logging.getLogger('urllib3').setLevel(logging.WARNING)
    logging.getLogger('sqlalchemy').setLevel(logging.WARNING)
    logging.getLogger('google').setLevel(logging.WARNING)
    logging.getLogger('httpx').setLevel(logging.WARNING)
    
    logging.info(f"æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼Œç›®å½•: {log_path.absolute()}")

logger = logging.getLogger(__name__)

def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description='Aè‚¡è‡ªé€‰è‚¡æ™ºèƒ½åˆ†æç³»ç»Ÿ')
    parser.add_argument('--debug', action='store_true', help='å¯ç”¨è°ƒè¯•æ¨¡å¼')
    parser.add_argument('--dry-run', action='store_true', help='ä»…è·å–æ•°æ®')
    parser.add_argument('--stocks', type=str, help='æŒ‡å®šåˆ†æè‚¡ç¥¨ä»£ç ')
    parser.add_argument('--no-notify', action='store_true', help='ä¸å‘é€æ¨é€')
    parser.add_argument('--single-notify', action='store_true', help='å•è‚¡æ¨é€æ¨¡å¼')
    parser.add_argument('--workers', type=int, default=None, help='å¹¶å‘çº¿ç¨‹æ•°')
    parser.add_argument('--schedule', action='store_true', help='å¯ç”¨å®šæ—¶ä»»åŠ¡')
    parser.add_argument('--market-review', action='store_true', help='ä»…å¤§ç›˜å¤ç›˜')
    parser.add_argument('--no-market-review', action='store_true', help='è·³è¿‡å¤§ç›˜å¤ç›˜')
    parser.add_argument('--webui', action='store_true', help='å¯åŠ¨WebUI')
    parser.add_argument('--webui-only', action='store_true', help='ä»…WebUI')
    parser.add_argument('--no-context-snapshot', action='store_true', help='ä¸ä¿å­˜å¿«ç…§')
    return parser.parse_args()

def run_full_analysis(config: Config, args: argparse.Namespace, stock_codes: Optional[List[str]] = None):
    """
    æ‰§è¡Œåˆ†ææµç¨‹ï¼ˆäº’æ–¥é€»è¾‘ä¼˜åŒ–ç‰ˆï¼‰
    """
    try:
        if getattr(args, 'single_notify', False):
            config.single_stock_notify = True
        
        save_context_snapshot = None
        if getattr(args, 'no_context_snapshot', False):
            save_context_snapshot = False
        query_id = uuid.uuid4().hex
        
        pipeline = StockAnalysisPipeline(
            config=config,
            max_workers=args.workers,
            query_id=query_id,
            query_source="cli",
            save_context_snapshot=save_context_snapshot
        )
        
        results = []
        # === 1. è¿è¡Œä¸ªè‚¡åˆ†æ ===
        # é€»è¾‘ï¼šåªè¦ä¸æ˜¯"ä»…å¤§ç›˜å¤ç›˜"ï¼Œå°±è¿è¡Œä¸ªè‚¡
        if not args.market_review: 
            try:
                results = pipeline.run(
                    stock_codes=stock_codes,
                    dry_run=args.dry_run,
                    send_notification=not args.no_notify
                )
            except Exception as e:
                logger.error(f"âŒ ä¸ªè‚¡åˆ†ææµç¨‹å‘ç”Ÿå¼‚å¸¸: {e}")

        # === 2. è¿è¡Œå¤§ç›˜å¤ç›˜ ===
        # é€»è¾‘ï¼š
        # 1. å¿…é¡»å¼€å¯é…ç½®å¼€å…³
        # 2. å¿…é¡»æ²¡æœ‰æ˜¾å¼ç¦ç”¨ (--no-market-review)
        # 3. [å…³é”®ä¿®å¤] å¦‚æœæŒ‡å®šäº†ä¸ªè‚¡ (--stocks)ï¼Œåˆ™é»˜è®¤ä¸è·‘å¤§ç›˜ï¼Œé™¤éåŒæ—¶æŒ‡å®šäº† --market-review
        should_run_market = config.market_review_enabled and not args.no_market_review
        
        if stock_codes and not args.market_review:
            # å¦‚æœæŒ‡å®šäº†ä¸ªè‚¡ï¼Œä¸”æ²¡å¼ºåˆ¶è¦æ±‚è·‘å¤§ç›˜ï¼Œåˆ™é™é»˜å…³é—­å¤§ç›˜å¤ç›˜
            should_run_market = False
            logger.info("å·²æŒ‡å®šä¸ªè‚¡åˆ†æï¼Œè‡ªåŠ¨è·³è¿‡å¤§ç›˜å¤ç›˜ã€‚")

        market_report = ""
        if should_run_market:
            # é—´éš”ç­‰å¾…
            if results and getattr(config, 'analysis_delay', 0) > 0:
                time.sleep(config.analysis_delay)

            logger.info("\n" + "="*40)
            logger.info("ğŸ“ˆ å¼€å§‹æ‰§è¡Œå¤§ç›˜å¤ç›˜åˆ†æ...")
            logger.info("="*40)
            
            try:
                market_report = run_market_review(
                    notifier=pipeline.notifier,
                    analyzer=pipeline.analyzer,
                    search_service=pipeline.search_service
                )
                if market_report:
                    logger.info("âœ… å¤§ç›˜å¤ç›˜å®Œæˆ")
            except Exception as e:
                logger.error(f"âŒ å¤§ç›˜å¤ç›˜æ‰§è¡Œå¤±è´¥: {e}")
        
        # æ‘˜è¦è¾“å‡º
        if results:
            logger.info("\n===== åˆ†æç»“æœæ‘˜è¦ =====")
            for r in sorted(results, key=lambda x: x.sentiment_score, reverse=True):
                emoji = r.get_emoji()
                logger.info(f"{emoji} {r.name}({r.code}): {r.operation_advice} | è¯„åˆ† {r.sentiment_score}")
        
        # é£ä¹¦æ–‡æ¡£ç”Ÿæˆ
        try:
            feishu_doc = FeishuDocManager()
            if feishu_doc.is_configured() and (results or market_report):
                tz_cn = timezone(timedelta(hours=8))
                now = datetime.now(tz_cn)
                doc_title = f"{now.strftime('%Y-%m-%d %H:%M')} å¤ç›˜æŠ¥å‘Š"
                
                full_content = ""
                if market_report:
                    full_content += f"# ğŸ“ˆ å¤§ç›˜å¤ç›˜\n\n{market_report}\n\n---\n\n"
                if results:
                    dashboard_content = pipeline.notifier.generate_dashboard_report(results)
                    full_content += f"# ğŸš€ ä¸ªè‚¡å†³ç­–ä»ªè¡¨ç›˜\n\n{dashboard_content}"
                
                doc_url = feishu_doc.create_daily_doc(doc_title, full_content)
                if doc_url:
                    logger.info(f"é£ä¹¦äº‘æ–‡æ¡£åˆ›å»ºæˆåŠŸ: {doc_url}")
                    if not args.no_notify:
                        pipeline.notifier.send(f"[{now.strftime('%H:%M')}] å¤ç›˜æ–‡æ¡£: {doc_url}")
        except Exception as e:
            logger.error(f"é£ä¹¦æ–‡æ¡£ç”Ÿæˆå¤±è´¥: {e}")
        
    except Exception as e:
        logger.exception(f"åˆ†ææµç¨‹æ‰§è¡Œå¤±è´¥: {e}")

def start_bot_stream_clients(config: Config):
    if config.dingtalk_stream_enabled:
        try:
            from bot.platforms import start_dingtalk_stream_background
            start_dingtalk_stream_background()
        except: pass
    if getattr(config, 'feishu_stream_enabled', False):
        try:
            from bot.platforms import start_feishu_stream_background
            start_feishu_stream_background()
        except: pass

def main() -> int:
    args = parse_arguments()
    config = get_config()
    setup_logging(debug=args.debug, log_dir=config.log_dir)
    
    logger.info("=" * 60)
    logger.info("Aè‚¡è‡ªé€‰è‚¡æ™ºèƒ½åˆ†æç³»ç»Ÿ å¯åŠ¨")
    logger.info("=" * 60)
    
    stock_codes = None
    if args.stocks:
        stock_codes = [c.strip() for c in args.stocks.split(',') if c.strip()]
        logger.info(f"æŒ‡å®šåˆ†æè‚¡ç¥¨: {stock_codes}")
    
    # WebUI é€»è¾‘
    start_webui = (args.webui or args.webui_only or config.webui_enabled) and os.getenv("GITHUB_ACTIONS") != "true"
    if start_webui:
        try:
            from webui import run_server_in_thread
            run_server_in_thread(host=config.webui_host, port=config.webui_port)
            start_bot_stream_clients(config)
        except Exception as e:
            logger.error(f"WebUI å¯åŠ¨å¤±è´¥: {e}")
    
    if args.webui_only:
        try:
            while True: time.sleep(1)
        except KeyboardInterrupt: return 0

    try:
        # æ¨¡å¼1: ä»…å¤§ç›˜å¤ç›˜
        if args.market_review:
            logger.info("æ¨¡å¼: ä»…å¤§ç›˜å¤ç›˜")
            # åˆå§‹åŒ–å¿…è¦ç»„ä»¶
            notifier = NotificationService()
            analyzer = GeminiAnalyzer(api_key=config.gemini_api_key)
            search_service = None
            if config.bocha_api_keys or config.tavily_api_keys:
                search_service = SearchService(bocha_keys=config.bocha_api_keys, tavily_keys=config.tavily_api_keys)
            
            run_market_review(notifier=notifier, analyzer=analyzer, search_service=search_service)
            return 0
        
        # æ¨¡å¼2: å®šæ—¶ä»»åŠ¡
        if args.schedule or config.schedule_enabled:
            logger.info(f"æ¨¡å¼: å®šæ—¶ä»»åŠ¡ ({config.schedule_time})")
            from src.scheduler import run_with_schedule
            run_with_schedule(lambda: run_full_analysis(config, args, stock_codes), config.schedule_time, True)
            return 0
        
        # æ¨¡å¼3: æ­£å¸¸è¿è¡Œ
        run_full_analysis(config, args, stock_codes)
        
        if start_webui and not (args.schedule or config.schedule_enabled):
            try:
                while True: time.sleep(1)
            except KeyboardInterrupt: pass
            
        return 0
        
    except KeyboardInterrupt:
        return 0
    except Exception as e:
        logger.exception(f"ç¨‹åºå¤±è´¥: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(main())
--------------------

#File: webui.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
WebUI å…¥å£æ–‡ä»¶ (å‘åå…¼å®¹)
===================================

æœ¬æ–‡ä»¶ä¿æŒå‘åå…¼å®¹ï¼Œå®é™…å®ç°å·²è¿ç§»åˆ° web/ åŒ…

ç»“æ„è¯´æ˜:
    web/
    â”œâ”€â”€ __init__.py    - åŒ…åˆå§‹åŒ–
    â”œâ”€â”€ server.py      - HTTP æœåŠ¡å™¨
    â”œâ”€â”€ router.py      - è·¯ç”±åˆ†å‘
    â”œâ”€â”€ handlers.py    - è¯·æ±‚å¤„ç†å™¨
    â”œâ”€â”€ services.py    - ä¸šåŠ¡æœåŠ¡å±‚
    â””â”€â”€ templates.py   - HTML æ¨¡æ¿

API Endpoints:
  GET  /              - é…ç½®é¡µé¢
  GET  /health        - å¥åº·æ£€æŸ¥
  GET  /analysis?code=xxx - è§¦å‘å•åªè‚¡ç¥¨å¼‚æ­¥åˆ†æ
  GET  /tasks         - æŸ¥è¯¢ä»»åŠ¡åˆ—è¡¨
  GET  /task?id=xxx   - æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
  POST /update        - æ›´æ–°é…ç½®

Usage:
  python webui.py
  WEBUI_HOST=0.0.0.0 WEBUI_PORT=8000 python webui.py
"""

from __future__ import annotations

import os
import logging

# ä» web åŒ…å¯¼å…¥ï¼ˆæ–°æ¶æ„ï¼‰
from web.server import WebServer, run_server_in_thread, run_server
from web.router import Router, get_router
from web.services import ConfigService, AnalysisService, get_config_service, get_analysis_service
from web.handlers import PageHandler, ApiHandler
from web.templates import render_config_page, render_error_page

logger = logging.getLogger(__name__)

# å¯¼å‡ºæ‰€æœ‰å…¬å…±æ¥å£ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
__all__ = [
    # æœåŠ¡å™¨
    'WebServer',
    'run_server_in_thread',
    'run_server',
    # è·¯ç”±
    'Router',
    'get_router',
    # æœåŠ¡
    'ConfigService',
    'AnalysisService',
    'get_config_service',
    'get_analysis_service',
    # å¤„ç†å™¨
    'PageHandler',
    'ApiHandler',
    # æ¨¡æ¿
    'render_config_page',
    'render_error_page',
]


def _start_bot_stream_clients() -> None:
    """å¯åŠ¨ Bot Stream æ¨¡å¼å®¢æˆ·ç«¯ï¼ˆå¦‚æœå·²é…ç½®ï¼‰"""
    from src.config import get_config
    config = get_config()
    
    # é’‰é’‰ Stream æ¨¡å¼
    if config.dingtalk_stream_enabled:
        try:
            from bot.platforms import start_dingtalk_stream_background, DINGTALK_STREAM_AVAILABLE
            if DINGTALK_STREAM_AVAILABLE:
                if start_dingtalk_stream_background():
                    logger.info("[WebUI] é’‰é’‰ Stream å®¢æˆ·ç«¯å·²åœ¨åå°å¯åŠ¨")
                else:
                    logger.warning("[WebUI] é’‰é’‰ Stream å®¢æˆ·ç«¯å¯åŠ¨å¤±è´¥")
            else:
                logger.warning("[WebUI] é’‰é’‰ Stream æ¨¡å¼å·²å¯ç”¨ä½† SDK æœªå®‰è£…")
                logger.warning("[WebUI] è¯·è¿è¡Œ: pip install dingtalk-stream")
        except Exception as e:
            logger.error(f"[WebUI] å¯åŠ¨é’‰é’‰ Stream å®¢æˆ·ç«¯å¤±è´¥: {e}")

    # é£ä¹¦ Stream æ¨¡å¼
    if getattr(config, 'feishu_stream_enabled', False):
        try:
            from bot.platforms import start_feishu_stream_background, FEISHU_SDK_AVAILABLE
            if FEISHU_SDK_AVAILABLE:
                if start_feishu_stream_background():
                    logger.info("[WebUI] é£ä¹¦ Stream å®¢æˆ·ç«¯å·²åœ¨åå°å¯åŠ¨")
                else:
                    logger.warning("[WebUI] é£ä¹¦ Stream å®¢æˆ·ç«¯å¯åŠ¨å¤±è´¥")
            else:
                logger.warning("[WebUI] é£ä¹¦ Stream æ¨¡å¼å·²å¯ç”¨ä½† SDK æœªå®‰è£…")
                logger.warning("[WebUI] è¯·è¿è¡Œ: pip install lark-oapi")
        except Exception as e:
            logger.error(f"[WebUI] å¯åŠ¨é£ä¹¦ Stream å®¢æˆ·ç«¯å¤±è´¥: {e}")


def main() -> int:
    """
    ä¸»å…¥å£å‡½æ•°
    
    æ”¯æŒç¯å¢ƒå˜é‡é…ç½®:
        WEBUI_HOST: ç›‘å¬åœ°å€ (é»˜è®¤ 127.0.0.1)
        WEBUI_PORT: ç›‘å¬ç«¯å£ (é»˜è®¤ 8000)
    """
    host = os.getenv("WEBUI_HOST", "127.0.0.1")
    port = int(os.getenv("WEBUI_PORT", "8000"))
    
    print(f"WebUI running: http://{host}:{port}")
    print("API Endpoints:")
    print("  GET  /              - é…ç½®é¡µé¢")
    print("  GET  /health        - å¥åº·æ£€æŸ¥")
    print("  GET  /analysis?code=xxx - è§¦å‘åˆ†æ")
    print("  GET  /tasks         - ä»»åŠ¡åˆ—è¡¨")
    print("  GET  /task?id=xxx   - ä»»åŠ¡çŠ¶æ€")
    print("  POST /update        - æ›´æ–°é…ç½®")
    print()
    print("Bot Webhooks:")
    print("  POST /bot/feishu    - é£ä¹¦æœºå™¨äºº")
    print("  POST /bot/dingtalk  - é’‰é’‰æœºå™¨äºº")
    print("  POST /bot/wecom     - ä¼ä¸šå¾®ä¿¡æœºå™¨äºº")
    print("  POST /bot/telegram  - Telegram æœºå™¨äºº")
    print()
    
    # å¯åŠ¨ Bot Stream å®¢æˆ·ç«¯ï¼ˆå¦‚æœé…ç½®äº†ï¼‰
    _start_bot_stream_clients()
    
    try:
        run_server(host=host, port=port)
    except KeyboardInterrupt:
        pass
    
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

--------------------

#File: analyzer_service.py
--------------------
# src/analyzer_service.py
# -*- coding: utf-8 -*-
"""
===================================
Aè‚¡è‡ªé€‰è‚¡æ™ºèƒ½åˆ†æç³»ç»Ÿ - åˆ†ææœåŠ¡å±‚ (å¹¶å‘å¢å¼ºç‰ˆ)
===================================

èŒè´£ï¼š
1. å°è£…æ ¸å¿ƒåˆ†æé€»è¾‘ï¼Œæ”¯æŒå¤šè°ƒç”¨æ–¹ï¼ˆCLIã€WebUIã€Botï¼‰
2. æä¾›æ¸…æ™°çš„APIæ¥å£ï¼Œä¸ä¾èµ–äºå‘½ä»¤è¡Œå‚æ•°
3. æ”¯æŒä¾èµ–æ³¨å…¥ï¼Œä¾¿äºæµ‹è¯•å’Œæ‰©å±•
4. ç»Ÿä¸€ç®¡ç†åˆ†ææµç¨‹å’Œé…ç½®
5. [æ–°å¢] å¤šçº¿ç¨‹å¹¶å‘æ§åˆ¶ï¼Œæœ€å¤§åŒ–åˆ©ç”¨ API é¢åº¦
"""

import uuid
import time
import logging
from typing import List, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed

from src.analyzer import AnalysisResult
from src.config import get_config, Config
from src.notification import NotificationService
from src.enums import ReportType
from src.core.pipeline import StockAnalysisPipeline
from src.core.market_review import run_market_review

logger = logging.getLogger(__name__)

def analyze_stock(
    stock_code: str,
    config: Config = None,
    full_report: bool = False,
    notifier: Optional[NotificationService] = None
) -> Optional[AnalysisResult]:
    """
    åˆ†æå•åªè‚¡ç¥¨
    
    Args:
        stock_code: è‚¡ç¥¨ä»£ç 
        config: é…ç½®å¯¹è±¡ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä½¿ç”¨å•ä¾‹ï¼‰
        full_report: æ˜¯å¦ç”Ÿæˆå®Œæ•´æŠ¥å‘Š
        notifier: é€šçŸ¥æœåŠ¡ï¼ˆå¯é€‰ï¼‰
        
    Returns:
        åˆ†æç»“æœå¯¹è±¡
    """
    if config is None:
        config = get_config()
    
    # åˆ›å»ºåˆ†ææµæ°´çº¿
    # æ³¨æ„ï¼šæ¯æ¬¡è°ƒç”¨éƒ½åˆ›å»ºæ–°å®ä¾‹ï¼Œå¤©ç„¶çº¿ç¨‹å®‰å…¨
    pipeline = StockAnalysisPipeline(
        config=config,
        query_id=uuid.uuid4().hex,
        query_source="cli"
    )
    
    # ä½¿ç”¨é€šçŸ¥æœåŠ¡ï¼ˆå¦‚æœæä¾›ï¼‰
    if notifier:
        pipeline.notifier = notifier
    
    # æ ¹æ®full_reportå‚æ•°è®¾ç½®æŠ¥å‘Šç±»å‹
    report_type = ReportType.FULL if full_report else ReportType.SIMPLE
    
    try:
        # è¿è¡Œå•åªè‚¡ç¥¨åˆ†æ
        result = pipeline.process_single_stock(
            code=stock_code,
            skip_analysis=False,
            single_stock_notify=notifier is not None,
            report_type=report_type
        )
        return result
    except Exception as e:
        logger.error(f"âŒ åˆ†æè‚¡ç¥¨ {stock_code} æ—¶å‘ç”Ÿæœªæ•è·å¼‚å¸¸: {e}")
        return None

def analyze_stocks(
    stock_codes: List[str],
    config: Config = None,
    full_report: bool = False,
    notifier: Optional[NotificationService] = None
) -> List[AnalysisResult]:
    """
    ã€å¹¶å‘ä¼˜åŒ–ç‰ˆã€‘åˆ†æå¤šåªè‚¡ç¥¨
    
    Args:
        stock_codes: è‚¡ç¥¨ä»£ç åˆ—è¡¨
        config: é…ç½®å¯¹è±¡
        full_report: æ˜¯å¦ç”Ÿæˆå®Œæ•´æŠ¥å‘Š
        notifier: é€šçŸ¥æœåŠ¡
        
    Returns:
        åˆ†æç»“æœåˆ—è¡¨
    """
    if config is None:
        config = get_config()
    
    results = []
    total_stocks = len(stock_codes)
    
    # === ğŸš€ å¹¶å‘å‚æ•°é…ç½® ===
    # Google Gemini å…è´¹ç‰ˆé™åˆ¶çº¦ 15 RPM (è™½ç„¶å†™çš„æ˜¯ RPMï¼Œä½†æœ‰æ—¶å€™æ˜¯æŒ‰æ¯åˆ†é’Ÿè¯·æ±‚æ•°ç®—çš„)
    # è®¾ç½® 3 ä¸ªçº¿ç¨‹å¹¶è¡Œï¼Œæ—¢èƒ½æé€Ÿï¼Œåˆä¸å®¹æ˜“è¢«å°ã€‚
    MAX_WORKERS = 3
    
    logger.info(f"âš¡ï¸ å¯åŠ¨å¹¶å‘åˆ†ææ¨¡å¼ï¼Œç›®æ ‡: {total_stocks} åªè‚¡ç¥¨ï¼Œå¹¶å‘çº¿ç¨‹æ•°: {MAX_WORKERS}")
    
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        future_to_code = {}
        
        # 1. æäº¤ä»»åŠ¡
        for i, code in enumerate(stock_codes):
            # æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ± 
            future = executor.submit(analyze_stock, code, config, full_report, notifier)
            future_to_code[future] = code
            
            # === ğŸš¦ å…³é”®é™æµ ===
            # è™½ç„¶å¼€äº†å¤šçº¿ç¨‹ï¼Œä½†ä¸èƒ½ç¬é—´æŠŠè¯·æ±‚å…¨å‘å‡ºå»ï¼Œå¦åˆ™ä¼šè§¦å‘ HTTP 429ã€‚
            # é—´éš” 1.5 ç§’æäº¤ä¸€ä¸ªï¼Œä¿è¯è¯·æ±‚æ˜¯å‡åŒ€åˆ†å¸ƒçš„ã€‚
            # 3ä¸ªçº¿ç¨‹ * 1.5sé—´éš” = APIè¯·æ±‚éå¸¸å¹³æ»‘
            time.sleep(1.5)
            
            if (i + 1) % 5 == 0:
                logger.info(f"å·²æäº¤ {i + 1}/{total_stocks} ä¸ªåˆ†æä»»åŠ¡...")

        # 2. è·å–ç»“æœ (æŒ‰å®Œæˆé¡ºåº)
        for future in as_completed(future_to_code):
            code = future_to_code[future]
            try:
                result = future.result()
                if result:
                    results.append(result)
                    logger.info(f"âœ… [{len(results)}/{total_stocks}] å®Œæˆåˆ†æ: {code} {result.name}")
                else:
                    logger.warning(f"âš ï¸ [{len(results)}/{total_stocks}] åˆ†æè¿”å›ç©ºå€¼: {code}")
            except Exception as exc:
                logger.error(f"âŒ è‚¡ç¥¨ {code} çº¿ç¨‹æ‰§è¡Œå¼‚å¸¸: {exc}")

    logger.info("ğŸ‰ æ‰€æœ‰å¹¶å‘ä»»åŠ¡æ‰§è¡Œå®Œæ¯•")
    return results

def perform_market_review(
    config: Config = None,
    notifier: Optional[NotificationService] = None
) -> Optional[str]:
    """
    æ‰§è¡Œå¤§ç›˜å¤ç›˜
    """
    if config is None:
        config = get_config()
    
    pipeline = StockAnalysisPipeline(
        config=config,
        query_id=uuid.uuid4().hex,
        query_source="cli"
    )
    
    review_notifier = notifier or pipeline.notifier
    
    return run_market_review(
        notifier=review_notifier,
        analyzer=pipeline.analyzer,
        search_service=pipeline.search_service
    )

--------------------

#File: pyproject.toml
--------------------
[tool.black]
line-length = 120
target-version = ['py310', 'py311', 'py312']
include = '\.pyi?$'
exclude = '''
/(
    \.git
    | \.hg
    | \.mypy_cache
    | \.tox
    | \.venv
    | venv
    | _build
    | buck-out
    | build
    | dist
    | __pycache__
)/
'''

[tool.isort]
profile = "black"
line_length = 120
skip = [".git", "__pycache__", ".env", "venv", ".venv"]

[tool.bandit]
exclude_dirs = ["tests", "test_*.py"]
skips = ["B101"]  # assert è¯­å¥åœ¨æµ‹è¯•ä¸­æ˜¯å…è®¸çš„

--------------------

#File: src/enums.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
æšä¸¾ç±»å‹å®šä¹‰
===================================

é›†ä¸­ç®¡ç†ç³»ç»Ÿä¸­ä½¿ç”¨çš„æšä¸¾ç±»å‹ï¼Œæä¾›ç±»å‹å®‰å…¨å’Œä»£ç å¯è¯»æ€§ã€‚
"""

from enum import Enum


class ReportType(str, Enum):
    """
    æŠ¥å‘Šç±»å‹æšä¸¾
    
    ç”¨äº API è§¦å‘åˆ†ææ—¶é€‰æ‹©æ¨é€çš„æŠ¥å‘Šæ ¼å¼ã€‚
    ç»§æ‰¿ str ä½¿å…¶å¯ä»¥ç›´æ¥ä¸å­—ç¬¦ä¸²æ¯”è¾ƒå’Œåºåˆ—åŒ–ã€‚
    """
    SIMPLE = "simple"  # ç²¾ç®€æŠ¥å‘Šï¼šä½¿ç”¨ generate_single_stock_report
    FULL = "full"      # å®Œæ•´æŠ¥å‘Šï¼šä½¿ç”¨ generate_dashboard_report
    
    @classmethod
    def from_str(cls, value: str) -> "ReportType":
        """
        ä»å­—ç¬¦ä¸²å®‰å…¨åœ°è½¬æ¢ä¸ºæšä¸¾å€¼
        
        Args:
            value: å­—ç¬¦ä¸²å€¼
            
        Returns:
            å¯¹åº”çš„æšä¸¾å€¼ï¼Œæ— æ•ˆè¾“å…¥è¿”å›é»˜è®¤å€¼ SIMPLE
        """
        try:
            return cls(value.lower().strip())
        except (ValueError, AttributeError):
            return cls.SIMPLE
    
    @property
    def display_name(self) -> str:
        """è·å–ç”¨äºæ˜¾ç¤ºçš„åç§°"""
        return {
            ReportType.SIMPLE: "ç²¾ç®€æŠ¥å‘Š",
            ReportType.FULL: "å®Œæ•´æŠ¥å‘Š",
        }.get(self, "ç²¾ç®€æŠ¥å‘Š")

--------------------

#File: src/.DS_Store
--------------------
Error reading file: 'utf-8' codec can't decode byte 0x80 in position 3131: invalid start byte
--------------------

#File: src/config.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Aè‚¡è‡ªé€‰è‚¡æ™ºèƒ½åˆ†æç³»ç»Ÿ - é…ç½®ç®¡ç†æ¨¡å—
===================================

èŒè´£ï¼š
1. ä½¿ç”¨å•ä¾‹æ¨¡å¼ç®¡ç†å…¨å±€é…ç½®
2. ä» .env æ–‡ä»¶åŠ è½½æ•æ„Ÿé…ç½®
3. æä¾›ç±»å‹å®‰å…¨çš„é…ç½®è®¿é—®æ¥å£
"""

import os
from pathlib import Path
from typing import List, Optional
from dotenv import load_dotenv, dotenv_values
from dataclasses import dataclass, field


def setup_env():
    """åˆå§‹åŒ–ç¯å¢ƒå˜é‡ï¼ˆæ”¯æŒä» .env åŠ è½½ï¼‰"""
    # src/config.py -> src/ -> root
    env_path = Path(__file__).parent.parent / '.env'
    load_dotenv(dotenv_path=env_path)


@dataclass
class Config:
    """
    ç³»ç»Ÿé…ç½®ç±» - å•ä¾‹æ¨¡å¼
    
    è®¾è®¡è¯´æ˜ï¼š
    - ä½¿ç”¨ dataclass ç®€åŒ–é…ç½®å±æ€§å®šä¹‰
    - æ‰€æœ‰é…ç½®é¡¹ä»ç¯å¢ƒå˜é‡è¯»å–ï¼Œæ”¯æŒé»˜è®¤å€¼
    - ç±»æ–¹æ³• get_instance() å®ç°å•ä¾‹è®¿é—®
    """
    
    # === è‡ªé€‰è‚¡é…ç½® ===
    stock_list: List[str] = field(default_factory=list)

    # === é£ä¹¦äº‘æ–‡æ¡£é…ç½® ===
    feishu_app_id: Optional[str] = None
    feishu_app_secret: Optional[str] = None
    feishu_folder_token: Optional[str] = None  # ç›®æ ‡æ–‡ä»¶å¤¹ Token

    # === æ•°æ®æº API Token ===
    tushare_token: Optional[str] = None
    
    # === AI åˆ†æé…ç½® ===
    gemini_api_key: Optional[str] = None
    gemini_model: str = "gemini-3-flash-preview"  # ä¸»æ¨¡å‹
    gemini_model_fallback: str = "gemini-2.5-flash"  # å¤‡é€‰æ¨¡å‹
    gemini_temperature: float = 0.7  # æ¸©åº¦å‚æ•°ï¼ˆ0.0-2.0ï¼Œæ§åˆ¶è¾“å‡ºéšæœºæ€§ï¼Œé»˜è®¤0.7ï¼‰

    # Gemini API è¯·æ±‚é…ç½®ï¼ˆé˜²æ­¢ 429 é™æµï¼‰
    gemini_request_delay: float = 2.0  # è¯·æ±‚é—´éš”ï¼ˆç§’ï¼‰
    gemini_max_retries: int = 5  # æœ€å¤§é‡è¯•æ¬¡æ•°
    gemini_retry_delay: float = 5.0  # é‡è¯•åŸºç¡€å»¶æ—¶ï¼ˆç§’ï¼‰

    # OpenAI å…¼å®¹ APIï¼ˆå¤‡é€‰ï¼Œå½“ Gemini ä¸å¯ç”¨æ—¶ä½¿ç”¨ï¼‰
    openai_api_key: Optional[str] = None
    openai_base_url: Optional[str] = None  # å¦‚: https://api.openai.com/v1
    openai_model: str = "gpt-4o-mini"  # OpenAI å…¼å®¹æ¨¡å‹åç§°
    openai_temperature: float = 0.7  # OpenAI æ¸©åº¦å‚æ•°ï¼ˆ0.0-2.0ï¼Œé»˜è®¤0.7ï¼‰
    
    # === æœç´¢å¼•æ“é…ç½®ï¼ˆæ”¯æŒå¤š Key è´Ÿè½½å‡è¡¡ï¼‰===
    bocha_api_keys: List[str] = field(default_factory=list)  # Bocha API Keys
    tavily_api_keys: List[str] = field(default_factory=list)  # Tavily API Keys
    serpapi_keys: List[str] = field(default_factory=list)  # SerpAPI Keys
    
    # === é€šçŸ¥é…ç½®ï¼ˆå¯åŒæ—¶é…ç½®å¤šä¸ªï¼Œå…¨éƒ¨æ¨é€ï¼‰===
    
    # ä¼ä¸šå¾®ä¿¡ Webhook
    wechat_webhook_url: Optional[str] = None
    
    # é£ä¹¦ Webhook
    feishu_webhook_url: Optional[str] = None
    
    # Telegram é…ç½®ï¼ˆéœ€è¦åŒæ—¶é…ç½® Bot Token å’Œ Chat IDï¼‰
    telegram_bot_token: Optional[str] = None  # Bot Tokenï¼ˆ@BotFather è·å–ï¼‰
    telegram_chat_id: Optional[str] = None  # Chat ID
    telegram_message_thread_id: Optional[str] = None  # Topic ID (Message Thread ID) for groups
    
    # é‚®ä»¶é…ç½®ï¼ˆåªéœ€é‚®ç®±å’Œæˆæƒç ï¼ŒSMTP è‡ªåŠ¨è¯†åˆ«ï¼‰
    email_sender: Optional[str] = None  # å‘ä»¶äººé‚®ç®±
    email_password: Optional[str] = None  # é‚®ç®±å¯†ç /æˆæƒç 
    email_receivers: List[str] = field(default_factory=list)  # æ”¶ä»¶äººåˆ—è¡¨ï¼ˆç•™ç©ºåˆ™å‘ç»™è‡ªå·±ï¼‰
    
    # Pushover é…ç½®ï¼ˆæ‰‹æœº/æ¡Œé¢æ¨é€é€šçŸ¥ï¼‰
    pushover_user_key: Optional[str] = None  # ç”¨æˆ· Keyï¼ˆhttps://pushover.net è·å–ï¼‰
    pushover_api_token: Optional[str] = None  # åº”ç”¨ API Token
    
    # è‡ªå®šä¹‰ Webhookï¼ˆæ”¯æŒå¤šä¸ªï¼Œé€—å·åˆ†éš”ï¼‰
    # é€‚ç”¨äºï¼šé’‰é’‰ã€Discordã€Slackã€è‡ªå»ºæœåŠ¡ç­‰ä»»æ„æ”¯æŒ POST JSON çš„ Webhook
    custom_webhook_urls: List[str] = field(default_factory=list)
    custom_webhook_bearer_token: Optional[str] = None  # Bearer Tokenï¼ˆç”¨äºéœ€è¦è®¤è¯çš„ Webhookï¼‰
    
    # Discord é€šçŸ¥é…ç½®
    discord_bot_token: Optional[str] = None  # Discord Bot Token
    discord_main_channel_id: Optional[str] = None  # Discord ä¸»é¢‘é“ ID
    discord_webhook_url: Optional[str] = None  # Discord Webhook URL

    # AstrBot é€šçŸ¥é…ç½®
    astrbot_token: Optional[str] = None
    astrbot_url: Optional[str] = None

    # å•è‚¡æ¨é€æ¨¡å¼ï¼šæ¯åˆ†æå®Œä¸€åªè‚¡ç¥¨ç«‹å³æ¨é€ï¼Œè€Œä¸æ˜¯æ±‡æ€»åæ¨é€
    single_stock_notify: bool = False

    # æŠ¥å‘Šç±»å‹ï¼šsimple(ç²¾ç®€) æˆ– full(å®Œæ•´)
    report_type: str = "simple"

    # PushPlus æ¨é€é…ç½®
    pushplus_token: Optional[str] = None  # PushPlus Token

    # åˆ†æé—´éš”æ—¶é—´ï¼ˆç§’ï¼‰- ç”¨äºé¿å…APIé™æµ
    analysis_delay: float = 0.0  # ä¸ªè‚¡åˆ†æä¸å¤§ç›˜åˆ†æä¹‹é—´çš„å»¶è¿Ÿ

    # æ¶ˆæ¯é•¿åº¦é™åˆ¶ï¼ˆå­—èŠ‚ï¼‰- è¶…é•¿è‡ªåŠ¨åˆ†æ‰¹å‘é€
    feishu_max_bytes: int = 20000  # é£ä¹¦é™åˆ¶çº¦ 20KBï¼Œé»˜è®¤ 20000 å­—èŠ‚
    wechat_max_bytes: int = 4000   # ä¼ä¸šå¾®ä¿¡é™åˆ¶ 4096 å­—èŠ‚ï¼Œé»˜è®¤ 4000 å­—èŠ‚
    wechat_msg_type: str = "markdown"  # ä¼ä¸šå¾®ä¿¡æ¶ˆæ¯ç±»å‹ï¼Œé»˜è®¤ markdown ç±»å‹
    
    # === æ•°æ®åº“é…ç½® ===
    database_path: str = "./data/stock_analysis.db"

    # æ˜¯å¦ä¿å­˜åˆ†æä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆç”¨äºå†å²å›æº¯ï¼‰
    save_context_snapshot: bool = True
    
    # === æ—¥å¿—é…ç½® ===
    log_dir: str = "./logs"  # æ—¥å¿—æ–‡ä»¶ç›®å½•
    log_level: str = "INFO"  # æ—¥å¿—çº§åˆ«
    
    # === ç³»ç»Ÿé…ç½® ===
    max_workers: int = 3  # ä½å¹¶å‘é˜²å°ç¦
    debug: bool = False
    http_proxy: Optional[str] = None  # HTTP ä»£ç† (ä¾‹å¦‚: http://127.0.0.1:10809)
    https_proxy: Optional[str] = None # HTTPS ä»£ç†
    
    # === å®šæ—¶ä»»åŠ¡é…ç½® ===
    schedule_enabled: bool = False            # æ˜¯å¦å¯ç”¨å®šæ—¶ä»»åŠ¡
    schedule_time: str = "18:00"              # æ¯æ—¥æ¨é€æ—¶é—´ï¼ˆHH:MM æ ¼å¼ï¼‰
    market_review_enabled: bool = True        # æ˜¯å¦å¯ç”¨å¤§ç›˜å¤ç›˜

    # === å®æ—¶è¡Œæƒ…å¢å¼ºæ•°æ®é…ç½® ===
    # å®æ—¶è¡Œæƒ…å¼€å…³ï¼ˆå…³é—­åä½¿ç”¨å†å²æ”¶ç›˜ä»·è¿›è¡Œåˆ†æï¼‰
    enable_realtime_quote: bool = True
    # ç­¹ç åˆ†å¸ƒå¼€å…³ï¼ˆè¯¥æ¥å£ä¸ç¨³å®šï¼Œäº‘ç«¯éƒ¨ç½²å»ºè®®å…³é—­ï¼‰
    enable_chip_distribution: bool = True
    # å®æ—¶è¡Œæƒ…æ•°æ®æºä¼˜å…ˆçº§ï¼ˆé€—å·åˆ†éš”ï¼‰
    # æ¨èé¡ºåºï¼štencent > akshare_sina > efinance > akshare_em > tushare
    # - tencent: è…¾è®¯è´¢ç»ï¼Œæœ‰é‡æ¯”/æ¢æ‰‹ç‡/å¸‚ç›ˆç‡ç­‰ï¼Œå•è‚¡æŸ¥è¯¢ç¨³å®šï¼ˆæ¨èï¼‰
    # - akshare_sina: æ–°æµªè´¢ç»ï¼ŒåŸºæœ¬è¡Œæƒ…ç¨³å®šï¼Œä½†æ— é‡æ¯”
    # - efinance/akshare_em: ä¸œè´¢å…¨é‡æ¥å£ï¼Œæ•°æ®æœ€å…¨ä½†å®¹æ˜“è¢«å°
    # - tushare: Tushare Proï¼Œéœ€è¦2000ç§¯åˆ†ï¼Œæ•°æ®å…¨é¢ï¼ˆä»˜è´¹ç”¨æˆ·å¯ä¼˜å…ˆä½¿ç”¨ï¼‰
    realtime_source_priority: str = "tencent,akshare_sina,efinance,akshare_em"
    # å®æ—¶è¡Œæƒ…ç¼“å­˜æ—¶é—´ï¼ˆç§’ï¼‰
    realtime_cache_ttl: int = 600
    # ç†”æ–­å™¨å†·å´æ—¶é—´ï¼ˆç§’ï¼‰
    circuit_breaker_cooldown: int = 300

    # Discord æœºå™¨äººçŠ¶æ€
    discord_bot_status: str = "Aè‚¡æ™ºèƒ½åˆ†æ | /help"

    # === æµæ§é…ç½®ï¼ˆé˜²å°ç¦å…³é”®å‚æ•°ï¼‰===
    # Akshare è¯·æ±‚é—´éš”èŒƒå›´ï¼ˆç§’ï¼‰
    akshare_sleep_min: float = 2.0
    akshare_sleep_max: float = 5.0
    
    # Tushare æ¯åˆ†é’Ÿæœ€å¤§è¯·æ±‚æ•°ï¼ˆå…è´¹é…é¢ï¼‰
    tushare_rate_limit_per_minute: int = 80
    
    # é‡è¯•é…ç½®
    max_retries: int = 3
    retry_base_delay: float = 1.0
    retry_max_delay: float = 30.0
    
    # === WebUI é…ç½® ===
    webui_enabled: bool = False
    webui_host: str = "127.0.0.1"
    webui_port: int = 8000
    
    # === æœºå™¨äººé…ç½® ===
    bot_enabled: bool = True              # æ˜¯å¦å¯ç”¨æœºå™¨äººåŠŸèƒ½
    bot_command_prefix: str = "/"         # å‘½ä»¤å‰ç¼€
    bot_rate_limit_requests: int = 10     # é¢‘ç‡é™åˆ¶ï¼šçª—å£å†…æœ€å¤§è¯·æ±‚æ•°
    bot_rate_limit_window: int = 60       # é¢‘ç‡é™åˆ¶ï¼šçª—å£æ—¶é—´ï¼ˆç§’ï¼‰
    bot_admin_users: List[str] = field(default_factory=list)  # ç®¡ç†å‘˜ç”¨æˆ· ID åˆ—è¡¨
    
    # é£ä¹¦æœºå™¨äººï¼ˆäº‹ä»¶è®¢é˜…ï¼‰- å·²æœ‰ feishu_app_id, feishu_app_secret
    feishu_verification_token: Optional[str] = None  # äº‹ä»¶è®¢é˜…éªŒè¯ Token
    feishu_encrypt_key: Optional[str] = None         # æ¶ˆæ¯åŠ å¯†å¯†é’¥ï¼ˆå¯é€‰ï¼‰
    feishu_stream_enabled: bool = False              # æ˜¯å¦å¯ç”¨ Stream é•¿è¿æ¥æ¨¡å¼ï¼ˆæ— éœ€å…¬ç½‘IPï¼‰
    
    # é’‰é’‰æœºå™¨äºº
    dingtalk_app_key: Optional[str] = None      # åº”ç”¨ AppKey
    dingtalk_app_secret: Optional[str] = None   # åº”ç”¨ AppSecret
    dingtalk_stream_enabled: bool = False       # æ˜¯å¦å¯ç”¨ Stream æ¨¡å¼ï¼ˆæ— éœ€å…¬ç½‘IPï¼‰
    
    # ä¼ä¸šå¾®ä¿¡æœºå™¨äººï¼ˆå›è°ƒæ¨¡å¼ï¼‰
    wecom_corpid: Optional[str] = None              # ä¼ä¸š ID
    wecom_token: Optional[str] = None               # å›è°ƒ Token
    wecom_encoding_aes_key: Optional[str] = None    # æ¶ˆæ¯åŠ è§£å¯†å¯†é’¥
    wecom_agent_id: Optional[str] = None            # åº”ç”¨ AgentId
    
    # Telegram æœºå™¨äºº - å·²æœ‰ telegram_bot_token, telegram_chat_id
    telegram_webhook_secret: Optional[str] = None   # Webhook å¯†é’¥
    
    # Discord æœºå™¨äººæ‰©å±•é…ç½®
    discord_bot_status: str = "Aè‚¡æ™ºèƒ½åˆ†æ | /help"  # æœºå™¨äººçŠ¶æ€ä¿¡æ¯
    
    # å•ä¾‹å®ä¾‹å­˜å‚¨
    _instance: Optional['Config'] = None
    
    @classmethod
    def get_instance(cls) -> 'Config':
        """
        è·å–é…ç½®å•ä¾‹å®ä¾‹
        
        å•ä¾‹æ¨¡å¼ç¡®ä¿ï¼š
        1. å…¨å±€åªæœ‰ä¸€ä¸ªé…ç½®å®ä¾‹
        2. é…ç½®åªä»ç¯å¢ƒå˜é‡åŠ è½½ä¸€æ¬¡
        3. æ‰€æœ‰æ¨¡å—å…±äº«ç›¸åŒé…ç½®
        """
        if cls._instance is None:
            cls._instance = cls._load_from_env()
        return cls._instance
    
    @classmethod
    def _load_from_env(cls) -> 'Config':
        """
        ä» .env æ–‡ä»¶åŠ è½½é…ç½®
        
        åŠ è½½ä¼˜å…ˆçº§ï¼š
        1. ç³»ç»Ÿç¯å¢ƒå˜é‡
        2. .env æ–‡ä»¶
        3. ä»£ç ä¸­çš„é»˜è®¤å€¼
        """
        # ç¡®ä¿ç¯å¢ƒå˜é‡å·²åŠ è½½
        setup_env()

        # === æ™ºèƒ½ä»£ç†é…ç½® (å…³é”®ä¿®å¤) ===
        # å¦‚æœé…ç½®äº†ä»£ç†ï¼Œè‡ªåŠ¨è®¾ç½® NO_PROXY ä»¥æ’é™¤å›½å†…æ•°æ®æºï¼Œé¿å…è¡Œæƒ…è·å–å¤±è´¥
        http_proxy = os.getenv('HTTP_PROXY') or os.getenv('http_proxy')
        if http_proxy:
            # å›½å†…é‡‘èæ•°æ®æºåŸŸååˆ—è¡¨
            domestic_domains = [
                'eastmoney.com',   # ä¸œæ–¹è´¢å¯Œ (Efinance/Akshare)
                'sina.com.cn',     # æ–°æµªè´¢ç» (Akshare)
                '163.com',         # ç½‘æ˜“è´¢ç» (Akshare)
                'tushare.pro',     # Tushare
                'baostock.com',    # Baostock
                'sse.com.cn',      # ä¸Šäº¤æ‰€
                'szse.cn',         # æ·±äº¤æ‰€
                'csindex.com.cn',  # ä¸­è¯æŒ‡æ•°
                'cninfo.com.cn',   # å·¨æ½®èµ„è®¯
                'localhost',
                '127.0.0.1'
            ]

            # è·å–ç°æœ‰çš„ no_proxy
            current_no_proxy = os.getenv('NO_PROXY') or os.getenv('no_proxy') or ''
            existing_domains = current_no_proxy.split(',') if current_no_proxy else []

            # åˆå¹¶å»é‡
            final_domains = list(set(existing_domains + domestic_domains))
            final_no_proxy = ','.join(filter(None, final_domains))

            # è®¾ç½®ç¯å¢ƒå˜é‡ (requests/urllib3/aiohttp éƒ½ä¼šéµå®ˆæ­¤è®¾ç½®)
            os.environ['NO_PROXY'] = final_no_proxy
            os.environ['no_proxy'] = final_no_proxy

            # ç¡®ä¿ HTTP_PROXY ä¹Ÿè¢«æ­£ç¡®è®¾ç½®ï¼ˆä»¥é˜²ä»…åœ¨ .env ä¸­å®šä¹‰ä½†æœªå¯¼å‡ºï¼‰
            os.environ['HTTP_PROXY'] = http_proxy
            os.environ['http_proxy'] = http_proxy

            # HTTPS_PROXY åŒç†
            https_proxy = os.getenv('HTTPS_PROXY') or os.getenv('https_proxy')
            if https_proxy:
                os.environ['HTTPS_PROXY'] = https_proxy
                os.environ['https_proxy'] = https_proxy

        
        # è§£æè‡ªé€‰è‚¡åˆ—è¡¨ï¼ˆé€—å·åˆ†éš”ï¼‰
        stock_list_str = os.getenv('STOCK_LIST', '')
        stock_list = [
            code.strip() 
            for code in stock_list_str.split(',') 
            if code.strip()
        ]
        
        # å¦‚æœæ²¡æœ‰é…ç½®ï¼Œä½¿ç”¨é»˜è®¤çš„ç¤ºä¾‹è‚¡ç¥¨
        if not stock_list:
            stock_list = ['600519', '000001', '300750']
        
        # è§£ææœç´¢å¼•æ“ API Keysï¼ˆæ”¯æŒå¤šä¸ª keyï¼Œé€—å·åˆ†éš”ï¼‰
        bocha_keys_str = os.getenv('BOCHA_API_KEYS', '')
        bocha_api_keys = [k.strip() for k in bocha_keys_str.split(',') if k.strip()]
        
        tavily_keys_str = os.getenv('TAVILY_API_KEYS', '')
        tavily_api_keys = [k.strip() for k in tavily_keys_str.split(',') if k.strip()]
        
        serpapi_keys_str = os.getenv('SERPAPI_API_KEYS', '')
        serpapi_keys = [k.strip() for k in serpapi_keys_str.split(',') if k.strip()]

        # ä¼å¾®æ¶ˆæ¯ç±»å‹ä¸æœ€å¤§å­—èŠ‚æ•°é€»è¾‘
        wechat_msg_type = os.getenv('WECHAT_MSG_TYPE', 'markdown')
        wechat_msg_type_lower = wechat_msg_type.lower()
        wechat_max_bytes_env = os.getenv('WECHAT_MAX_BYTES')
        if wechat_max_bytes_env not in (None, ''):
            wechat_max_bytes = int(wechat_max_bytes_env)
        else:
            # æœªæ˜¾å¼é…ç½®æ—¶ï¼Œæ ¹æ®æ¶ˆæ¯ç±»å‹é€‰æ‹©é»˜è®¤å­—èŠ‚æ•°
            wechat_max_bytes = 2048 if wechat_msg_type_lower == 'text' else 4000
        
        return cls(
            stock_list=stock_list,
            feishu_app_id=os.getenv('FEISHU_APP_ID'),
            feishu_app_secret=os.getenv('FEISHU_APP_SECRET'),
            feishu_folder_token=os.getenv('FEISHU_FOLDER_TOKEN'),
            tushare_token=os.getenv('TUSHARE_TOKEN'),
            gemini_api_key=os.getenv('GEMINI_API_KEY'),
            gemini_model=os.getenv('GEMINI_MODEL', 'gemini-3-flash-preview'),
            gemini_model_fallback=os.getenv('GEMINI_MODEL_FALLBACK', 'gemini-2.5-flash'),
            gemini_temperature=float(os.getenv('GEMINI_TEMPERATURE', '0.7')),
            gemini_request_delay=float(os.getenv('GEMINI_REQUEST_DELAY', '2.0')),
            gemini_max_retries=int(os.getenv('GEMINI_MAX_RETRIES', '5')),
            gemini_retry_delay=float(os.getenv('GEMINI_RETRY_DELAY', '5.0')),
            openai_api_key=os.getenv('OPENAI_API_KEY'),
            openai_base_url=os.getenv('OPENAI_BASE_URL'),
            openai_model=os.getenv('OPENAI_MODEL', 'gpt-4o-mini'),
            openai_temperature=float(os.getenv('OPENAI_TEMPERATURE', '0.7')),
            bocha_api_keys=bocha_api_keys,
            tavily_api_keys=tavily_api_keys,
            serpapi_keys=serpapi_keys,
            wechat_webhook_url=os.getenv('WECHAT_WEBHOOK_URL'),
            feishu_webhook_url=os.getenv('FEISHU_WEBHOOK_URL'),
            telegram_bot_token=os.getenv('TELEGRAM_BOT_TOKEN'),
            telegram_chat_id=os.getenv('TELEGRAM_CHAT_ID'),
            telegram_message_thread_id=os.getenv('TELEGRAM_MESSAGE_THREAD_ID'),
            email_sender=os.getenv('EMAIL_SENDER'),
            email_password=os.getenv('EMAIL_PASSWORD'),
            email_receivers=[r.strip() for r in os.getenv('EMAIL_RECEIVERS', '').split(',') if r.strip()],
            pushover_user_key=os.getenv('PUSHOVER_USER_KEY'),
            pushover_api_token=os.getenv('PUSHOVER_API_TOKEN'),
            pushplus_token=os.getenv('PUSHPLUS_TOKEN'),
            custom_webhook_urls=[u.strip() for u in os.getenv('CUSTOM_WEBHOOK_URLS', '').split(',') if u.strip()],
            custom_webhook_bearer_token=os.getenv('CUSTOM_WEBHOOK_BEARER_TOKEN'),
            discord_bot_token=os.getenv('DISCORD_BOT_TOKEN'),
            discord_main_channel_id=os.getenv('DISCORD_MAIN_CHANNEL_ID'),
            discord_webhook_url=os.getenv('DISCORD_WEBHOOK_URL'),
            astrbot_url=os.getenv('ASTRBOT_URL'),
            astrbot_token=os.getenv('ASTRBOT_TOKEN'),
            single_stock_notify=os.getenv('SINGLE_STOCK_NOTIFY', 'false').lower() == 'true',
            report_type=os.getenv('REPORT_TYPE', 'simple').lower(),
            analysis_delay=float(os.getenv('ANALYSIS_DELAY', '0')),
            feishu_max_bytes=int(os.getenv('FEISHU_MAX_BYTES', '20000')),
            wechat_max_bytes=wechat_max_bytes,
            wechat_msg_type=wechat_msg_type_lower,
            database_path=os.getenv('DATABASE_PATH', './data/stock_analysis.db'),
            save_context_snapshot=os.getenv('SAVE_CONTEXT_SNAPSHOT', 'true').lower() == 'true',
            log_dir=os.getenv('LOG_DIR', './logs'),
            log_level=os.getenv('LOG_LEVEL', 'INFO'),
            max_workers=int(os.getenv('MAX_WORKERS', '3')),
            debug=os.getenv('DEBUG', 'false').lower() == 'true',
            http_proxy=os.getenv('HTTP_PROXY'),
            https_proxy=os.getenv('HTTPS_PROXY'),
            schedule_enabled=os.getenv('SCHEDULE_ENABLED', 'false').lower() == 'true',
            schedule_time=os.getenv('SCHEDULE_TIME', '18:00'),
            market_review_enabled=os.getenv('MARKET_REVIEW_ENABLED', 'true').lower() == 'true',
            webui_enabled=os.getenv('WEBUI_ENABLED', 'false').lower() == 'true',
            webui_host=os.getenv('WEBUI_HOST', '127.0.0.1'),
            webui_port=int(os.getenv('WEBUI_PORT', '8000')),
            # æœºå™¨äººé…ç½®
            bot_enabled=os.getenv('BOT_ENABLED', 'true').lower() == 'true',
            bot_command_prefix=os.getenv('BOT_COMMAND_PREFIX', '/'),
            bot_rate_limit_requests=int(os.getenv('BOT_RATE_LIMIT_REQUESTS', '10')),
            bot_rate_limit_window=int(os.getenv('BOT_RATE_LIMIT_WINDOW', '60')),
            bot_admin_users=[u.strip() for u in os.getenv('BOT_ADMIN_USERS', '').split(',') if u.strip()],
            # é£ä¹¦æœºå™¨äºº
            feishu_verification_token=os.getenv('FEISHU_VERIFICATION_TOKEN'),
            feishu_encrypt_key=os.getenv('FEISHU_ENCRYPT_KEY'),
            feishu_stream_enabled=os.getenv('FEISHU_STREAM_ENABLED', 'false').lower() == 'true',
            # é’‰é’‰æœºå™¨äºº
            dingtalk_app_key=os.getenv('DINGTALK_APP_KEY'),
            dingtalk_app_secret=os.getenv('DINGTALK_APP_SECRET'),
            dingtalk_stream_enabled=os.getenv('DINGTALK_STREAM_ENABLED', 'false').lower() == 'true',
            # ä¼ä¸šå¾®ä¿¡æœºå™¨äºº
            wecom_corpid=os.getenv('WECOM_CORPID'),
            wecom_token=os.getenv('WECOM_TOKEN'),
            wecom_encoding_aes_key=os.getenv('WECOM_ENCODING_AES_KEY'),
            wecom_agent_id=os.getenv('WECOM_AGENT_ID'),
            # Telegram
            telegram_webhook_secret=os.getenv('TELEGRAM_WEBHOOK_SECRET'),
            # Discord æœºå™¨äººæ‰©å±•é…ç½®
            discord_bot_status=os.getenv('DISCORD_BOT_STATUS', 'Aè‚¡æ™ºèƒ½åˆ†æ | /help'),
            # å®æ—¶è¡Œæƒ…å¢å¼ºæ•°æ®é…ç½®
            enable_realtime_quote=os.getenv('ENABLE_REALTIME_QUOTE', 'true').lower() == 'true',
            enable_chip_distribution=os.getenv('ENABLE_CHIP_DISTRIBUTION', 'true').lower() == 'true',
            # å®æ—¶è¡Œæƒ…æ•°æ®æºä¼˜å…ˆçº§ï¼š
            # - tencent: è…¾è®¯è´¢ç»ï¼Œæœ‰é‡æ¯”/æ¢æ‰‹ç‡/PE/PBç­‰ï¼Œå•è‚¡æŸ¥è¯¢ç¨³å®šï¼ˆæ¨èï¼‰
            # - akshare_sina: æ–°æµªè´¢ç»ï¼ŒåŸºæœ¬è¡Œæƒ…ç¨³å®šï¼Œä½†æ— é‡æ¯”
            # - efinance/akshare_em: ä¸œè´¢å…¨é‡æ¥å£ï¼Œæ•°æ®æœ€å…¨ä½†å®¹æ˜“è¢«å°
            # - tushare: Tushare Proï¼Œéœ€è¦2000ç§¯åˆ†ï¼Œæ•°æ®å…¨é¢
            realtime_source_priority=os.getenv('REALTIME_SOURCE_PRIORITY', 'tencent,akshare_sina,efinance,akshare_em'),
            realtime_cache_ttl=int(os.getenv('REALTIME_CACHE_TTL', '600')),
            circuit_breaker_cooldown=int(os.getenv('CIRCUIT_BREAKER_COOLDOWN', '300'))
        )
    
    @classmethod
    def reset_instance(cls) -> None:
        """é‡ç½®å•ä¾‹ï¼ˆä¸»è¦ç”¨äºæµ‹è¯•ï¼‰"""
        cls._instance = None

    def refresh_stock_list(self) -> None:
        """
        çƒ­è¯»å– STOCK_LIST ç¯å¢ƒå˜é‡å¹¶æ›´æ–°é…ç½®ä¸­çš„è‡ªé€‰è‚¡åˆ—è¡¨
        
        æ”¯æŒä¸¤ç§é…ç½®æ–¹å¼ï¼š
        1. .env æ–‡ä»¶ï¼ˆæœ¬åœ°å¼€å‘ã€å®šæ—¶ä»»åŠ¡æ¨¡å¼ï¼‰ - ä¿®æ”¹åä¸‹æ¬¡æ‰§è¡Œè‡ªåŠ¨ç”Ÿæ•ˆ
        2. ç³»ç»Ÿç¯å¢ƒå˜é‡ï¼ˆGitHub Actionsã€Dockerï¼‰ - å¯åŠ¨æ—¶å›ºå®šï¼Œè¿è¡Œä¸­ä¸å˜
        """
        # ä¼˜å…ˆä» .env æ–‡ä»¶è¯»å–æœ€æ–°é…ç½®ï¼Œè¿™æ ·å³ä½¿åœ¨å®¹å™¨ç¯å¢ƒä¸­ä¿®æ”¹äº† .env æ–‡ä»¶ï¼Œ
        # ä¹Ÿèƒ½è·å–åˆ°æœ€æ–°çš„è‚¡ç¥¨åˆ—è¡¨é…ç½®
        env_path = Path(__file__).parent.parent / '.env'
        stock_list_str = ''
        if env_path.exists():
            # ç›´æ¥ä» .env æ–‡ä»¶è¯»å–æœ€æ–°çš„é…ç½®
            env_values = dotenv_values(env_path)
            stock_list_str = (env_values.get('STOCK_LIST') or '').strip()

        # å¦‚æœ .env æ–‡ä»¶ä¸å­˜åœ¨æˆ–æœªé…ç½®ï¼Œæ‰å°è¯•ä»ç³»ç»Ÿç¯å¢ƒå˜é‡è¯»å–
        if not stock_list_str:
            stock_list_str = os.getenv('STOCK_LIST', '')

        stock_list = [
            code.strip()
            for code in stock_list_str.split(',')
            if code.strip()
        ]

        if not stock_list:        
            stock_list = ['000001']

        self.stock_list = stock_list
    
    def validate(self) -> List[str]:
        """
        éªŒè¯é…ç½®å®Œæ•´æ€§
        
        Returns:
            ç¼ºå¤±æˆ–æ— æ•ˆé…ç½®é¡¹çš„è­¦å‘Šåˆ—è¡¨
        """
        warnings = []
        
        if not self.stock_list:
            warnings.append("è­¦å‘Šï¼šæœªé…ç½®è‡ªé€‰è‚¡åˆ—è¡¨ (STOCK_LIST)")
        
        if not self.tushare_token:
            warnings.append("æç¤ºï¼šæœªé…ç½® Tushare Tokenï¼Œå°†ä½¿ç”¨å…¶ä»–æ•°æ®æº")
        
        if not self.gemini_api_key and not self.openai_api_key:
            warnings.append("è­¦å‘Šï¼šæœªé…ç½® Gemini æˆ– OpenAI API Keyï¼ŒAI åˆ†æåŠŸèƒ½å°†ä¸å¯ç”¨")
        elif not self.gemini_api_key:
            warnings.append("æç¤ºï¼šæœªé…ç½® Gemini API Keyï¼Œå°†ä½¿ç”¨ OpenAI å…¼å®¹ API")
        
        if not self.bocha_api_keys and not self.tavily_api_keys and not self.serpapi_keys:
            warnings.append("æç¤ºï¼šæœªé…ç½®æœç´¢å¼•æ“ API Key (Bocha/Tavily/SerpAPI)ï¼Œæ–°é—»æœç´¢åŠŸèƒ½å°†ä¸å¯ç”¨")
        
        # æ£€æŸ¥é€šçŸ¥é…ç½®
        has_notification = (
            self.wechat_webhook_url or
            self.feishu_webhook_url or
            (self.telegram_bot_token and self.telegram_chat_id) or
            (self.email_sender and self.email_password) or
            (self.pushover_user_key and self.pushover_api_token) or
            self.pushplus_token or
            (self.custom_webhook_urls and self.custom_webhook_bearer_token) or
            (self.discord_bot_token and self.discord_main_channel_id) or
            self.discord_webhook_url
        )
        if not has_notification:
            warnings.append("æç¤ºï¼šæœªé…ç½®é€šçŸ¥æ¸ é“ï¼Œå°†ä¸å‘é€æ¨é€é€šçŸ¥")
        
        return warnings
    
    def get_db_url(self) -> str:
        """
        è·å– SQLAlchemy æ•°æ®åº“è¿æ¥ URL
        
        è‡ªåŠ¨åˆ›å»ºæ•°æ®åº“ç›®å½•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        """
        db_path = Path(self.database_path)
        db_path.parent.mkdir(parents=True, exist_ok=True)
        return f"sqlite:///{db_path.absolute()}"


# === ä¾¿æ·çš„é…ç½®è®¿é—®å‡½æ•° ===
def get_config() -> Config:
    """è·å–å…¨å±€é…ç½®å®ä¾‹çš„å¿«æ·æ–¹å¼"""
    return Config.get_instance()


if __name__ == "__main__":
    # æµ‹è¯•é…ç½®åŠ è½½
    config = get_config()
    print("=== é…ç½®åŠ è½½æµ‹è¯• ===")
    print(f"è‡ªé€‰è‚¡åˆ—è¡¨: {config.stock_list}")
    print(f"æ•°æ®åº“è·¯å¾„: {config.database_path}")
    print(f"æœ€å¤§å¹¶å‘æ•°: {config.max_workers}")
    print(f"è°ƒè¯•æ¨¡å¼: {config.debug}")
    
    # éªŒè¯é…ç½®
    warnings = config.validate()
    if warnings:
        print("\né…ç½®éªŒè¯ç»“æœ:")
        for w in warnings:
            print(f"  - {w}")

--------------------

#File: src/formatters.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
æ ¼å¼åŒ–å·¥å…·æ¨¡å—
===================================

æä¾›å„ç§å†…å®¹æ ¼å¼åŒ–å·¥å…·å‡½æ•°ï¼Œç”¨äºå°†é€šç”¨æ ¼å¼è½¬æ¢ä¸ºå¹³å°ç‰¹å®šæ ¼å¼ã€‚
"""

import re
import time
from typing import List, Callable


def format_feishu_markdown(content: str) -> str:
    """
    å°†é€šç”¨ Markdown è½¬æ¢ä¸ºé£ä¹¦ lark_md æ›´å‹å¥½çš„æ ¼å¼
    
    è½¬æ¢è§„åˆ™ï¼š
    - é£ä¹¦ä¸æ”¯æŒ Markdown æ ‡é¢˜ï¼ˆ# / ## / ###ï¼‰ï¼Œç”¨åŠ ç²—ä»£æ›¿
    - å¼•ç”¨å—ä½¿ç”¨å‰ç¼€æ›¿ä»£
    - åˆ†éš”çº¿ç»Ÿä¸€ä¸ºç»†çº¿
    - è¡¨æ ¼è½¬æ¢ä¸ºæ¡ç›®åˆ—è¡¨
    
    Args:
        content: åŸå§‹ Markdown å†…å®¹
        
    Returns:
        è½¬æ¢åçš„é£ä¹¦ Markdown æ ¼å¼å†…å®¹
        
    Example:
        >>> markdown = "# æ ‡é¢˜\\n> å¼•ç”¨\\n| åˆ—1 | åˆ—2 |"
        >>> formatted = format_feishu_markdown(markdown)
        >>> print(formatted)
        **æ ‡é¢˜**
        ğŸ’¬ å¼•ç”¨
        â€¢ åˆ—1ï¼šå€¼1 | åˆ—2ï¼šå€¼2
    """
    def _flush_table_rows(buffer: List[str], output: List[str]) -> None:
        """å°†è¡¨æ ¼ç¼“å†²åŒºä¸­çš„è¡Œè½¬æ¢ä¸ºé£ä¹¦æ ¼å¼"""
        if not buffer:
            return

        def _parse_row(row: str) -> List[str]:
            """è§£æè¡¨æ ¼è¡Œï¼Œæå–å•å…ƒæ ¼"""
            cells = [c.strip() for c in row.strip().strip('|').split('|')]
            return [c for c in cells if c]

        rows = []
        for raw in buffer:
            # è·³è¿‡åˆ†éš”è¡Œï¼ˆå¦‚ |---|---|ï¼‰
            if re.match(r'^\s*\|?\s*[:-]+\s*(\|\s*[:-]+\s*)+\|?\s*$', raw):
                continue
            parsed = _parse_row(raw)
            if parsed:
                rows.append(parsed)

        if not rows:
            return

        header = rows[0]
        data_rows = rows[1:] if len(rows) > 1 else []
        for row in data_rows:
            pairs = []
            for idx, cell in enumerate(row):
                key = header[idx] if idx < len(header) else f"åˆ—{idx + 1}"
                pairs.append(f"{key}ï¼š{cell}")
            output.append(f"â€¢ {' | '.join(pairs)}")

    lines = []
    table_buffer: List[str] = []

    for raw_line in content.splitlines():
        line = raw_line.rstrip()

        # å¤„ç†è¡¨æ ¼è¡Œ
        if line.strip().startswith('|'):
            table_buffer.append(line)
            continue

        # åˆ·æ–°è¡¨æ ¼ç¼“å†²åŒº
        if table_buffer:
            _flush_table_rows(table_buffer, lines)
            table_buffer = []

        # è½¬æ¢æ ‡é¢˜ï¼ˆ# ## ### ç­‰ï¼‰
        if re.match(r'^#{1,6}\s+', line):
            title = re.sub(r'^#{1,6}\s+', '', line).strip()
            line = f"**{title}**" if title else ""
        # è½¬æ¢å¼•ç”¨å—
        elif line.startswith('> '):
            quote = line[2:].strip()
            line = f"ğŸ’¬ {quote}" if quote else ""
        # è½¬æ¢åˆ†éš”çº¿
        elif line.strip() == '---':
            line = 'â”€â”€â”€â”€â”€â”€â”€â”€'
        # è½¬æ¢åˆ—è¡¨é¡¹
        elif line.startswith('- '):
            line = f"â€¢ {line[2:].strip()}"

        lines.append(line)

    # å¤„ç†æœ«å°¾çš„è¡¨æ ¼
    if table_buffer:
        _flush_table_rows(table_buffer, lines)

    return "\n".join(lines).strip()


def _chunk_by_lines(content: str, max_bytes: int, send_func: Callable[[str], bool]) -> bool:
    """
    å¼ºåˆ¶æŒ‰è¡Œåˆ†å‰²å‘é€ï¼ˆæ— æ³•æ™ºèƒ½åˆ†å‰²æ—¶çš„ fallbackï¼‰
    
    Args:
        content: å®Œæ•´æ¶ˆæ¯å†…å®¹
        max_bytes: å•æ¡æ¶ˆæ¯æœ€å¤§å­—èŠ‚æ•°
        send_func: å‘é€å•æ¡æ¶ˆæ¯çš„å‡½æ•°
        
    Returns:
        æ˜¯å¦å…¨éƒ¨å‘é€æˆåŠŸ
    """
    chunks = []
    current_chunk = ""
    
    # æŒ‰è¡Œåˆ†å‰²ï¼Œç¡®ä¿ä¸ä¼šåœ¨å¤šå­—èŠ‚å­—ç¬¦ä¸­é—´æˆªæ–­
    lines = content.split('\n')
    
    for line in lines:
        test_chunk = current_chunk + ('\n' if current_chunk else '') + line
        if len(test_chunk.encode('utf-8')) > max_bytes - 100:  # é¢„ç•™ç©ºé—´ç»™åˆ†é¡µæ ‡è®°
            if current_chunk:
                chunks.append(current_chunk)
            current_chunk = line
        else:
            current_chunk = test_chunk
    
    if current_chunk:
        chunks.append(current_chunk)
    
    total_chunks = len(chunks)
    success_count = 0
    
    for i, chunk in enumerate(chunks):
        # æ·»åŠ åˆ†é¡µæ ‡è®°
        page_marker = f"\n\nğŸ“„ ({i+1}/{total_chunks})" if total_chunks > 1 else ""
        
        try:
            if send_func(chunk + page_marker):
                success_count += 1
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"é£ä¹¦ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€å¼‚å¸¸: {e}")
        
        # æ‰¹æ¬¡é—´éš”ï¼Œé¿å…è§¦å‘é¢‘ç‡é™åˆ¶
        if i < total_chunks - 1:
            time.sleep(1)
    
    return success_count == total_chunks


def chunk_feishu_content(content: str, max_bytes: int, send_func: Callable[[str], bool]) -> bool:
    """
    å°†è¶…é•¿å†…å®¹åˆ†æ®µå‘é€åˆ°é£ä¹¦
    
    æ™ºèƒ½åˆ†å‰²ç­–ç•¥ï¼š
    1. ä¼˜å…ˆæŒ‰ "---" åˆ†éš”ï¼ˆè‚¡ç¥¨ä¹‹é—´çš„åˆ†éš”çº¿ï¼‰
    2. å…¶æ¬¡æŒ‰ "### " æ ‡é¢˜åˆ†å‰²ï¼ˆæ¯åªè‚¡ç¥¨çš„æ ‡é¢˜ï¼‰
    3. æœ€åæŒ‰è¡Œå¼ºåˆ¶åˆ†å‰²
    
    Args:
        content: å®Œæ•´æ¶ˆæ¯å†…å®¹
        max_bytes: å•æ¡æ¶ˆæ¯æœ€å¤§å­—èŠ‚æ•°
        send_func: å‘é€å•æ¡æ¶ˆæ¯çš„å‡½æ•°ï¼Œæ¥æ”¶å†…å®¹å­—ç¬¦ä¸²ï¼Œè¿”å›æ˜¯å¦æˆåŠŸ
        
    Returns:
        æ˜¯å¦å…¨éƒ¨å‘é€æˆåŠŸ
    """
    def get_bytes(s: str) -> int:
        """è·å–å­—ç¬¦ä¸²çš„ UTF-8 å­—èŠ‚æ•°"""
        return len(s.encode('utf-8'))
    
    def _truncate_to_bytes(text: str, max_bytes: int) -> str:
        """æŒ‰å­—èŠ‚æˆªæ–­æ–‡æœ¬ï¼Œç¡®ä¿ä¸ä¼šåœ¨å¤šå­—èŠ‚å­—ç¬¦ä¸­é—´æˆªæ–­"""
        encoded = text.encode('utf-8')
        if len(encoded) <= max_bytes:
            return text
        
        # ä»æœ€å¤§å­—èŠ‚æ•°å¼€å§‹å‘å‰æŸ¥æ‰¾ï¼Œæ‰¾åˆ°å®Œæ•´çš„ UTF-8 å­—ç¬¦è¾¹ç•Œ
        truncated = encoded[:max_bytes]
        while truncated and (truncated[-1] & 0xC0) == 0x80:
            truncated = truncated[:-1]
        
        return truncated.decode('utf-8', errors='ignore')
    
    # æ™ºèƒ½åˆ†å‰²ï¼šä¼˜å…ˆæŒ‰ "---" åˆ†éš”ï¼ˆè‚¡ç¥¨ä¹‹é—´çš„åˆ†éš”çº¿ï¼‰
    # å¦‚æœæ²¡æœ‰åˆ†éš”çº¿ï¼ŒæŒ‰ "### " æ ‡é¢˜åˆ†å‰²ï¼ˆæ¯åªè‚¡ç¥¨çš„æ ‡é¢˜ï¼‰
    if "\n---\n" in content:
        sections = content.split("\n---\n")
        separator = "\n---\n"
    elif "\n### " in content:
        # æŒ‰ ### åˆ†å‰²ï¼Œä½†ä¿ç•™ ### å‰ç¼€
        parts = content.split("\n### ")
        sections = [parts[0]] + [f"### {p}" for p in parts[1:]]
        separator = "\n"
    else:
        # æ— æ³•æ™ºèƒ½åˆ†å‰²ï¼ŒæŒ‰è¡Œå¼ºåˆ¶åˆ†å‰²
        return _chunk_by_lines(content, max_bytes, send_func)
    
    chunks = []
    current_chunk = []
    current_bytes = 0
    separator_bytes = get_bytes(separator)
    
    for section in sections:
        section_bytes = get_bytes(section) + separator_bytes
        
        # å¦‚æœå•ä¸ª section å°±è¶…é•¿ï¼Œéœ€è¦å¼ºåˆ¶æˆªæ–­
        if section_bytes > max_bytes:
            # å…ˆå‘é€å½“å‰ç§¯ç´¯çš„å†…å®¹
            if current_chunk:
                chunks.append(separator.join(current_chunk))
                current_chunk = []
                current_bytes = 0
            
            # å¼ºåˆ¶æˆªæ–­è¿™ä¸ªè¶…é•¿ sectionï¼ˆæŒ‰å­—èŠ‚æˆªæ–­ï¼‰
            truncated = _truncate_to_bytes(section, max_bytes - 200)
            truncated += "\n\n...(æœ¬æ®µå†…å®¹è¿‡é•¿å·²æˆªæ–­)"
            chunks.append(truncated)
            continue
        
        # æ£€æŸ¥åŠ å…¥åæ˜¯å¦è¶…é•¿
        if current_bytes + section_bytes > max_bytes:
            # ä¿å­˜å½“å‰å—ï¼Œå¼€å§‹æ–°å—
            if current_chunk:
                chunks.append(separator.join(current_chunk))
            current_chunk = [section]
            current_bytes = section_bytes
        else:
            current_chunk.append(section)
            current_bytes += section_bytes
    
    # æ·»åŠ æœ€åä¸€å—
    if current_chunk:
        chunks.append(separator.join(current_chunk))
    
    # åˆ†æ‰¹å‘é€
    total_chunks = len(chunks)
    success_count = 0
    
    for i, chunk in enumerate(chunks):
        # æ·»åŠ åˆ†é¡µæ ‡è®°
        if total_chunks > 1:
            page_marker = f"\n\nğŸ“„ ({i+1}/{total_chunks})"
            chunk_with_marker = chunk + page_marker
        else:
            chunk_with_marker = chunk
        
        try:
            if send_func(chunk_with_marker):
                success_count += 1
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"é£ä¹¦ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€å¼‚å¸¸: {e}")
        
        # æ‰¹æ¬¡é—´éš”ï¼Œé¿å…è§¦å‘é¢‘ç‡é™åˆ¶
        if i < total_chunks - 1:
            time.sleep(1)
    
    return success_count == total_chunks

--------------------

#File: src/notification.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Aè‚¡è‡ªé€‰è‚¡æ™ºèƒ½åˆ†æç³»ç»Ÿ - é€šçŸ¥å±‚
===================================

èŒè´£ï¼š
1. æ±‡æ€»åˆ†æç»“æœç”Ÿæˆæ—¥æŠ¥
2. æ”¯æŒ Markdown æ ¼å¼è¾“å‡º
3. å¤šæ¸ é“æ¨é€ï¼ˆè‡ªåŠ¨è¯†åˆ«ï¼‰ï¼š
   - ä¼ä¸šå¾®ä¿¡ Webhook
   - é£ä¹¦ Webhook
   - Telegram Bot
   - é‚®ä»¶ SMTP
   - Pushoverï¼ˆæ‰‹æœº/æ¡Œé¢æ¨é€ï¼‰
"""
import hashlib
import hmac
import logging
import json
import smtplib
import re
import markdown2
from datetime import datetime
from typing import List, Dict, Any, Optional
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header
from enum import Enum

import requests
try:
    import discord
    discord_available = True
except ImportError:
    discord_available = False

from src.config import get_config
from src.analyzer import AnalysisResult
from src.formatters import format_feishu_markdown
from bot.models import BotMessage

logger = logging.getLogger(__name__)


class NotificationChannel(Enum):
    """é€šçŸ¥æ¸ é“ç±»å‹"""
    WECHAT = "wechat"      # ä¼ä¸šå¾®ä¿¡
    FEISHU = "feishu"      # é£ä¹¦
    TELEGRAM = "telegram"  # Telegram
    EMAIL = "email"        # é‚®ä»¶
    PUSHOVER = "pushover"  # Pushoverï¼ˆæ‰‹æœº/æ¡Œé¢æ¨é€ï¼‰
    PUSHPLUS = "pushplus"  # PushPlusï¼ˆå›½å†…æ¨é€æœåŠ¡ï¼‰
    CUSTOM = "custom"      # è‡ªå®šä¹‰ Webhook
    DISCORD = "discord"    # Discord æœºå™¨äºº (Bot)
    ASTRBOT = "astrbot"
    UNKNOWN = "unknown"    # æœªçŸ¥


# SMTP æœåŠ¡å™¨é…ç½®ï¼ˆè‡ªåŠ¨è¯†åˆ«ï¼‰
SMTP_CONFIGS = {
    # QQé‚®ç®±
    "qq.com": {"server": "smtp.qq.com", "port": 465, "ssl": True},
    "foxmail.com": {"server": "smtp.qq.com", "port": 465, "ssl": True},
    # ç½‘æ˜“é‚®ç®±
    "163.com": {"server": "smtp.163.com", "port": 465, "ssl": True},
    "126.com": {"server": "smtp.126.com", "port": 465, "ssl": True},
    # Gmail
    "gmail.com": {"server": "smtp.gmail.com", "port": 587, "ssl": False},
    # Outlook
    "outlook.com": {"server": "smtp-mail.outlook.com", "port": 587, "ssl": False},
    "hotmail.com": {"server": "smtp-mail.outlook.com", "port": 587, "ssl": False},
    "live.com": {"server": "smtp-mail.outlook.com", "port": 587, "ssl": False},
    # æ–°æµª
    "sina.com": {"server": "smtp.sina.com", "port": 465, "ssl": True},
    # æœç‹
    "sohu.com": {"server": "smtp.sohu.com", "port": 465, "ssl": True},
    # é˜¿é‡Œäº‘
    "aliyun.com": {"server": "smtp.aliyun.com", "port": 465, "ssl": True},
    # 139é‚®ç®±
    "139.com": {"server": "smtp.139.com", "port": 465, "ssl": True},
}


class ChannelDetector:
    """
    æ¸ é“æ£€æµ‹å™¨ - ç®€åŒ–ç‰ˆ
    
    æ ¹æ®é…ç½®ç›´æ¥åˆ¤æ–­æ¸ é“ç±»å‹ï¼ˆä¸å†éœ€è¦ URL è§£æï¼‰
    """
    
    @staticmethod
    def get_channel_name(channel: NotificationChannel) -> str:
        """è·å–æ¸ é“ä¸­æ–‡åç§°"""
        names = {
            NotificationChannel.WECHAT: "ä¼ä¸šå¾®ä¿¡",
            NotificationChannel.FEISHU: "é£ä¹¦",
            NotificationChannel.TELEGRAM: "Telegram",
            NotificationChannel.EMAIL: "é‚®ä»¶",
            NotificationChannel.PUSHOVER: "Pushover",
            NotificationChannel.PUSHPLUS: "PushPlus",
            NotificationChannel.CUSTOM: "è‡ªå®šä¹‰Webhook",
            NotificationChannel.DISCORD: "Discordæœºå™¨äºº",
            NotificationChannel.ASTRBOT: "ASTRBOTæœºå™¨äºº",
            NotificationChannel.UNKNOWN: "æœªçŸ¥æ¸ é“",
        }
        return names.get(channel, "æœªçŸ¥æ¸ é“")


class NotificationService:
    """
    é€šçŸ¥æœåŠ¡
    
    èŒè´£ï¼š
    1. ç”Ÿæˆ Markdown æ ¼å¼çš„åˆ†ææ—¥æŠ¥
    2. å‘æ‰€æœ‰å·²é…ç½®çš„æ¸ é“æ¨é€æ¶ˆæ¯ï¼ˆå¤šæ¸ é“å¹¶å‘ï¼‰
    3. æ”¯æŒæœ¬åœ°ä¿å­˜æ—¥æŠ¥
    
    æ”¯æŒçš„æ¸ é“ï¼š
    - ä¼ä¸šå¾®ä¿¡ Webhook
    - é£ä¹¦ Webhook
    - Telegram Bot
    - é‚®ä»¶ SMTP
    - Pushoverï¼ˆæ‰‹æœº/æ¡Œé¢æ¨é€ï¼‰
    
    æ³¨æ„ï¼šæ‰€æœ‰å·²é…ç½®çš„æ¸ é“éƒ½ä¼šæ”¶åˆ°æ¨é€
    """
    
    def __init__(self, source_message: Optional[BotMessage] = None):
        """
        åˆå§‹åŒ–é€šçŸ¥æœåŠ¡
        
        æ£€æµ‹æ‰€æœ‰å·²é…ç½®çš„æ¸ é“ï¼Œæ¨é€æ—¶ä¼šå‘æ‰€æœ‰æ¸ é“å‘é€
        """
        config = get_config()
        self._source_message = source_message
        self._context_channels: List[str] = []
        
        # å„æ¸ é“çš„ Webhook URL
        self._wechat_url = config.wechat_webhook_url
        self._feishu_url = getattr(config, 'feishu_webhook_url', None)

        # å¾®ä¿¡æ¶ˆæ¯ç±»å‹é…ç½®
        self._wechat_msg_type = getattr(config, 'wechat_msg_type', 'markdown')
        # Telegram é…ç½®
        self._telegram_config = {
            'bot_token': getattr(config, 'telegram_bot_token', None),
            'chat_id': getattr(config, 'telegram_chat_id', None),
            'message_thread_id': getattr(config, 'telegram_message_thread_id', None),
        }
        
        # é‚®ä»¶é…ç½®
        self._email_config = {
            'sender': config.email_sender,
            'password': config.email_password,
            'receivers': config.email_receivers or ([config.email_sender] if config.email_sender else []),
        }
        
        # Pushover é…ç½®
        self._pushover_config = {
            'user_key': getattr(config, 'pushover_user_key', None),
            'api_token': getattr(config, 'pushover_api_token', None),
        }

        # PushPlus é…ç½®
        self._pushplus_token = getattr(config, 'pushplus_token', None)

        # è‡ªå®šä¹‰ Webhook é…ç½®
        self._custom_webhook_urls = getattr(config, 'custom_webhook_urls', []) or []
        self._custom_webhook_bearer_token = getattr(config, 'custom_webhook_bearer_token', None)
        
        # Discord é…ç½®
        self._discord_config = {
            'bot_token': getattr(config, 'discord_bot_token', None),
            'channel_id': getattr(config, 'discord_main_channel_id', None),
            'webhook_url': getattr(config, 'discord_webhook_url', None),
        }

        self._astrbot_config = {
            'astrbot_url': getattr(config, 'astrbot_url', None),
            'astrbot_token': getattr(config, 'astrbot_token', None),
        }
        
        # æ¶ˆæ¯é•¿åº¦é™åˆ¶ï¼ˆå­—èŠ‚ï¼‰
        self._feishu_max_bytes = getattr(config, 'feishu_max_bytes', 20000)
        self._wechat_max_bytes = getattr(config, 'wechat_max_bytes', 4000)
        
        # æ£€æµ‹æ‰€æœ‰å·²é…ç½®çš„æ¸ é“
        self._available_channels = self._detect_all_channels()
        if self._has_context_channel():
            self._context_channels.append("é’‰é’‰ä¼šè¯")
        
        if not self._available_channels and not self._context_channels:
            logger.warning("æœªé…ç½®æœ‰æ•ˆçš„é€šçŸ¥æ¸ é“ï¼Œå°†ä¸å‘é€æ¨é€é€šçŸ¥")
        else:
            channel_names = [ChannelDetector.get_channel_name(ch) for ch in self._available_channels]
            channel_names.extend(self._context_channels)
            logger.info(f"å·²é…ç½® {len(channel_names)} ä¸ªé€šçŸ¥æ¸ é“ï¼š{', '.join(channel_names)}")
    
    def _detect_all_channels(self) -> List[NotificationChannel]:
        """
        æ£€æµ‹æ‰€æœ‰å·²é…ç½®çš„æ¸ é“
        
        Returns:
            å·²é…ç½®çš„æ¸ é“åˆ—è¡¨
        """
        channels = []
        
        # ä¼ä¸šå¾®ä¿¡
        if self._wechat_url:
            channels.append(NotificationChannel.WECHAT)
        
        # é£ä¹¦
        if self._feishu_url:
            channels.append(NotificationChannel.FEISHU)
        
        # Telegram
        if self._is_telegram_configured():
            channels.append(NotificationChannel.TELEGRAM)
        
        # é‚®ä»¶
        if self._is_email_configured():
            channels.append(NotificationChannel.EMAIL)
        
        # Pushover
        if self._is_pushover_configured():
            channels.append(NotificationChannel.PUSHOVER)

        # PushPlus
        if self._pushplus_token:
            channels.append(NotificationChannel.PUSHPLUS)

        # è‡ªå®šä¹‰ Webhook
        if self._custom_webhook_urls:
            channels.append(NotificationChannel.CUSTOM)
        
        # Discord
        if self._is_discord_configured():
            channels.append(NotificationChannel.DISCORD)
        # AstrBot
        if self._is_astrbot_configured():
            channels.append(NotificationChannel.ASTRBOT)
        return channels
    
    def _is_telegram_configured(self) -> bool:
        """æ£€æŸ¥ Telegram é…ç½®æ˜¯å¦å®Œæ•´"""
        return bool(self._telegram_config['bot_token'] and self._telegram_config['chat_id'])
    
    def _is_discord_configured(self) -> bool:
        """æ£€æŸ¥ Discord é…ç½®æ˜¯å¦å®Œæ•´ï¼ˆæ”¯æŒ Bot æˆ– Webhookï¼‰"""
        # åªè¦é…ç½®äº† Webhook æˆ–å®Œæ•´çš„ Bot Token+Channelï¼Œå³è§†ä¸ºå¯ç”¨
        bot_ok = bool(self._discord_config['bot_token'] and self._discord_config['channel_id'])
        webhook_ok = bool(self._discord_config['webhook_url'])
        return bot_ok or webhook_ok

    def _is_astrbot_configured(self) -> bool:
        """æ£€æŸ¥ AstrBot é…ç½®æ˜¯å¦å®Œæ•´ï¼ˆæ”¯æŒ Bot æˆ– Webhookï¼‰"""
        # åªè¦é…ç½®äº† URLï¼Œå³è§†ä¸ºå¯ç”¨
        url_ok = bool(self._astrbot_config['astrbot_url'])
        return url_ok

    def _is_email_configured(self) -> bool:
        """æ£€æŸ¥é‚®ä»¶é…ç½®æ˜¯å¦å®Œæ•´ï¼ˆåªéœ€é‚®ç®±å’Œæˆæƒç ï¼‰"""
        return bool(self._email_config['sender'] and self._email_config['password'])
    
    def _is_pushover_configured(self) -> bool:
        """æ£€æŸ¥ Pushover é…ç½®æ˜¯å¦å®Œæ•´"""
        return bool(self._pushover_config['user_key'] and self._pushover_config['api_token'])
    
    def is_available(self) -> bool:
        """æ£€æŸ¥é€šçŸ¥æœåŠ¡æ˜¯å¦å¯ç”¨ï¼ˆè‡³å°‘æœ‰ä¸€ä¸ªæ¸ é“æˆ–ä¸Šä¸‹æ–‡æ¸ é“ï¼‰"""
        return len(self._available_channels) > 0 or self._has_context_channel()
    
    def get_available_channels(self) -> List[NotificationChannel]:
        """è·å–æ‰€æœ‰å·²é…ç½®çš„æ¸ é“"""
        return self._available_channels
    
    def get_channel_names(self) -> str:
        """è·å–æ‰€æœ‰å·²é…ç½®æ¸ é“çš„åç§°"""
        names = [ChannelDetector.get_channel_name(ch) for ch in self._available_channels]
        if self._has_context_channel():
            names.append("é’‰é’‰ä¼šè¯")
        return ', '.join(names)

    def _has_context_channel(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦å­˜åœ¨åŸºäºæ¶ˆæ¯ä¸Šä¸‹æ–‡çš„ä¸´æ—¶æ¸ é“ï¼ˆå¦‚é’‰é’‰ä¼šè¯ã€é£ä¹¦ä¼šè¯ï¼‰"""
        return (
            self._extract_dingtalk_session_webhook() is not None
            or self._extract_feishu_reply_info() is not None
        )

    def _extract_dingtalk_session_webhook(self) -> Optional[str]:
        """ä»æ¥æºæ¶ˆæ¯ä¸­æå–é’‰é’‰ä¼šè¯ Webhookï¼ˆç”¨äº Stream æ¨¡å¼å›å¤ï¼‰"""
        if not isinstance(self._source_message, BotMessage):
            return None
        raw_data = getattr(self._source_message, "raw_data", {}) or {}
        if not isinstance(raw_data, dict):
            return None
        session_webhook = (
            raw_data.get("_session_webhook")
            or raw_data.get("sessionWebhook")
            or raw_data.get("session_webhook")
            or raw_data.get("session_webhook_url")
        )
        if not session_webhook and isinstance(raw_data.get("headers"), dict):
            session_webhook = raw_data["headers"].get("sessionWebhook")
        return session_webhook

    def _extract_feishu_reply_info(self) -> Optional[Dict[str, str]]:
        """
        ä»æ¥æºæ¶ˆæ¯ä¸­æå–é£ä¹¦å›å¤ä¿¡æ¯ï¼ˆç”¨äº Stream æ¨¡å¼å›å¤ï¼‰
        
        Returns:
            åŒ…å« chat_id çš„å­—å…¸ï¼Œæˆ– None
        """
        if not isinstance(self._source_message, BotMessage):
            return None
        if getattr(self._source_message, "platform", "") != "feishu":
            return None
        chat_id = getattr(self._source_message, "chat_id", "")
        if not chat_id:
            return None
        return {"chat_id": chat_id}

    def send_to_context(self, content: str) -> bool:
        """
        å‘åŸºäºæ¶ˆæ¯ä¸Šä¸‹æ–‡çš„æ¸ é“å‘é€æ¶ˆæ¯ï¼ˆä¾‹å¦‚é’‰é’‰ Stream ä¼šè¯ï¼‰
        
        Args:
            content: Markdown æ ¼å¼å†…å®¹
        """
        return self._send_via_source_context(content)
    
    def generate_daily_report(
        self,
        results: List[AnalysisResult],
        report_date: Optional[str] = None
    ) -> str:
        """
        ç”Ÿæˆ Markdown æ ¼å¼çš„æ—¥æŠ¥ï¼ˆè¯¦ç»†ç‰ˆï¼‰

        Args:
            results: åˆ†æç»“æœåˆ—è¡¨
            report_date: æŠ¥å‘Šæ—¥æœŸï¼ˆé»˜è®¤ä»Šå¤©ï¼‰

        Returns:
            Markdown æ ¼å¼çš„æ—¥æŠ¥å†…å®¹
        """
        if report_date is None:
            report_date = datetime.now().strftime('%Y-%m-%d')

        # æ ‡é¢˜
        report_lines = [
            f"# ğŸ“… {report_date} è‚¡ç¥¨æ™ºèƒ½åˆ†ææŠ¥å‘Š",
            "",
            f"> å…±åˆ†æ **{len(results)}** åªè‚¡ç¥¨ | æŠ¥å‘Šç”Ÿæˆæ—¶é—´ï¼š{datetime.now().strftime('%H:%M:%S')}",
            "",
            "---",
            "",
        ]
        
        # æŒ‰è¯„åˆ†æ’åºï¼ˆé«˜åˆ†åœ¨å‰ï¼‰
        sorted_results = sorted(
            results, 
            key=lambda x: x.sentiment_score, 
            reverse=True
        )
        
        # ç»Ÿè®¡ä¿¡æ¯ - ä½¿ç”¨ decision_type å­—æ®µå‡†ç¡®ç»Ÿè®¡
        buy_count = sum(1 for r in results if getattr(r, 'decision_type', '') == 'buy')
        sell_count = sum(1 for r in results if getattr(r, 'decision_type', '') == 'sell')
        hold_count = sum(1 for r in results if getattr(r, 'decision_type', '') in ('hold', ''))
        avg_score = sum(r.sentiment_score for r in results) / len(results) if results else 0
        
        report_lines.extend([
            "## ğŸ“Š æ“ä½œå»ºè®®æ±‡æ€»",
            "",
            "| æŒ‡æ ‡ | æ•°å€¼ |",
            "|------|------|",
            f"| ğŸŸ¢ å»ºè®®ä¹°å…¥/åŠ ä»“ | **{buy_count}** åª |",
            f"| ğŸŸ¡ å»ºè®®æŒæœ‰/è§‚æœ› | **{hold_count}** åª |",
            f"| ğŸ”´ å»ºè®®å‡ä»“/å–å‡º | **{sell_count}** åª |",
            f"| ğŸ“ˆ å¹³å‡çœ‹å¤šè¯„åˆ† | **{avg_score:.1f}** åˆ† |",
            "",
            "---",
            "",
            "## ğŸ“ˆ ä¸ªè‚¡è¯¦ç»†åˆ†æ",
            "",
        ])
        
        # é€ä¸ªè‚¡ç¥¨çš„è¯¦ç»†åˆ†æ
        for result in sorted_results:
            emoji = result.get_emoji()
            confidence_stars = result.get_confidence_stars() if hasattr(result, 'get_confidence_stars') else 'â­â­'
            
            report_lines.extend([
                f"### {emoji} {result.name} ({result.code})",
                "",
                f"**æ“ä½œå»ºè®®ï¼š{result.operation_advice}** | **ç»¼åˆè¯„åˆ†ï¼š{result.sentiment_score}åˆ†** | **è¶‹åŠ¿é¢„æµ‹ï¼š{result.trend_prediction}** | **ç½®ä¿¡åº¦ï¼š{confidence_stars}**",
                "",
            ])
            
            # æ ¸å¿ƒçœ‹ç‚¹
            if hasattr(result, 'key_points') and result.key_points:
                report_lines.extend([
                    f"**ğŸ¯ æ ¸å¿ƒçœ‹ç‚¹**ï¼š{result.key_points}",
                    "",
                ])
            
            # ä¹°å…¥/å–å‡ºç†ç”±
            if hasattr(result, 'buy_reason') and result.buy_reason:
                report_lines.extend([
                    f"**ğŸ’¡ æ“ä½œç†ç”±**ï¼š{result.buy_reason}",
                    "",
                ])
            
            # èµ°åŠ¿åˆ†æ
            if hasattr(result, 'trend_analysis') and result.trend_analysis:
                report_lines.extend([
                    "#### ğŸ“‰ èµ°åŠ¿åˆ†æ",
                    f"{result.trend_analysis}",
                    "",
                ])
            
            # çŸ­æœŸ/ä¸­æœŸå±•æœ›
            outlook_lines = []
            if hasattr(result, 'short_term_outlook') and result.short_term_outlook:
                outlook_lines.append(f"- **çŸ­æœŸï¼ˆ1-3æ—¥ï¼‰**ï¼š{result.short_term_outlook}")
            if hasattr(result, 'medium_term_outlook') and result.medium_term_outlook:
                outlook_lines.append(f"- **ä¸­æœŸï¼ˆ1-2å‘¨ï¼‰**ï¼š{result.medium_term_outlook}")
            if outlook_lines:
                report_lines.extend([
                    "#### ğŸ”® å¸‚åœºå±•æœ›",
                    *outlook_lines,
                    "",
                ])
            
            # æŠ€æœ¯é¢åˆ†æ
            tech_lines = []
            if result.technical_analysis:
                tech_lines.append(f"**ç»¼åˆ**ï¼š{result.technical_analysis}")
            if hasattr(result, 'ma_analysis') and result.ma_analysis:
                tech_lines.append(f"**å‡çº¿**ï¼š{result.ma_analysis}")
            if hasattr(result, 'volume_analysis') and result.volume_analysis:
                tech_lines.append(f"**é‡èƒ½**ï¼š{result.volume_analysis}")
            if hasattr(result, 'pattern_analysis') and result.pattern_analysis:
                tech_lines.append(f"**å½¢æ€**ï¼š{result.pattern_analysis}")
            if tech_lines:
                report_lines.extend([
                    "#### ğŸ“Š æŠ€æœ¯é¢åˆ†æ",
                    *tech_lines,
                    "",
                ])
            
            # åŸºæœ¬é¢åˆ†æ
            fund_lines = []
            if hasattr(result, 'fundamental_analysis') and result.fundamental_analysis:
                fund_lines.append(result.fundamental_analysis)
            if hasattr(result, 'sector_position') and result.sector_position:
                fund_lines.append(f"**æ¿å—åœ°ä½**ï¼š{result.sector_position}")
            if hasattr(result, 'company_highlights') and result.company_highlights:
                fund_lines.append(f"**å…¬å¸äº®ç‚¹**ï¼š{result.company_highlights}")
            if fund_lines:
                report_lines.extend([
                    "#### ğŸ¢ åŸºæœ¬é¢åˆ†æ",
                    *fund_lines,
                    "",
                ])
            
            # æ¶ˆæ¯é¢/æƒ…ç»ªé¢
            news_lines = []
            if result.news_summary:
                news_lines.append(f"**æ–°é—»æ‘˜è¦**ï¼š{result.news_summary}")
            if hasattr(result, 'market_sentiment') and result.market_sentiment:
                news_lines.append(f"**å¸‚åœºæƒ…ç»ª**ï¼š{result.market_sentiment}")
            if hasattr(result, 'hot_topics') and result.hot_topics:
                news_lines.append(f"**ç›¸å…³çƒ­ç‚¹**ï¼š{result.hot_topics}")
            if news_lines:
                report_lines.extend([
                    "#### ğŸ“° æ¶ˆæ¯é¢/æƒ…ç»ªé¢",
                    *news_lines,
                    "",
                ])
            
            # ç»¼åˆåˆ†æ
            if result.analysis_summary:
                report_lines.extend([
                    "#### ğŸ“ ç»¼åˆåˆ†æ",
                    result.analysis_summary,
                    "",
                ])
            
            # é£é™©æç¤º
            if hasattr(result, 'risk_warning') and result.risk_warning:
                report_lines.extend([
                    f"âš ï¸ **é£é™©æç¤º**ï¼š{result.risk_warning}",
                    "",
                ])
            
            # æ•°æ®æ¥æºè¯´æ˜
            if hasattr(result, 'search_performed') and result.search_performed:
                report_lines.append("*ğŸ” å·²æ‰§è¡Œè”ç½‘æœç´¢*")
            if hasattr(result, 'data_sources') and result.data_sources:
                report_lines.append(f"*ğŸ“‹ æ•°æ®æ¥æºï¼š{result.data_sources}*")
            
            # é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
            if not result.success and result.error_message:
                report_lines.extend([
                    "",
                    f"âŒ **åˆ†æå¼‚å¸¸**ï¼š{result.error_message[:100]}",
                ])
            
            report_lines.extend([
                "",
                "---",
                "",
            ])
        
        # åº•éƒ¨ä¿¡æ¯ï¼ˆå»é™¤å…è´£å£°æ˜ï¼‰
        report_lines.extend([
            "",
            f"*æŠ¥å‘Šç”Ÿæˆæ—¶é—´ï¼š{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*",
        ])
        
        return "\n".join(report_lines)
    
    def _get_signal_level(self, result: AnalysisResult) -> tuple:
        """
        æ ¹æ®æ“ä½œå»ºè®®è·å–ä¿¡å·ç­‰çº§å’Œé¢œè‰²
        
        Returns:
            (ä¿¡å·æ–‡å­—, emoji, é¢œè‰²æ ‡è®°)
        """
        advice = result.operation_advice
        score = result.sentiment_score
        
        if advice in ['å¼ºçƒˆä¹°å…¥'] or score >= 80:
            return ('å¼ºçƒˆä¹°å…¥', 'ğŸ’š', 'å¼ºä¹°')
        elif advice in ['ä¹°å…¥', 'åŠ ä»“'] or score >= 65:
            return ('ä¹°å…¥', 'ğŸŸ¢', 'ä¹°å…¥')
        elif advice in ['æŒæœ‰'] or 55 <= score < 65:
            return ('æŒæœ‰', 'ğŸŸ¡', 'æŒæœ‰')
        elif advice in ['è§‚æœ›'] or 45 <= score < 55:
            return ('è§‚æœ›', 'âšª', 'è§‚æœ›')
        elif advice in ['å‡ä»“'] or 35 <= score < 45:
            return ('å‡ä»“', 'ğŸŸ ', 'å‡ä»“')
        elif advice in ['å–å‡º', 'å¼ºçƒˆå–å‡º'] or score < 35:
            return ('å–å‡º', 'ğŸ”´', 'å–å‡º')
        else:
            return ('è§‚æœ›', 'âšª', 'è§‚æœ›')
    
    def generate_dashboard_report(
        self,
        results: List[AnalysisResult],
        report_date: Optional[str] = None
    ) -> str:
        """
        ç”Ÿæˆå†³ç­–ä»ªè¡¨ç›˜æ ¼å¼çš„æ—¥æŠ¥ï¼ˆè¯¦ç»†ç‰ˆï¼‰

        æ ¼å¼ï¼šå¸‚åœºæ¦‚è§ˆ + é‡è¦ä¿¡æ¯ + æ ¸å¿ƒç»“è®º + æ•°æ®é€è§† + ä½œæˆ˜è®¡åˆ’

        Args:
            results: åˆ†æç»“æœåˆ—è¡¨
            report_date: æŠ¥å‘Šæ—¥æœŸï¼ˆé»˜è®¤ä»Šå¤©ï¼‰

        Returns:
            Markdown æ ¼å¼çš„å†³ç­–ä»ªè¡¨ç›˜æ—¥æŠ¥
        """
        if report_date is None:
            report_date = datetime.now().strftime('%Y-%m-%d')

        # æŒ‰è¯„åˆ†æ’åºï¼ˆé«˜åˆ†åœ¨å‰ï¼‰
        sorted_results = sorted(results, key=lambda x: x.sentiment_score, reverse=True)

        # ç»Ÿè®¡ä¿¡æ¯ - ä½¿ç”¨ decision_type å­—æ®µå‡†ç¡®ç»Ÿè®¡
        buy_count = sum(1 for r in results if getattr(r, 'decision_type', '') == 'buy')
        sell_count = sum(1 for r in results if getattr(r, 'decision_type', '') == 'sell')
        hold_count = sum(1 for r in results if getattr(r, 'decision_type', '') in ('hold', ''))

        report_lines = [
            f"# ğŸ¯ {report_date} å†³ç­–ä»ªè¡¨ç›˜",
            "",
            f"> å…±åˆ†æ **{len(results)}** åªè‚¡ç¥¨ | ğŸŸ¢ä¹°å…¥:{buy_count} ğŸŸ¡è§‚æœ›:{hold_count} ğŸ”´å–å‡º:{sell_count}",
            "",
        ]

        # === æ–°å¢ï¼šåˆ†æç»“æœæ‘˜è¦ (Issue #112) ===
        if results:
            report_lines.extend([
                "## ğŸ“Š åˆ†æç»“æœæ‘˜è¦",
                "",
            ])
            for r in sorted_results:
                emoji = r.get_emoji()
                report_lines.append(
                    f"{emoji} **{r.name}({r.code})**: {r.operation_advice} | "
                    f"è¯„åˆ† {r.sentiment_score} | {r.trend_prediction}"
                )
            report_lines.extend([
                "",
                "---",
                "",
            ])

        # é€ä¸ªè‚¡ç¥¨çš„å†³ç­–ä»ªè¡¨ç›˜
        for result in sorted_results:
            signal_text, signal_emoji, signal_tag = self._get_signal_level(result)
            dashboard = result.dashboard if hasattr(result, 'dashboard') and result.dashboard else {}
            
            # è‚¡ç¥¨åç§°ï¼ˆä¼˜å…ˆä½¿ç”¨ dashboard æˆ– result ä¸­çš„åç§°ï¼‰
            stock_name = result.name if result.name and not result.name.startswith('è‚¡ç¥¨') else f'è‚¡ç¥¨{result.code}'
            
            report_lines.extend([
                f"## {signal_emoji} {stock_name} ({result.code})",
                "",
            ])
            
            # ========== èˆ†æƒ…ä¸åŸºæœ¬é¢æ¦‚è§ˆï¼ˆæ”¾åœ¨æœ€å‰é¢ï¼‰==========
            intel = dashboard.get('intelligence', {}) if dashboard else {}
            if intel:
                report_lines.extend([
                    "### ğŸ“° é‡è¦ä¿¡æ¯é€Ÿè§ˆ",
                    "",
                ])
                
                # èˆ†æƒ…æƒ…ç»ªæ€»ç»“
                if intel.get('sentiment_summary'):
                    report_lines.append(f"**ğŸ’­ èˆ†æƒ…æƒ…ç»ª**: {intel['sentiment_summary']}")
                
                # ä¸šç»©é¢„æœŸ
                if intel.get('earnings_outlook'):
                    report_lines.append(f"**ğŸ“Š ä¸šç»©é¢„æœŸ**: {intel['earnings_outlook']}")
                
                # é£é™©è­¦æŠ¥ï¼ˆé†’ç›®æ˜¾ç¤ºï¼‰
                risk_alerts = intel.get('risk_alerts', [])
                if risk_alerts:
                    report_lines.append("")
                    report_lines.append("**ğŸš¨ é£é™©è­¦æŠ¥**:")
                    for alert in risk_alerts:
                        report_lines.append(f"- {alert}")
                
                # åˆ©å¥½å‚¬åŒ–
                catalysts = intel.get('positive_catalysts', [])
                if catalysts:
                    report_lines.append("")
                    report_lines.append("**âœ¨ åˆ©å¥½å‚¬åŒ–**:")
                    for cat in catalysts:
                        report_lines.append(f"- {cat}")
                
                # æœ€æ–°æ¶ˆæ¯
                if intel.get('latest_news'):
                    report_lines.append("")
                    report_lines.append(f"**ğŸ“¢ æœ€æ–°åŠ¨æ€**: {intel['latest_news']}")
                
                report_lines.append("")
            
            # ========== æ ¸å¿ƒç»“è®º ==========
            core = dashboard.get('core_conclusion', {}) if dashboard else {}
            one_sentence = core.get('one_sentence', result.analysis_summary)
            time_sense = core.get('time_sensitivity', 'æœ¬å‘¨å†…')
            pos_advice = core.get('position_advice', {})
            
            report_lines.extend([
                "### ğŸ“Œ æ ¸å¿ƒç»“è®º",
                "",
                f"**{signal_emoji} {signal_text}** | {result.trend_prediction}",
                "",
                f"> **ä¸€å¥è¯å†³ç­–**: {one_sentence}",
                "",
                f"â° **æ—¶æ•ˆæ€§**: {time_sense}",
                "",
            ])
            
            # æŒä»“åˆ†ç±»å»ºè®®
            if pos_advice:
                report_lines.extend([
                    "| æŒä»“æƒ…å†µ | æ“ä½œå»ºè®® |",
                    "|---------|---------|",
                    f"| ğŸ†• **ç©ºä»“è€…** | {pos_advice.get('no_position', result.operation_advice)} |",
                    f"| ğŸ’¼ **æŒä»“è€…** | {pos_advice.get('has_position', 'ç»§ç»­æŒæœ‰')} |",
                    "",
                ])
            
            # ========== æ•°æ®é€è§† ==========
            data_persp = dashboard.get('data_perspective', {}) if dashboard else {}
            if data_persp:
                trend_data = data_persp.get('trend_status', {})
                price_data = data_persp.get('price_position', {})
                vol_data = data_persp.get('volume_analysis', {})
                chip_data = data_persp.get('chip_structure', {})
                
                report_lines.extend([
                    "### ğŸ“Š æ•°æ®é€è§†",
                    "",
                ])
                
                # è¶‹åŠ¿çŠ¶æ€
                if trend_data:
                    is_bullish = "âœ… æ˜¯" if trend_data.get('is_bullish', False) else "âŒ å¦"
                    report_lines.extend([
                        f"**å‡çº¿æ’åˆ—**: {trend_data.get('ma_alignment', 'N/A')} | å¤šå¤´æ’åˆ—: {is_bullish} | è¶‹åŠ¿å¼ºåº¦: {trend_data.get('trend_score', 'N/A')}/100",
                        "",
                    ])
                
                # ä»·æ ¼ä½ç½®
                if price_data:
                    bias_status = price_data.get('bias_status', 'N/A')
                    bias_emoji = "âœ…" if bias_status == "å®‰å…¨" else ("âš ï¸" if bias_status == "è­¦æˆ’" else "ğŸš¨")
                    report_lines.extend([
                        "| ä»·æ ¼æŒ‡æ ‡ | æ•°å€¼ |",
                        "|---------|------|",
                        f"| å½“å‰ä»· | {price_data.get('current_price', 'N/A')} |",
                        f"| MA5 | {price_data.get('ma5', 'N/A')} |",
                        f"| MA10 | {price_data.get('ma10', 'N/A')} |",
                        f"| MA20 | {price_data.get('ma20', 'N/A')} |",
                        f"| ä¹–ç¦»ç‡(MA5) | {price_data.get('bias_ma5', 'N/A')}% {bias_emoji}{bias_status} |",
                        f"| æ”¯æ’‘ä½ | {price_data.get('support_level', 'N/A')} |",
                        f"| å‹åŠ›ä½ | {price_data.get('resistance_level', 'N/A')} |",
                        "",
                    ])
                
                # é‡èƒ½åˆ†æ
                if vol_data:
                    report_lines.extend([
                        f"**é‡èƒ½**: é‡æ¯” {vol_data.get('volume_ratio', 'N/A')} ({vol_data.get('volume_status', '')}) | æ¢æ‰‹ç‡ {vol_data.get('turnover_rate', 'N/A')}%",
                        f"ğŸ’¡ *{vol_data.get('volume_meaning', '')}*",
                        "",
                    ])
                
                # ç­¹ç ç»“æ„
                if chip_data:
                    chip_health = chip_data.get('chip_health', 'N/A')
                    chip_emoji = "âœ…" if chip_health == "å¥åº·" else ("âš ï¸" if chip_health == "ä¸€èˆ¬" else "ğŸš¨")
                    report_lines.extend([
                        f"**ç­¹ç **: è·åˆ©æ¯”ä¾‹ {chip_data.get('profit_ratio', 'N/A')} | å¹³å‡æˆæœ¬ {chip_data.get('avg_cost', 'N/A')} | é›†ä¸­åº¦ {chip_data.get('concentration', 'N/A')} {chip_emoji}{chip_health}",
                        "",
                    ])
            
            # èˆ†æƒ…æƒ…æŠ¥å·²ç§»è‡³é¡¶éƒ¨æ˜¾ç¤º
            
            # ========== ä½œæˆ˜è®¡åˆ’ ==========
            battle = dashboard.get('battle_plan', {}) if dashboard else {}
            if battle:
                report_lines.extend([
                    "### ğŸ¯ ä½œæˆ˜è®¡åˆ’",
                    "",
                ])
                
                # ç‹™å‡»ç‚¹ä½
                sniper = battle.get('sniper_points', {})
                if sniper:
                    report_lines.extend([
                        "**ğŸ“ ç‹™å‡»ç‚¹ä½**",
                        "",
                        "| ç‚¹ä½ç±»å‹ | ä»·æ ¼ |",
                        "|---------|------|",
                        f"| ğŸ¯ ç†æƒ³ä¹°å…¥ç‚¹ | {sniper.get('ideal_buy', 'N/A')} |",
                        f"| ğŸ”µ æ¬¡ä¼˜ä¹°å…¥ç‚¹ | {sniper.get('secondary_buy', 'N/A')} |",
                        f"| ğŸ›‘ æ­¢æŸä½ | {sniper.get('stop_loss', 'N/A')} |",
                        f"| ğŸŠ ç›®æ ‡ä½ | {sniper.get('take_profit', 'N/A')} |",
                        "",
                    ])
                
                # ä»“ä½ç­–ç•¥
                position = battle.get('position_strategy', {})
                if position:
                    report_lines.extend([
                        f"**ğŸ’° ä»“ä½å»ºè®®**: {position.get('suggested_position', 'N/A')}",
                        f"- å»ºä»“ç­–ç•¥: {position.get('entry_plan', 'N/A')}",
                        f"- é£æ§ç­–ç•¥: {position.get('risk_control', 'N/A')}",
                        "",
                    ])
                
                # æ£€æŸ¥æ¸…å•
                checklist = battle.get('action_checklist', []) if battle else []
                if checklist:
                    report_lines.extend([
                        "**âœ… æ£€æŸ¥æ¸…å•**",
                        "",
                    ])
                    for item in checklist:
                        report_lines.append(f"- {item}")
                    report_lines.append("")
            
            # å¦‚æœæ²¡æœ‰ dashboardï¼Œæ˜¾ç¤ºä¼ ç»Ÿæ ¼å¼
            if not dashboard:
                # æ“ä½œç†ç”±
                if result.buy_reason:
                    report_lines.extend([
                        f"**ğŸ’¡ æ“ä½œç†ç”±**: {result.buy_reason}",
                        "",
                    ])
                
                # é£é™©æç¤º
                if result.risk_warning:
                    report_lines.extend([
                        f"**âš ï¸ é£é™©æç¤º**: {result.risk_warning}",
                        "",
                    ])
                
                # æŠ€æœ¯é¢åˆ†æ
                if result.ma_analysis or result.volume_analysis:
                    report_lines.extend([
                        "### ğŸ“Š æŠ€æœ¯é¢",
                        "",
                    ])
                    if result.ma_analysis:
                        report_lines.append(f"**å‡çº¿**: {result.ma_analysis}")
                    if result.volume_analysis:
                        report_lines.append(f"**é‡èƒ½**: {result.volume_analysis}")
                    report_lines.append("")
                
                # æ¶ˆæ¯é¢
                if result.news_summary:
                    report_lines.extend([
                        "### ğŸ“° æ¶ˆæ¯é¢",
                        f"{result.news_summary}",
                        "",
                    ])
            
            report_lines.extend([
                "---",
                "",
            ])
        
        # åº•éƒ¨ï¼ˆå»é™¤å…è´£å£°æ˜ï¼‰
        report_lines.extend([
            "",
            f"*æŠ¥å‘Šç”Ÿæˆæ—¶é—´ï¼š{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*",
        ])
        
        return "\n".join(report_lines)
    
    def generate_wechat_dashboard(self, results: List[AnalysisResult]) -> str:
        """
        ç”Ÿæˆä¼ä¸šå¾®ä¿¡å†³ç­–ä»ªè¡¨ç›˜ç²¾ç®€ç‰ˆï¼ˆæ§åˆ¶åœ¨4000å­—ç¬¦å†…ï¼‰
        
        åªä¿ç•™æ ¸å¿ƒç»“è®ºå’Œç‹™å‡»ç‚¹ä½
        
        Args:
            results: åˆ†æç»“æœåˆ—è¡¨
            
        Returns:
            ç²¾ç®€ç‰ˆå†³ç­–ä»ªè¡¨ç›˜
        """
        report_date = datetime.now().strftime('%Y-%m-%d')
        
        # æŒ‰è¯„åˆ†æ’åº
        sorted_results = sorted(results, key=lambda x: x.sentiment_score, reverse=True)
        
        # ç»Ÿè®¡ - ä½¿ç”¨ decision_type å­—æ®µå‡†ç¡®ç»Ÿè®¡
        buy_count = sum(1 for r in results if getattr(r, 'decision_type', '') == 'buy')
        sell_count = sum(1 for r in results if getattr(r, 'decision_type', '') == 'sell')
        hold_count = sum(1 for r in results if getattr(r, 'decision_type', '') in ('hold', ''))
        
        lines = [
            f"## ğŸ¯ {report_date} å†³ç­–ä»ªè¡¨ç›˜",
            "",
            f"> {len(results)}åªè‚¡ç¥¨ | ğŸŸ¢ä¹°å…¥:{buy_count} ğŸŸ¡è§‚æœ›:{hold_count} ğŸ”´å–å‡º:{sell_count}",
            "",
        ]
        
        for result in sorted_results:
            signal_text, signal_emoji, _ = self._get_signal_level(result)
            dashboard = result.dashboard if hasattr(result, 'dashboard') and result.dashboard else {}
            core = dashboard.get('core_conclusion', {}) if dashboard else {}
            battle = dashboard.get('battle_plan', {}) if dashboard else {}
            intel = dashboard.get('intelligence', {}) if dashboard else {}
            
            # è‚¡ç¥¨åç§°
            stock_name = result.name if result.name and not result.name.startswith('è‚¡ç¥¨') else f'è‚¡ç¥¨{result.code}'
            
            # æ ‡é¢˜è¡Œï¼šä¿¡å·ç­‰çº§ + è‚¡ç¥¨åç§°
            lines.append(f"### {signal_emoji} **{signal_text}** | {stock_name}({result.code})")
            lines.append("")
            
            # æ ¸å¿ƒå†³ç­–ï¼ˆä¸€å¥è¯ï¼‰
            one_sentence = core.get('one_sentence', result.analysis_summary) if core else result.analysis_summary
            if one_sentence:
                lines.append(f"ğŸ“Œ **{one_sentence[:80]}**")
                lines.append("")
            
            # é‡è¦ä¿¡æ¯åŒºï¼ˆèˆ†æƒ…+åŸºæœ¬é¢ï¼‰
            info_lines = []
            
            # ä¸šç»©é¢„æœŸ
            if intel.get('earnings_outlook'):
                outlook = intel['earnings_outlook'][:60]
                info_lines.append(f"ğŸ“Š ä¸šç»©: {outlook}")
            
            # èˆ†æƒ…æƒ…ç»ª
            if intel.get('sentiment_summary'):
                sentiment = intel['sentiment_summary'][:50]
                info_lines.append(f"ğŸ’­ èˆ†æƒ…: {sentiment}")
            
            if info_lines:
                lines.extend(info_lines)
                lines.append("")
            
            # é£é™©è­¦æŠ¥ï¼ˆæœ€é‡è¦ï¼Œé†’ç›®æ˜¾ç¤ºï¼‰
            risks = intel.get('risk_alerts', []) if intel else []
            if risks:
                lines.append("ğŸš¨ **é£é™©**:")
                for risk in risks[:2]:  # æœ€å¤šæ˜¾ç¤º2æ¡
                    risk_text = risk[:50] + "..." if len(risk) > 50 else risk
                    lines.append(f"   â€¢ {risk_text}")
                lines.append("")
            
            # åˆ©å¥½å‚¬åŒ–
            catalysts = intel.get('positive_catalysts', []) if intel else []
            if catalysts:
                lines.append("âœ¨ **åˆ©å¥½**:")
                for cat in catalysts[:2]:  # æœ€å¤šæ˜¾ç¤º2æ¡
                    cat_text = cat[:50] + "..." if len(cat) > 50 else cat
                    lines.append(f"   â€¢ {cat_text}")
                lines.append("")
            
            # ç‹™å‡»ç‚¹ä½
            sniper = battle.get('sniper_points', {}) if battle else {}
            if sniper:
                ideal_buy = sniper.get('ideal_buy', '')
                stop_loss = sniper.get('stop_loss', '')
                take_profit = sniper.get('take_profit', '')
                
                points = []
                if ideal_buy:
                    points.append(f"ğŸ¯ä¹°ç‚¹:{ideal_buy[:15]}")
                if stop_loss:
                    points.append(f"ğŸ›‘æ­¢æŸ:{stop_loss[:15]}")
                if take_profit:
                    points.append(f"ğŸŠç›®æ ‡:{take_profit[:15]}")
                
                if points:
                    lines.append(" | ".join(points))
                    lines.append("")
            
            # æŒä»“å»ºè®®
            pos_advice = core.get('position_advice', {}) if core else {}
            if pos_advice:
                no_pos = pos_advice.get('no_position', '')
                has_pos = pos_advice.get('has_position', '')
                if no_pos:
                    lines.append(f"ğŸ†• ç©ºä»“è€…: {no_pos[:50]}")
                if has_pos:
                    lines.append(f"ğŸ’¼ æŒä»“è€…: {has_pos[:50]}")
                lines.append("")
            
            # æ£€æŸ¥æ¸…å•ç®€åŒ–ç‰ˆ
            checklist = battle.get('action_checklist', []) if battle else []
            if checklist:
                # åªæ˜¾ç¤ºä¸é€šè¿‡çš„é¡¹ç›®
                failed_checks = [c for c in checklist if c.startswith('âŒ') or c.startswith('âš ï¸')]
                if failed_checks:
                    lines.append("**æ£€æŸ¥æœªé€šè¿‡é¡¹**:")
                    for check in failed_checks[:3]:
                        lines.append(f"   {check[:40]}")
                    lines.append("")
            
            lines.append("---")
            lines.append("")
        
        # åº•éƒ¨
        lines.append(f"*ç”Ÿæˆæ—¶é—´: {datetime.now().strftime('%H:%M')}*")
        
        content = "\n".join(lines)
        
        return content
    
    def generate_wechat_summary(self, results: List[AnalysisResult]) -> str:
        """
        ç”Ÿæˆä¼ä¸šå¾®ä¿¡ç²¾ç®€ç‰ˆæ—¥æŠ¥ï¼ˆæ§åˆ¶åœ¨4000å­—ç¬¦å†…ï¼‰

        Args:
            results: åˆ†æç»“æœåˆ—è¡¨

        Returns:
            ç²¾ç®€ç‰ˆ Markdown å†…å®¹
        """
        report_date = datetime.now().strftime('%Y-%m-%d')

        # æŒ‰è¯„åˆ†æ’åº
        sorted_results = sorted(results, key=lambda x: x.sentiment_score, reverse=True)

        # ç»Ÿè®¡ - ä½¿ç”¨ decision_type å­—æ®µå‡†ç¡®ç»Ÿè®¡
        buy_count = sum(1 for r in results if getattr(r, 'decision_type', '') == 'buy')
        sell_count = sum(1 for r in results if getattr(r, 'decision_type', '') == 'sell')
        hold_count = sum(1 for r in results if getattr(r, 'decision_type', '') in ('hold', ''))
        avg_score = sum(r.sentiment_score for r in results) / len(results) if results else 0

        lines = [
            f"## ğŸ“… {report_date} è‚¡ç¥¨åˆ†ææŠ¥å‘Š",
            "",
            f"> å…± **{len(results)}** åª | ğŸŸ¢ä¹°å…¥:{buy_count} ğŸŸ¡æŒæœ‰:{hold_count} ğŸ”´å–å‡º:{sell_count} | å‡åˆ†:{avg_score:.0f}",
            "",
        ]
        
        # æ¯åªè‚¡ç¥¨ç²¾ç®€ä¿¡æ¯ï¼ˆæ§åˆ¶é•¿åº¦ï¼‰
        for result in sorted_results:
            emoji = result.get_emoji()
            
            # æ ¸å¿ƒä¿¡æ¯è¡Œ
            lines.append(f"### {emoji} {result.name}({result.code})")
            lines.append(f"**{result.operation_advice}** | è¯„åˆ†:{result.sentiment_score} | {result.trend_prediction}")
            
            # æ“ä½œç†ç”±ï¼ˆæˆªæ–­ï¼‰
            if hasattr(result, 'buy_reason') and result.buy_reason:
                reason = result.buy_reason[:80] + "..." if len(result.buy_reason) > 80 else result.buy_reason
                lines.append(f"ğŸ’¡ {reason}")
            
            # æ ¸å¿ƒçœ‹ç‚¹
            if hasattr(result, 'key_points') and result.key_points:
                points = result.key_points[:60] + "..." if len(result.key_points) > 60 else result.key_points
                lines.append(f"ğŸ¯ {points}")
            
            # é£é™©æç¤ºï¼ˆæˆªæ–­ï¼‰
            if hasattr(result, 'risk_warning') and result.risk_warning:
                risk = result.risk_warning[:50] + "..." if len(result.risk_warning) > 50 else result.risk_warning
                lines.append(f"âš ï¸ {risk}")
            
            lines.append("")
        
        # åº•éƒ¨
        lines.extend([
            "---",
            "*AIç”Ÿæˆï¼Œä»…ä¾›å‚è€ƒï¼Œä¸æ„æˆæŠ•èµ„å»ºè®®*",
            f"*è¯¦ç»†æŠ¥å‘Šè§ reports/report_{report_date.replace('-', '')}.md*"
        ])
        
        content = "\n".join(lines)
        
        return content
    
    def generate_single_stock_report(self, result: AnalysisResult) -> str:
        """
        ç”Ÿæˆå•åªè‚¡ç¥¨çš„åˆ†ææŠ¥å‘Šï¼ˆç”¨äºå•è‚¡æ¨é€æ¨¡å¼ #55ï¼‰
        
        æ ¼å¼ç²¾ç®€ä½†ä¿¡æ¯å®Œæ•´ï¼Œé€‚åˆæ¯åˆ†æå®Œä¸€åªè‚¡ç¥¨ç«‹å³æ¨é€
        
        Args:
            result: å•åªè‚¡ç¥¨çš„åˆ†æç»“æœ
            
        Returns:
            Markdown æ ¼å¼çš„å•è‚¡æŠ¥å‘Š
        """
        report_date = datetime.now().strftime('%Y-%m-%d %H:%M')
        signal_text, signal_emoji, _ = self._get_signal_level(result)
        dashboard = result.dashboard if hasattr(result, 'dashboard') and result.dashboard else {}
        core = dashboard.get('core_conclusion', {}) if dashboard else {}
        battle = dashboard.get('battle_plan', {}) if dashboard else {}
        intel = dashboard.get('intelligence', {}) if dashboard else {}
        
        # è‚¡ç¥¨åç§°
        stock_name = result.name if result.name and not result.name.startswith('è‚¡ç¥¨') else f'è‚¡ç¥¨{result.code}'
        
        lines = [
            f"## {signal_emoji} {stock_name} ({result.code})",
            "",
            f"> {report_date} | è¯„åˆ†: **{result.sentiment_score}** | {result.trend_prediction}",
            "",
        ]
        
        # æ ¸å¿ƒå†³ç­–ï¼ˆä¸€å¥è¯ï¼‰
        one_sentence = core.get('one_sentence', result.analysis_summary) if core else result.analysis_summary
        if one_sentence:
            lines.extend([
                "### ğŸ“Œ æ ¸å¿ƒç»“è®º",
                "",
                f"**{signal_text}**: {one_sentence}",
                "",
            ])
        
        # é‡è¦ä¿¡æ¯ï¼ˆèˆ†æƒ…+åŸºæœ¬é¢ï¼‰
        info_added = False
        if intel:
            if intel.get('earnings_outlook'):
                if not info_added:
                    lines.append("### ğŸ“° é‡è¦ä¿¡æ¯")
                    lines.append("")
                    info_added = True
                lines.append(f"ğŸ“Š **ä¸šç»©é¢„æœŸ**: {intel['earnings_outlook'][:100]}")
            
            if intel.get('sentiment_summary'):
                if not info_added:
                    lines.append("### ğŸ“° é‡è¦ä¿¡æ¯")
                    lines.append("")
                    info_added = True
                lines.append(f"ğŸ’­ **èˆ†æƒ…æƒ…ç»ª**: {intel['sentiment_summary'][:80]}")
            
            # é£é™©è­¦æŠ¥
            risks = intel.get('risk_alerts', [])
            if risks:
                if not info_added:
                    lines.append("### ğŸ“° é‡è¦ä¿¡æ¯")
                    lines.append("")
                    info_added = True
                lines.append("")
                lines.append("ğŸš¨ **é£é™©è­¦æŠ¥**:")
                for risk in risks[:3]:
                    lines.append(f"- {risk[:60]}")
            
            # åˆ©å¥½å‚¬åŒ–
            catalysts = intel.get('positive_catalysts', [])
            if catalysts:
                lines.append("")
                lines.append("âœ¨ **åˆ©å¥½å‚¬åŒ–**:")
                for cat in catalysts[:3]:
                    lines.append(f"- {cat[:60]}")
        
        if info_added:
            lines.append("")
        
        # ç‹™å‡»ç‚¹ä½
        sniper = battle.get('sniper_points', {}) if battle else {}
        if sniper:
            lines.extend([
                "### ğŸ¯ æ“ä½œç‚¹ä½",
                "",
                "| ä¹°ç‚¹ | æ­¢æŸ | ç›®æ ‡ |",
                "|------|------|------|",
            ])
            ideal_buy = sniper.get('ideal_buy', '-')
            stop_loss = sniper.get('stop_loss', '-')
            take_profit = sniper.get('take_profit', '-')
            lines.append(f"| {ideal_buy} | {stop_loss} | {take_profit} |")
            lines.append("")
        
        # æŒä»“å»ºè®®
        pos_advice = core.get('position_advice', {}) if core else {}
        if pos_advice:
            lines.extend([
                "### ğŸ’¼ æŒä»“å»ºè®®",
                "",
                f"- ğŸ†• **ç©ºä»“è€…**: {pos_advice.get('no_position', result.operation_advice)}",
                f"- ğŸ’¼ **æŒä»“è€…**: {pos_advice.get('has_position', 'ç»§ç»­æŒæœ‰')}",
                "",
            ])
        
        lines.extend([
            "---",
            "*AIç”Ÿæˆï¼Œä»…ä¾›å‚è€ƒï¼Œä¸æ„æˆæŠ•èµ„å»ºè®®*",
        ])
        
        return "\n".join(lines)
    
    def send_to_wechat(self, content: str) -> bool:
        """
        æ¨é€æ¶ˆæ¯åˆ°ä¼ä¸šå¾®ä¿¡æœºå™¨äºº
        
        ä¼ä¸šå¾®ä¿¡ Webhook æ¶ˆæ¯æ ¼å¼ï¼š
        æ”¯æŒ markdown ç±»å‹ä»¥åŠ text ç±»å‹, markdown ç±»å‹åœ¨å¾®ä¿¡ä¸­æ— æ³•å±•ç¤ºï¼Œå¯ä»¥ä½¿ç”¨ text ç±»å‹,
        markdown ç±»å‹ä¼šè§£æ markdown æ ¼å¼,text ç±»å‹ä¼šç›´æ¥å‘é€çº¯æ–‡æœ¬ã€‚

        markdown ç±»å‹ç¤ºä¾‹ï¼š
        {
            "msgtype": "markdown",
            "markdown": {
                "content": "## æ ‡é¢˜\n\nå†…å®¹"
            }
        }
        
        text ç±»å‹ç¤ºä¾‹ï¼š
        {
            "msgtype": "text",
            "text": {
                "content": "å†…å®¹"
            }
        }

        æ³¨æ„ï¼šä¼ä¸šå¾®ä¿¡ Markdown é™åˆ¶ 4096 å­—èŠ‚ï¼ˆéå­—ç¬¦ï¼‰, Text ç±»å‹é™åˆ¶ 2048 å­—èŠ‚ï¼Œè¶…é•¿å†…å®¹ä¼šè‡ªåŠ¨åˆ†æ‰¹å‘é€
        å¯é€šè¿‡ç¯å¢ƒå˜é‡ WECHAT_MAX_BYTES è°ƒæ•´é™åˆ¶å€¼
        
        Args:
            content: Markdown æ ¼å¼çš„æ¶ˆæ¯å†…å®¹
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        if not self._wechat_url:
            logger.warning("ä¼ä¸šå¾®ä¿¡ Webhook æœªé…ç½®ï¼Œè·³è¿‡æ¨é€")
            return False
        
        max_bytes = self._wechat_max_bytes  # ä»é…ç½®è¯»å–ï¼Œé»˜è®¤ 4000 å­—èŠ‚
        
        # æ£€æŸ¥å­—èŠ‚é•¿åº¦ï¼Œè¶…é•¿åˆ™åˆ†æ‰¹å‘é€
        content_bytes = len(content.encode('utf-8'))
        if content_bytes > max_bytes:
            logger.info(f"æ¶ˆæ¯å†…å®¹è¶…é•¿({content_bytes}å­—èŠ‚/{len(content)}å­—ç¬¦)ï¼Œå°†åˆ†æ‰¹å‘é€")
            return self._send_wechat_chunked(content, max_bytes)
        
        try:
            return self._send_wechat_message(content)
        except Exception as e:
            logger.error(f"å‘é€ä¼ä¸šå¾®ä¿¡æ¶ˆæ¯å¤±è´¥: {e}")
            return False
    
    def _send_wechat_chunked(self, content: str, max_bytes: int) -> bool:
        """
        åˆ†æ‰¹å‘é€é•¿æ¶ˆæ¯åˆ°ä¼ä¸šå¾®ä¿¡
        
        æŒ‰è‚¡ç¥¨åˆ†æå—ï¼ˆä»¥ --- æˆ– ### åˆ†éš”ï¼‰æ™ºèƒ½åˆ†å‰²ï¼Œç¡®ä¿æ¯æ‰¹ä¸è¶…è¿‡é™åˆ¶
        
        Args:
            content: å®Œæ•´æ¶ˆæ¯å†…å®¹
            max_bytes: å•æ¡æ¶ˆæ¯æœ€å¤§å­—èŠ‚æ•°
            
        Returns:
            æ˜¯å¦å…¨éƒ¨å‘é€æˆåŠŸ
        """
        import time
        
        def get_bytes(s: str) -> int:
            """è·å–å­—ç¬¦ä¸²çš„ UTF-8 å­—èŠ‚æ•°"""
            return len(s.encode('utf-8'))
        
        # æ™ºèƒ½åˆ†å‰²ï¼šä¼˜å…ˆæŒ‰ "---" åˆ†éš”ï¼ˆè‚¡ç¥¨ä¹‹é—´çš„åˆ†éš”çº¿ï¼‰
        # å…¶æ¬¡å°è¯•å„çº§æ ‡é¢˜åˆ†å‰²
        if "\n---\n" in content:
            sections = content.split("\n---\n")
            separator = "\n---\n"
        elif "\n### " in content:
            # æŒ‰ ### åˆ†å‰²
            parts = content.split("\n### ")
            sections = [parts[0]] + [f"### {p}" for p in parts[1:]]
            separator = "\n"
        elif "\n## " in content:
            # æŒ‰ ## åˆ†å‰² (å…¼å®¹äºŒçº§æ ‡é¢˜)
            parts = content.split("\n## ")
            sections = [parts[0]] + [f"## {p}" for p in parts[1:]]
            separator = "\n"
        elif "\n**" in content:
            # æŒ‰ ** åŠ ç²—æ ‡é¢˜åˆ†å‰² (å…¼å®¹ AI æœªè¾“å‡ºæ ‡å‡† Markdown æ ‡é¢˜çš„æƒ…å†µ)
            parts = content.split("\n**")
            sections = [parts[0]] + [f"**{p}" for p in parts[1:]]
            separator = "\n"
        else:
            # æ— æ³•æ™ºèƒ½åˆ†å‰²ï¼ŒæŒ‰å­—ç¬¦å¼ºåˆ¶åˆ†å‰²
            return self._send_wechat_force_chunked(content, max_bytes)
        
        chunks = []
        current_chunk = []
        current_bytes = 0
        separator_bytes = get_bytes(separator)
        
        for section in sections:
            section_bytes = get_bytes(section) + separator_bytes
            
            # å¦‚æœå•ä¸ª section å°±è¶…é•¿ï¼Œéœ€è¦å¼ºåˆ¶æˆªæ–­
            if section_bytes > max_bytes:
                # å…ˆå‘é€å½“å‰ç§¯ç´¯çš„å†…å®¹
                if current_chunk:
                    chunks.append(separator.join(current_chunk))
                    current_chunk = []
                    current_bytes = 0
                
                # å¼ºåˆ¶æˆªæ–­è¿™ä¸ªè¶…é•¿ sectionï¼ˆæŒ‰å­—èŠ‚æˆªæ–­ï¼‰
                truncated = self._truncate_to_bytes(section, max_bytes - 200)
                truncated += "\n\n...(æœ¬æ®µå†…å®¹è¿‡é•¿å·²æˆªæ–­)"
                chunks.append(truncated)
                continue
            
            # æ£€æŸ¥åŠ å…¥åæ˜¯å¦è¶…é•¿
            if current_bytes + section_bytes > max_bytes:
                # ä¿å­˜å½“å‰å—ï¼Œå¼€å§‹æ–°å—
                if current_chunk:
                    chunks.append(separator.join(current_chunk))
                current_chunk = [section]
                current_bytes = section_bytes
            else:
                current_chunk.append(section)
                current_bytes += section_bytes
        
        # æ·»åŠ æœ€åä¸€å—
        if current_chunk:
            chunks.append(separator.join(current_chunk))
        
        # åˆ†æ‰¹å‘é€
        total_chunks = len(chunks)
        success_count = 0
        
        logger.info(f"ä¼ä¸šå¾®ä¿¡åˆ†æ‰¹å‘é€ï¼šå…± {total_chunks} æ‰¹")
        
        for i, chunk in enumerate(chunks):
            # æ·»åŠ åˆ†é¡µæ ‡è®°
            if total_chunks > 1:
                page_marker = f"\n\nğŸ“„ *({i+1}/{total_chunks})*"
                chunk_with_marker = chunk + page_marker
            else:
                chunk_with_marker = chunk
            
            try:
                if self._send_wechat_message(chunk_with_marker):
                    success_count += 1
                    logger.info(f"ä¼ä¸šå¾®ä¿¡ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€æˆåŠŸ")
                else:
                    logger.error(f"ä¼ä¸šå¾®ä¿¡ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€å¤±è´¥")
            except Exception as e:
                logger.error(f"ä¼ä¸šå¾®ä¿¡ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€å¼‚å¸¸: {e}")

            # æ‰¹æ¬¡é—´éš”ï¼Œé¿å…è§¦å‘é¢‘ç‡é™åˆ¶
            if i < total_chunks - 1:
                time.sleep(2.5)  # å¢åŠ åˆ° 2.5sï¼Œé¿å…ä¼ä¸šå¾®ä¿¡é™æµ

        return success_count == total_chunks
    
    def _send_wechat_force_chunked(self, content: str, max_bytes: int) -> bool:
        """
        å¼ºåˆ¶æŒ‰å­—èŠ‚åˆ†å‰²å‘é€ï¼ˆæ— æ³•æ™ºèƒ½åˆ†å‰²æ—¶çš„ fallbackï¼‰
        
        Args:
            content: å®Œæ•´æ¶ˆæ¯å†…å®¹
            max_bytes: å•æ¡æ¶ˆæ¯æœ€å¤§å­—èŠ‚æ•°
        """
        import time
        
        chunks = []
        current_chunk = ""
        
        # æŒ‰è¡Œåˆ†å‰²ï¼Œç¡®ä¿ä¸ä¼šåœ¨å¤šå­—èŠ‚å­—ç¬¦ä¸­é—´æˆªæ–­
        lines = content.split('\n')
        
        for line in lines:
            test_chunk = current_chunk + ('\n' if current_chunk else '') + line
            if len(test_chunk.encode('utf-8')) > max_bytes - 100:  # é¢„ç•™ç©ºé—´ç»™åˆ†é¡µæ ‡è®°
                if current_chunk:
                    chunks.append(current_chunk)
                current_chunk = line
            else:
                current_chunk = test_chunk
        
        if current_chunk:
            chunks.append(current_chunk)
        
        total_chunks = len(chunks)
        success_count = 0
        
        logger.info(f"ä¼ä¸šå¾®ä¿¡å¼ºåˆ¶åˆ†æ‰¹å‘é€ï¼šå…± {total_chunks} æ‰¹")
        
        for i, chunk in enumerate(chunks):
            page_marker = f"\n\nğŸ“„ *({i+1}/{total_chunks})*" if total_chunks > 1 else ""
            
            try:
                if self._send_wechat_message(chunk + page_marker):
                    success_count += 1
            except Exception as e:
                logger.error(f"ä¼ä¸šå¾®ä¿¡ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€å¼‚å¸¸: {e}")
            
            if i < total_chunks - 1:
                time.sleep(1)
        
        return success_count == total_chunks
    
    def _truncate_to_bytes(self, text: str, max_bytes: int) -> str:
        """
        æŒ‰å­—èŠ‚æ•°æˆªæ–­å­—ç¬¦ä¸²ï¼Œç¡®ä¿ä¸ä¼šåœ¨å¤šå­—èŠ‚å­—ç¬¦ä¸­é—´æˆªæ–­
        
        Args:
            text: è¦æˆªæ–­çš„å­—ç¬¦ä¸²
            max_bytes: æœ€å¤§å­—èŠ‚æ•°
            
        Returns:
            æˆªæ–­åçš„å­—ç¬¦ä¸²
        """
        encoded = text.encode('utf-8')
        if len(encoded) <= max_bytes:
            return text
        
        # ä» max_bytes ä½ç½®å¾€å‰æ‰¾ï¼Œç¡®ä¿ä¸æˆªæ–­å¤šå­—èŠ‚å­—ç¬¦
        truncated = encoded[:max_bytes]
        # å°è¯•è§£ç ï¼Œå¦‚æœå¤±è´¥åˆ™ç»§ç»­å¾€å‰
        while truncated:
            try:
                return truncated.decode('utf-8')
            except UnicodeDecodeError:
                truncated = truncated[:-1]
        return ""
    
    def _gen_wechat_payload(self, content: str) -> dict:
        """ç”Ÿæˆä¼ä¸šå¾®ä¿¡æ¶ˆæ¯ payload"""
        if self._wechat_msg_type == 'text':
            return {
                "msgtype": "text",
                "text": {
                    "content": content
                }
            }
        else:
            return {
                "msgtype": "markdown",
                "markdown": {
                    "content": content
                }
            }

    def _send_wechat_message(self, content: str) -> bool:
        """å‘é€ä¼ä¸šå¾®ä¿¡æ¶ˆæ¯"""
        payload = self._gen_wechat_payload(content)
        
        response = requests.post(
            self._wechat_url,
            json=payload,
            timeout=10
        )
        
        if response.status_code == 200:
            result = response.json()
            if result.get('errcode') == 0:
                logger.info("ä¼ä¸šå¾®ä¿¡æ¶ˆæ¯å‘é€æˆåŠŸ")
                return True
            else:
                logger.error(f"ä¼ä¸šå¾®ä¿¡è¿”å›é”™è¯¯: {result}")
                return False
        else:
            logger.error(f"ä¼ä¸šå¾®ä¿¡è¯·æ±‚å¤±è´¥: {response.status_code}")
            return False
    
    def send_to_feishu(self, content: str) -> bool:
        """
        æ¨é€æ¶ˆæ¯åˆ°é£ä¹¦æœºå™¨äºº
        
        é£ä¹¦è‡ªå®šä¹‰æœºå™¨äºº Webhook æ¶ˆæ¯æ ¼å¼ï¼š
        {
            "msg_type": "text",
            "content": {
                "text": "æ–‡æœ¬å†…å®¹"
            }
        }
        
        è¯´æ˜ï¼šé£ä¹¦æ–‡æœ¬æ¶ˆæ¯ä¸ä¼šæ¸²æŸ“ Markdownï¼Œéœ€ä½¿ç”¨äº¤äº’å¡ç‰‡ï¼ˆlark_mdï¼‰æ ¼å¼
        
        æ³¨æ„ï¼šé£ä¹¦æ–‡æœ¬æ¶ˆæ¯é™åˆ¶çº¦ 20KBï¼Œè¶…é•¿å†…å®¹ä¼šè‡ªåŠ¨åˆ†æ‰¹å‘é€
        å¯é€šè¿‡ç¯å¢ƒå˜é‡ FEISHU_MAX_BYTES è°ƒæ•´é™åˆ¶å€¼
        
        Args:
            content: æ¶ˆæ¯å†…å®¹ï¼ˆMarkdown ä¼šè½¬ä¸ºçº¯æ–‡æœ¬ï¼‰
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        if not self._feishu_url:
            logger.warning("é£ä¹¦ Webhook æœªé…ç½®ï¼Œè·³è¿‡æ¨é€")
            return False
        
        # é£ä¹¦ lark_md æ”¯æŒæœ‰é™ï¼Œå…ˆåšæ ¼å¼è½¬æ¢
        formatted_content = format_feishu_markdown(content)

        max_bytes = self._feishu_max_bytes  # ä»é…ç½®è¯»å–ï¼Œé»˜è®¤ 20000 å­—èŠ‚
        
        # æ£€æŸ¥å­—èŠ‚é•¿åº¦ï¼Œè¶…é•¿åˆ™åˆ†æ‰¹å‘é€
        content_bytes = len(formatted_content.encode('utf-8'))
        if content_bytes > max_bytes:
            logger.info(f"é£ä¹¦æ¶ˆæ¯å†…å®¹è¶…é•¿({content_bytes}å­—èŠ‚/{len(content)}å­—ç¬¦)ï¼Œå°†åˆ†æ‰¹å‘é€")
            return self._send_feishu_chunked(formatted_content, max_bytes)
        
        try:
            return self._send_feishu_message(formatted_content)
        except Exception as e:
            logger.error(f"å‘é€é£ä¹¦æ¶ˆæ¯å¤±è´¥: {e}")
            return False
    
    def _send_feishu_chunked(self, content: str, max_bytes: int) -> bool:
        """
        åˆ†æ‰¹å‘é€é•¿æ¶ˆæ¯åˆ°é£ä¹¦
        
        æŒ‰è‚¡ç¥¨åˆ†æå—ï¼ˆä»¥ --- æˆ– ### åˆ†éš”ï¼‰æ™ºèƒ½åˆ†å‰²ï¼Œç¡®ä¿æ¯æ‰¹ä¸è¶…è¿‡é™åˆ¶
        
        Args:
            content: å®Œæ•´æ¶ˆæ¯å†…å®¹
            max_bytes: å•æ¡æ¶ˆæ¯æœ€å¤§å­—èŠ‚æ•°
            
        Returns:
            æ˜¯å¦å…¨éƒ¨å‘é€æˆåŠŸ
        """
        import time
        
        def get_bytes(s: str) -> int:
            """è·å–å­—ç¬¦ä¸²çš„ UTF-8 å­—èŠ‚æ•°"""
            return len(s.encode('utf-8'))
        
        # æ™ºèƒ½åˆ†å‰²ï¼šä¼˜å…ˆæŒ‰ "---" åˆ†éš”ï¼ˆè‚¡ç¥¨ä¹‹é—´çš„åˆ†éš”çº¿ï¼‰
        # å¦‚æœæ²¡æœ‰åˆ†éš”çº¿ï¼ŒæŒ‰ "### " æ ‡é¢˜åˆ†å‰²ï¼ˆæ¯åªè‚¡ç¥¨çš„æ ‡é¢˜ï¼‰
        if "\n---\n" in content:
            sections = content.split("\n---\n")
            separator = "\n---\n"
        elif "\n### " in content:
            # æŒ‰ ### åˆ†å‰²ï¼Œä½†ä¿ç•™ ### å‰ç¼€
            parts = content.split("\n### ")
            sections = [parts[0]] + [f"### {p}" for p in parts[1:]]
            separator = "\n"
        else:
            # æ— æ³•æ™ºèƒ½åˆ†å‰²ï¼ŒæŒ‰è¡Œå¼ºåˆ¶åˆ†å‰²
            return self._send_feishu_force_chunked(content, max_bytes)
        
        chunks = []
        current_chunk = []
        current_bytes = 0
        separator_bytes = get_bytes(separator)
        
        for section in sections:
            section_bytes = get_bytes(section) + separator_bytes
            
            # å¦‚æœå•ä¸ª section å°±è¶…é•¿ï¼Œéœ€è¦å¼ºåˆ¶æˆªæ–­
            if section_bytes > max_bytes:
                # å…ˆå‘é€å½“å‰ç§¯ç´¯çš„å†…å®¹
                if current_chunk:
                    chunks.append(separator.join(current_chunk))
                    current_chunk = []
                    current_bytes = 0
                
                # å¼ºåˆ¶æˆªæ–­è¿™ä¸ªè¶…é•¿ sectionï¼ˆæŒ‰å­—èŠ‚æˆªæ–­ï¼‰
                truncated = self._truncate_to_bytes(section, max_bytes - 200)
                truncated += "\n\n...(æœ¬æ®µå†…å®¹è¿‡é•¿å·²æˆªæ–­)"
                chunks.append(truncated)
                continue
            
            # æ£€æŸ¥åŠ å…¥åæ˜¯å¦è¶…é•¿
            if current_bytes + section_bytes > max_bytes:
                # ä¿å­˜å½“å‰å—ï¼Œå¼€å§‹æ–°å—
                if current_chunk:
                    chunks.append(separator.join(current_chunk))
                current_chunk = [section]
                current_bytes = section_bytes
            else:
                current_chunk.append(section)
                current_bytes += section_bytes
        
        # æ·»åŠ æœ€åä¸€å—
        if current_chunk:
            chunks.append(separator.join(current_chunk))
        
        # åˆ†æ‰¹å‘é€
        total_chunks = len(chunks)
        success_count = 0
        
        logger.info(f"é£ä¹¦åˆ†æ‰¹å‘é€ï¼šå…± {total_chunks} æ‰¹")
        
        for i, chunk in enumerate(chunks):
            # æ·»åŠ åˆ†é¡µæ ‡è®°
            if total_chunks > 1:
                page_marker = f"\n\nğŸ“„ ({i+1}/{total_chunks})"
                chunk_with_marker = chunk + page_marker
            else:
                chunk_with_marker = chunk
            
            try:
                if self._send_feishu_message(chunk_with_marker):
                    success_count += 1
                    logger.info(f"é£ä¹¦ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€æˆåŠŸ")
                else:
                    logger.error(f"é£ä¹¦ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€å¤±è´¥")
            except Exception as e:
                logger.error(f"é£ä¹¦ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€å¼‚å¸¸: {e}")
            
            # æ‰¹æ¬¡é—´éš”ï¼Œé¿å…è§¦å‘é¢‘ç‡é™åˆ¶
            if i < total_chunks - 1:
                time.sleep(1)
        
        return success_count == total_chunks
    
    def _send_feishu_force_chunked(self, content: str, max_bytes: int) -> bool:
        """
        å¼ºåˆ¶æŒ‰å­—èŠ‚åˆ†å‰²å‘é€ï¼ˆæ— æ³•æ™ºèƒ½åˆ†å‰²æ—¶çš„ fallbackï¼‰
        
        Args:
            content: å®Œæ•´æ¶ˆæ¯å†…å®¹
            max_bytes: å•æ¡æ¶ˆæ¯æœ€å¤§å­—èŠ‚æ•°
        """
        import time
        
        chunks = []
        current_chunk = ""
        
        # æŒ‰è¡Œåˆ†å‰²ï¼Œç¡®ä¿ä¸ä¼šåœ¨å¤šå­—èŠ‚å­—ç¬¦ä¸­é—´æˆªæ–­
        lines = content.split('\n')
        
        for line in lines:
            test_chunk = current_chunk + ('\n' if current_chunk else '') + line
            if len(test_chunk.encode('utf-8')) > max_bytes - 100:  # é¢„ç•™ç©ºé—´ç»™åˆ†é¡µæ ‡è®°
                if current_chunk:
                    chunks.append(current_chunk)
                current_chunk = line
            else:
                current_chunk = test_chunk
        
        if current_chunk:
            chunks.append(current_chunk)
        
        total_chunks = len(chunks)
        success_count = 0
        
        logger.info(f"é£ä¹¦å¼ºåˆ¶åˆ†æ‰¹å‘é€ï¼šå…± {total_chunks} æ‰¹")
        
        for i, chunk in enumerate(chunks):
            page_marker = f"\n\nğŸ“„ ({i+1}/{total_chunks})" if total_chunks > 1 else ""
            
            try:
                if self._send_feishu_message(chunk + page_marker):
                    success_count += 1
            except Exception as e:
                logger.error(f"é£ä¹¦ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€å¼‚å¸¸: {e}")
            
            if i < total_chunks - 1:
                time.sleep(1)
        
        return success_count == total_chunks
    
    def _send_feishu_message(self, content: str) -> bool:
        """å‘é€å•æ¡é£ä¹¦æ¶ˆæ¯ï¼ˆä¼˜å…ˆä½¿ç”¨ Markdown å¡ç‰‡ï¼‰"""
        def _post_payload(payload: Dict[str, Any]) -> bool:
            logger.debug(f"é£ä¹¦è¯·æ±‚ URL: {self._feishu_url}")
            logger.debug(f"é£ä¹¦è¯·æ±‚ payload é•¿åº¦: {len(content)} å­—ç¬¦")

            response = requests.post(
                self._feishu_url,
                json=payload,
                timeout=30
            )

            logger.debug(f"é£ä¹¦å“åº”çŠ¶æ€ç : {response.status_code}")
            logger.debug(f"é£ä¹¦å“åº”å†…å®¹: {response.text}")

            if response.status_code == 200:
                result = response.json()
                code = result.get('code') if 'code' in result else result.get('StatusCode')
                if code == 0:
                    logger.info("é£ä¹¦æ¶ˆæ¯å‘é€æˆåŠŸ")
                    return True
                else:
                    error_msg = result.get('msg') or result.get('StatusMessage', 'æœªçŸ¥é”™è¯¯')
                    error_code = result.get('code') or result.get('StatusCode', 'N/A')
                    logger.error(f"é£ä¹¦è¿”å›é”™è¯¯ [code={error_code}]: {error_msg}")
                    logger.error(f"å®Œæ•´å“åº”: {result}")
                    return False
            else:
                logger.error(f"é£ä¹¦è¯·æ±‚å¤±è´¥: HTTP {response.status_code}")
                logger.error(f"å“åº”å†…å®¹: {response.text}")
                return False

        # 1) ä¼˜å…ˆä½¿ç”¨äº¤äº’å¡ç‰‡ï¼ˆæ”¯æŒ Markdown æ¸²æŸ“ï¼‰
        card_payload = {
            "msg_type": "interactive",
            "card": {
                "config": {"wide_screen_mode": True},
                "header": {
                    "title": {
                        "tag": "plain_text",
                        "content": "Aè‚¡æ™ºèƒ½åˆ†ææŠ¥å‘Š"
                    }
                },
                "elements": [
                    {
                        "tag": "div",
                        "text": {
                            "tag": "lark_md",
                            "content": content
                        }
                    }
                ]
            }
        }

        if _post_payload(card_payload):
            return True

        # 2) å›é€€ä¸ºæ™®é€šæ–‡æœ¬æ¶ˆæ¯
        text_payload = {
            "msg_type": "text",
            "content": {
                "text": content
            }
        }

        return _post_payload(text_payload)

    def send_to_email(self, content: str, subject: Optional[str] = None) -> bool:
        """
        é€šè¿‡ SMTP å‘é€é‚®ä»¶ï¼ˆè‡ªåŠ¨è¯†åˆ« SMTP æœåŠ¡å™¨ï¼‰
        
        Args:
            content: é‚®ä»¶å†…å®¹ï¼ˆæ”¯æŒ Markdownï¼Œä¼šè½¬æ¢ä¸º HTMLï¼‰
            subject: é‚®ä»¶ä¸»é¢˜ï¼ˆå¯é€‰ï¼Œé»˜è®¤è‡ªåŠ¨ç”Ÿæˆï¼‰
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        if not self._is_email_configured():
            logger.warning("é‚®ä»¶é…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡æ¨é€")
            return False
        
        sender = self._email_config['sender']
        password = self._email_config['password']
        receivers = self._email_config['receivers']
        
        try:
            # ç”Ÿæˆä¸»é¢˜
            if subject is None:
                date_str = datetime.now().strftime('%Y-%m-%d')
                subject = f"ğŸ“ˆ è‚¡ç¥¨æ™ºèƒ½åˆ†ææŠ¥å‘Š - {date_str}"
            
            # å°† Markdown è½¬æ¢ä¸ºç®€å• HTML
            html_content = self._markdown_to_html(content)
            
            # æ„å»ºé‚®ä»¶
            msg = MIMEMultipart('alternative')
            msg['Subject'] = Header(subject, 'utf-8')
            msg['From'] = sender
            msg['To'] = ', '.join(receivers)
            
            # æ·»åŠ çº¯æ–‡æœ¬å’Œ HTML ä¸¤ä¸ªç‰ˆæœ¬
            text_part = MIMEText(content, 'plain', 'utf-8')
            html_part = MIMEText(html_content, 'html', 'utf-8')
            msg.attach(text_part)
            msg.attach(html_part)
            
            # è‡ªåŠ¨è¯†åˆ« SMTP é…ç½®
            domain = sender.split('@')[-1].lower()
            smtp_config = SMTP_CONFIGS.get(domain)
            
            if smtp_config:
                smtp_server = smtp_config['server']
                smtp_port = smtp_config['port']
                use_ssl = smtp_config['ssl']
                logger.info(f"è‡ªåŠ¨è¯†åˆ«é‚®ç®±ç±»å‹: {domain} -> {smtp_server}:{smtp_port}")
            else:
                # æœªçŸ¥é‚®ç®±ï¼Œå°è¯•é€šç”¨é…ç½®
                smtp_server = f"smtp.{domain}"
                smtp_port = 465
                use_ssl = True
                logger.warning(f"æœªçŸ¥é‚®ç®±ç±»å‹ {domain}ï¼Œå°è¯•é€šç”¨é…ç½®: {smtp_server}:{smtp_port}")
            
            # æ ¹æ®é…ç½®é€‰æ‹©è¿æ¥æ–¹å¼
            if use_ssl:
                # SSL è¿æ¥ï¼ˆç«¯å£ 465ï¼‰
                server = smtplib.SMTP_SSL(smtp_server, smtp_port, timeout=30)
            else:
                # TLS è¿æ¥ï¼ˆç«¯å£ 587ï¼‰
                server = smtplib.SMTP(smtp_server, smtp_port, timeout=30)
                server.starttls()
            
            server.login(sender, password)
            server.send_message(msg)
            server.quit()
            
            logger.info(f"é‚®ä»¶å‘é€æˆåŠŸï¼Œæ”¶ä»¶äºº: {receivers}")
            return True
            
        except smtplib.SMTPAuthenticationError:
            logger.error("é‚®ä»¶å‘é€å¤±è´¥ï¼šè®¤è¯é”™è¯¯ï¼Œè¯·æ£€æŸ¥é‚®ç®±å’Œæˆæƒç æ˜¯å¦æ­£ç¡®")
            return False
        except smtplib.SMTPConnectError as e:
            logger.error(f"é‚®ä»¶å‘é€å¤±è´¥ï¼šæ— æ³•è¿æ¥ SMTP æœåŠ¡å™¨ - {e}")
            return False
        except Exception as e:
            logger.error(f"å‘é€é‚®ä»¶å¤±è´¥: {e}")
            return False
    
    def _markdown_to_html(self, markdown_text: str) -> str:
        """
        å°† Markdown è½¬æ¢ä¸º HTMLï¼Œæ”¯æŒè¡¨æ ¼å¹¶ä¼˜åŒ–æ’ç‰ˆ

        ä½¿ç”¨ markdown2 åº“è¿›è¡Œè½¬æ¢ï¼Œå¹¶æ·»åŠ ä¼˜åŒ–çš„ CSS æ ·å¼
        è§£å†³é—®é¢˜ï¼š
        1. é‚®ä»¶è¡¨æ ¼æœªæ¸²æŸ“é—®é¢˜
        2. é‚®ä»¶å†…å®¹æ’ç‰ˆè¿‡äºæ¾æ•£é—®é¢˜
        """
        # ä½¿ç”¨ markdown2 è½¬æ¢ï¼Œå¼€å¯è¡¨æ ¼å’Œå…¶ä»–æ‰©å±•æ”¯æŒ
        html_content = markdown2.markdown(
            markdown_text,
            extras=["tables", "fenced-code-blocks", "break-on-newline", "cuddled-lists"]
        )

        # ä¼˜åŒ– CSS æ ·å¼ï¼šæ›´ç´§å‡‘çš„æ’ç‰ˆï¼Œç¾è§‚çš„è¡¨æ ¼
        css_style = """
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
                line-height: 1.5;
                color: #24292e;
                font-size: 14px;
                padding: 15px;
                max-width: 900px;
                margin: 0 auto;
            }
            h1 {
                font-size: 20px;
                border-bottom: 1px solid #eaecef;
                padding-bottom: 0.3em;
                margin-top: 1.2em;
                margin-bottom: 0.8em;
                color: #0366d6;
            }
            h2 {
                font-size: 18px;
                border-bottom: 1px solid #eaecef;
                padding-bottom: 0.3em;
                margin-top: 1.0em;
                margin-bottom: 0.6em;
            }
            h3 {
                font-size: 16px;
                margin-top: 0.8em;
                margin-bottom: 0.4em;
            }
            p {
                margin-top: 0;
                margin-bottom: 8px;
            }
            /* è¡¨æ ¼æ ·å¼ä¼˜åŒ– */
            table {
                border-collapse: collapse;
                width: 100%;
                margin: 12px 0;
                display: block;
                overflow-x: auto;
                font-size: 13px;
            }
            th, td {
                border: 1px solid #dfe2e5;
                padding: 6px 10px;
                text-align: left;
            }
            th {
                background-color: #f6f8fa;
                font-weight: 600;
            }
            tr:nth-child(2n) {
                background-color: #f8f8f8;
            }
            tr:hover {
                background-color: #f1f8ff;
            }
            /* å¼•ç”¨å—æ ·å¼ */
            blockquote {
                color: #6a737d;
                border-left: 0.25em solid #dfe2e5;
                padding: 0 1em;
                margin: 0 0 10px 0;
            }
            /* ä»£ç å—æ ·å¼ */
            code {
                padding: 0.2em 0.4em;
                margin: 0;
                font-size: 85%;
                background-color: rgba(27,31,35,0.05);
                border-radius: 3px;
                font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            }
            pre {
                padding: 12px;
                overflow: auto;
                line-height: 1.45;
                background-color: #f6f8fa;
                border-radius: 3px;
                margin-bottom: 10px;
            }
            hr {
                height: 0.25em;
                padding: 0;
                margin: 16px 0;
                background-color: #e1e4e8;
                border: 0;
            }
            ul, ol {
                padding-left: 20px;
                margin-bottom: 10px;
            }
            li {
                margin: 2px 0;
            }
        """

        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <style>
                {css_style}
            </style>
        </head>
        <body>
            {html_content}
        </body>
        </html>
        """
    
    def send_to_telegram(self, content: str) -> bool:
        """
        æ¨é€æ¶ˆæ¯åˆ° Telegram æœºå™¨äºº
        
        Telegram Bot API æ ¼å¼ï¼š
        POST https://api.telegram.org/bot<token>/sendMessage
        {
            "chat_id": "xxx",
            "text": "æ¶ˆæ¯å†…å®¹",
            "parse_mode": "Markdown"
        }
        
        Args:
            content: æ¶ˆæ¯å†…å®¹ï¼ˆMarkdown æ ¼å¼ï¼‰
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        if not self._is_telegram_configured():
            logger.warning("Telegram é…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡æ¨é€")
            return False
        
        bot_token = self._telegram_config['bot_token']
        chat_id = self._telegram_config['chat_id']
        message_thread_id = self._telegram_config.get('message_thread_id')
        
        try:
            # Telegram API ç«¯ç‚¹
            api_url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
            
            # Telegram æ¶ˆæ¯æœ€å¤§é•¿åº¦ 4096 å­—ç¬¦
            max_length = 4096
            
            if len(content) <= max_length:
                # å•æ¡æ¶ˆæ¯å‘é€
                return self._send_telegram_message(api_url, chat_id, content, message_thread_id)
            else:
                # åˆ†æ®µå‘é€é•¿æ¶ˆæ¯
                return self._send_telegram_chunked(api_url, chat_id, content, max_length, message_thread_id)
                
        except Exception as e:
            logger.error(f"å‘é€ Telegram æ¶ˆæ¯å¤±è´¥: {e}")
            import traceback
            logger.debug(traceback.format_exc())
            return False
    
    def _send_telegram_message(self, api_url: str, chat_id: str, text: str, message_thread_id: Optional[str] = None) -> bool:
        """å‘é€å•æ¡ Telegram æ¶ˆæ¯"""
        # è½¬æ¢ Markdown ä¸º Telegram æ”¯æŒçš„æ ¼å¼
        # Telegram çš„ Markdown æ ¼å¼ç¨æœ‰ä¸åŒï¼Œåšç®€å•å¤„ç†
        telegram_text = self._convert_to_telegram_markdown(text)
        
        payload = {
            "chat_id": chat_id,
            "text": telegram_text,
            "parse_mode": "Markdown",
            "disable_web_page_preview": True
        }

        if message_thread_id:
            payload['message_thread_id'] = message_thread_id
        
        response = requests.post(api_url, json=payload, timeout=10)
        
        if response.status_code == 200:
            result = response.json()
            if result.get('ok'):
                logger.info("Telegram æ¶ˆæ¯å‘é€æˆåŠŸ")
                return True
            else:
                error_desc = result.get('description', 'æœªçŸ¥é”™è¯¯')
                logger.error(f"Telegram è¿”å›é”™è¯¯: {error_desc}")
                
                # å¦‚æœ Markdown è§£æå¤±è´¥ï¼Œå°è¯•çº¯æ–‡æœ¬å‘é€
                if 'parse' in error_desc.lower() or 'markdown' in error_desc.lower():
                    logger.info("å°è¯•ä½¿ç”¨çº¯æ–‡æœ¬æ ¼å¼é‡æ–°å‘é€...")
                    payload['parse_mode'] = None
                    payload['text'] = text  # ä½¿ç”¨åŸå§‹æ–‡æœ¬
                    del payload['parse_mode']
                    
                    response = requests.post(api_url, json=payload, timeout=10)
                    if response.status_code == 200 and response.json().get('ok'):
                        logger.info("Telegram æ¶ˆæ¯å‘é€æˆåŠŸï¼ˆçº¯æ–‡æœ¬ï¼‰")
                        return True
                
                return False
        else:
            logger.error(f"Telegram è¯·æ±‚å¤±è´¥: HTTP {response.status_code}")
            logger.error(f"å“åº”å†…å®¹: {response.text}")
            return False
    
    def _send_telegram_chunked(self, api_url: str, chat_id: str, content: str, max_length: int, message_thread_id: Optional[str] = None) -> bool:
        """åˆ†æ®µå‘é€é•¿ Telegram æ¶ˆæ¯"""
        # æŒ‰æ®µè½åˆ†å‰²
        sections = content.split("\n---\n")
        
        current_chunk = []
        current_length = 0
        all_success = True
        chunk_index = 1
        
        for section in sections:
            section_length = len(section) + 5  # +5 for "\n---\n"
            
            if current_length + section_length > max_length:
                # å‘é€å½“å‰å—
                if current_chunk:
                    chunk_content = "\n---\n".join(current_chunk)
                    logger.info(f"å‘é€ Telegram æ¶ˆæ¯å— {chunk_index}...")
                    if not self._send_telegram_message(api_url, chat_id, chunk_content, message_thread_id):
                        all_success = False
                    chunk_index += 1
                
                # é‡ç½®
                current_chunk = [section]
                current_length = section_length
            else:
                current_chunk.append(section)
                current_length += section_length
        
        # å‘é€æœ€åä¸€å—
        if current_chunk:
            chunk_content = "\n---\n".join(current_chunk)
            logger.info(f"å‘é€ Telegram æ¶ˆæ¯å— {chunk_index}...")
            if not self._send_telegram_message(api_url, chat_id, chunk_content, message_thread_id):
                all_success = False
                
        return all_success
    
    def _convert_to_telegram_markdown(self, text: str) -> str:
        """
        å°†æ ‡å‡† Markdown è½¬æ¢ä¸º Telegram æ”¯æŒçš„æ ¼å¼
        
        Telegram Markdown é™åˆ¶ï¼š
        - ä¸æ”¯æŒ # æ ‡é¢˜
        - ä½¿ç”¨ *bold* è€Œé **bold**
        - ä½¿ç”¨ _italic_ 
        """
        result = text
        
        # ç§»é™¤ # æ ‡é¢˜æ ‡è®°ï¼ˆTelegram ä¸æ”¯æŒï¼‰
        result = re.sub(r'^#{1,6}\s+', '', result, flags=re.MULTILINE)
        
        # è½¬æ¢ **bold** ä¸º *bold*
        result = re.sub(r'\*\*(.+?)\*\*', r'*\1*', result)
        
        # è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦ï¼ˆTelegram Markdown éœ€è¦ï¼‰
        # æ³¨æ„ï¼šä¸è½¬ä¹‰å·²ç»ç”¨äºæ ¼å¼çš„ * _ `
        for char in ['[', ']', '(', ')']:
            result = result.replace(char, f'\\{char}')
        
        return result
    
    def send_to_pushover(self, content: str, title: Optional[str] = None) -> bool:
        """
        æ¨é€æ¶ˆæ¯åˆ° Pushover
        
        Pushover API æ ¼å¼ï¼š
        POST https://api.pushover.net/1/messages.json
        {
            "token": "åº”ç”¨ API Token",
            "user": "ç”¨æˆ· Key",
            "message": "æ¶ˆæ¯å†…å®¹",
            "title": "æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰"
        }
        
        Pushover ç‰¹ç‚¹ï¼š
        - æ”¯æŒ iOS/Android/æ¡Œé¢å¤šå¹³å°æ¨é€
        - æ¶ˆæ¯é™åˆ¶ 1024 å­—ç¬¦
        - æ”¯æŒä¼˜å…ˆçº§è®¾ç½®
        - æ”¯æŒ HTML æ ¼å¼
        
        Args:
            content: æ¶ˆæ¯å†…å®¹ï¼ˆMarkdown æ ¼å¼ï¼Œä¼šè½¬ä¸ºçº¯æ–‡æœ¬ï¼‰
            title: æ¶ˆæ¯æ ‡é¢˜ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸º"è‚¡ç¥¨åˆ†ææŠ¥å‘Š"ï¼‰
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        if not self._is_pushover_configured():
            logger.warning("Pushover é…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡æ¨é€")
            return False
        
        user_key = self._pushover_config['user_key']
        api_token = self._pushover_config['api_token']
        
        # Pushover API ç«¯ç‚¹
        api_url = "https://api.pushover.net/1/messages.json"
        
        # å¤„ç†æ¶ˆæ¯æ ‡é¢˜
        if title is None:
            date_str = datetime.now().strftime('%Y-%m-%d')
            title = f"ğŸ“ˆ è‚¡ç¥¨åˆ†ææŠ¥å‘Š - {date_str}"
        
        # Pushover æ¶ˆæ¯é™åˆ¶ 1024 å­—ç¬¦
        max_length = 1024
        
        # è½¬æ¢ Markdown ä¸ºçº¯æ–‡æœ¬ï¼ˆPushover æ”¯æŒ HTMLï¼Œä½†çº¯æ–‡æœ¬æ›´é€šç”¨ï¼‰
        plain_content = self._markdown_to_plain_text(content)
        
        if len(plain_content) <= max_length:
            # å•æ¡æ¶ˆæ¯å‘é€
            return self._send_pushover_message(api_url, user_key, api_token, plain_content, title)
        else:
            # åˆ†æ®µå‘é€é•¿æ¶ˆæ¯
            return self._send_pushover_chunked(api_url, user_key, api_token, plain_content, title, max_length)
    
    def _markdown_to_plain_text(self, markdown_text: str) -> str:
        """
        å°† Markdown è½¬æ¢ä¸ºçº¯æ–‡æœ¬
        
        ç§»é™¤ Markdown æ ¼å¼æ ‡è®°ï¼Œä¿ç•™å¯è¯»æ€§
        """
        text = markdown_text
        
        # ç§»é™¤æ ‡é¢˜æ ‡è®° # ## ###
        text = re.sub(r'^#{1,6}\s+', '', text, flags=re.MULTILINE)
        
        # ç§»é™¤åŠ ç²— **text** -> text
        text = re.sub(r'\*\*(.+?)\*\*', r'\1', text)
        
        # ç§»é™¤æ–œä½“ *text* -> text
        text = re.sub(r'\*(.+?)\*', r'\1', text)
        
        # ç§»é™¤å¼•ç”¨ > text -> text
        text = re.sub(r'^>\s+', '', text, flags=re.MULTILINE)
        
        # ç§»é™¤åˆ—è¡¨æ ‡è®° - item -> item
        text = re.sub(r'^[-*]\s+', 'â€¢ ', text, flags=re.MULTILINE)
        
        # ç§»é™¤åˆ†éš”çº¿ ---
        text = re.sub(r'^---+$', 'â”€â”€â”€â”€â”€â”€â”€â”€', text, flags=re.MULTILINE)
        
        # ç§»é™¤è¡¨æ ¼è¯­æ³• |---|---|
        text = re.sub(r'\|[-:]+\|[-:|\s]+\|', '', text)
        text = re.sub(r'^\|(.+)\|$', r'\1', text, flags=re.MULTILINE)
        
        # æ¸…ç†å¤šä½™ç©ºè¡Œ
        text = re.sub(r'\n{3,}', '\n\n', text)
        
        return text.strip()
    
    def _send_pushover_message(
        self, 
        api_url: str, 
        user_key: str, 
        api_token: str, 
        message: str, 
        title: str,
        priority: int = 0
    ) -> bool:
        """
        å‘é€å•æ¡ Pushover æ¶ˆæ¯
        
        Args:
            api_url: Pushover API ç«¯ç‚¹
            user_key: ç”¨æˆ· Key
            api_token: åº”ç”¨ API Token
            message: æ¶ˆæ¯å†…å®¹
            title: æ¶ˆæ¯æ ‡é¢˜
            priority: ä¼˜å…ˆçº§ (-2 ~ 2ï¼Œé»˜è®¤ 0)
        """
        try:
            payload = {
                "token": api_token,
                "user": user_key,
                "message": message,
                "title": title,
                "priority": priority,
            }
            
            response = requests.post(api_url, data=payload, timeout=30)
            
            if response.status_code == 200:
                result = response.json()
                if result.get('status') == 1:
                    logger.info("Pushover æ¶ˆæ¯å‘é€æˆåŠŸ")
                    return True
                else:
                    errors = result.get('errors', ['æœªçŸ¥é”™è¯¯'])
                    logger.error(f"Pushover è¿”å›é”™è¯¯: {errors}")
                    return False
            else:
                logger.error(f"Pushover è¯·æ±‚å¤±è´¥: HTTP {response.status_code}")
                logger.debug(f"å“åº”å†…å®¹: {response.text}")
                return False
                
        except Exception as e:
            logger.error(f"å‘é€ Pushover æ¶ˆæ¯å¤±è´¥: {e}")
            return False
    
    def _send_pushover_chunked(
        self, 
        api_url: str, 
        user_key: str, 
        api_token: str, 
        content: str, 
        title: str,
        max_length: int
    ) -> bool:
        """
        åˆ†æ®µå‘é€é•¿ Pushover æ¶ˆæ¯
        
        æŒ‰æ®µè½åˆ†å‰²ï¼Œç¡®ä¿æ¯æ®µä¸è¶…è¿‡æœ€å¤§é•¿åº¦
        """
        import time
        
        # æŒ‰æ®µè½ï¼ˆåˆ†éš”çº¿æˆ–åŒæ¢è¡Œï¼‰åˆ†å‰²
        if "â”€â”€â”€â”€â”€â”€â”€â”€" in content:
            sections = content.split("â”€â”€â”€â”€â”€â”€â”€â”€")
            separator = "â”€â”€â”€â”€â”€â”€â”€â”€"
        else:
            sections = content.split("\n\n")
            separator = "\n\n"
        
        chunks = []
        current_chunk = []
        current_length = 0
        
        for section in sections:
            # è®¡ç®—æ·»åŠ è¿™ä¸ª section åçš„å®é™…é•¿åº¦
            # join() åªåœ¨å…ƒç´ ä¹‹é—´æ”¾ç½®åˆ†éš”ç¬¦ï¼Œä¸æ˜¯æ¯ä¸ªå…ƒç´ åé¢
            # æ‰€ä»¥ï¼šç¬¬ä¸€ä¸ªå…ƒç´ ä¸éœ€è¦åˆ†éš”ç¬¦ï¼Œåç»­å…ƒç´ éœ€è¦ä¸€ä¸ªåˆ†éš”ç¬¦è¿æ¥
            if current_chunk:
                # å·²æœ‰å…ƒç´ ï¼Œæ·»åŠ æ–°å…ƒç´ éœ€è¦ï¼šå½“å‰é•¿åº¦ + åˆ†éš”ç¬¦ + æ–° section
                new_length = current_length + len(separator) + len(section)
            else:
                # ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä¸éœ€è¦åˆ†éš”ç¬¦
                new_length = len(section)
            
            if new_length > max_length:
                if current_chunk:
                    chunks.append(separator.join(current_chunk))
                current_chunk = [section]
                current_length = len(section)
            else:
                current_chunk.append(section)
                current_length = new_length
        
        if current_chunk:
            chunks.append(separator.join(current_chunk))
        
        total_chunks = len(chunks)
        success_count = 0
        
        logger.info(f"Pushover åˆ†æ‰¹å‘é€ï¼šå…± {total_chunks} æ‰¹")
        
        for i, chunk in enumerate(chunks):
            # æ·»åŠ åˆ†é¡µæ ‡è®°åˆ°æ ‡é¢˜
            chunk_title = f"{title} ({i+1}/{total_chunks})" if total_chunks > 1 else title
            
            if self._send_pushover_message(api_url, user_key, api_token, chunk, chunk_title):
                success_count += 1
                logger.info(f"Pushover ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€æˆåŠŸ")
            else:
                logger.error(f"Pushover ç¬¬ {i+1}/{total_chunks} æ‰¹å‘é€å¤±è´¥")
            
            # æ‰¹æ¬¡é—´éš”ï¼Œé¿å…è§¦å‘é¢‘ç‡é™åˆ¶
            if i < total_chunks - 1:
                time.sleep(1)
        
        return success_count == total_chunks
    
    def send_to_custom(self, content: str) -> bool:
        """
        æ¨é€æ¶ˆæ¯åˆ°è‡ªå®šä¹‰ Webhook
        
        æ”¯æŒä»»æ„æ¥å— POST JSON çš„ Webhook ç«¯ç‚¹
        é»˜è®¤å‘é€æ ¼å¼ï¼š{"text": "æ¶ˆæ¯å†…å®¹", "content": "æ¶ˆæ¯å†…å®¹"}
        
        é€‚ç”¨äºï¼š
        - é’‰é’‰æœºå™¨äºº
        - Discord Webhook
        - Slack Incoming Webhook
        - è‡ªå»ºé€šçŸ¥æœåŠ¡
        - å…¶ä»–æ”¯æŒ POST JSON çš„æœåŠ¡
        
        Args:
            content: æ¶ˆæ¯å†…å®¹ï¼ˆMarkdown æ ¼å¼ï¼‰
            
        Returns:
            æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ª Webhook å‘é€æˆåŠŸ
        """
        if not self._custom_webhook_urls:
            logger.warning("æœªé…ç½®è‡ªå®šä¹‰ Webhookï¼Œè·³è¿‡æ¨é€")
            return False
        
        success_count = 0
        
        for i, url in enumerate(self._custom_webhook_urls):
            try:
                # é€šç”¨ JSON æ ¼å¼ï¼Œå…¼å®¹å¤§å¤šæ•° Webhook
                # é’‰é’‰æ ¼å¼: {"msgtype": "text", "text": {"content": "xxx"}}
                # Slack æ ¼å¼: {"text": "xxx"}
                # Discord æ ¼å¼: {"content": "xxx"}
                
                # é’‰é’‰æœºå™¨äººå¯¹ body æœ‰å­—èŠ‚ä¸Šé™ï¼ˆçº¦ 20000 bytesï¼‰ï¼Œè¶…é•¿éœ€è¦åˆ†æ‰¹å‘é€
                if self._is_dingtalk_webhook(url):
                    if self._send_dingtalk_chunked(url, content, max_bytes=20000):
                        logger.info(f"è‡ªå®šä¹‰ Webhook {i+1}ï¼ˆé’‰é’‰ï¼‰æ¨é€æˆåŠŸ")
                        success_count += 1
                    else:
                        logger.error(f"è‡ªå®šä¹‰ Webhook {i+1}ï¼ˆé’‰é’‰ï¼‰æ¨é€å¤±è´¥")
                    continue

                # å…¶ä»– Webhookï¼šå•æ¬¡å‘é€
                payload = self._build_custom_webhook_payload(url, content)
                if self._post_custom_webhook(url, payload, timeout=30):
                    logger.info(f"è‡ªå®šä¹‰ Webhook {i+1} æ¨é€æˆåŠŸ")
                    success_count += 1
                else:
                    logger.error(f"è‡ªå®šä¹‰ Webhook {i+1} æ¨é€å¤±è´¥")
                    
            except Exception as e:
                logger.error(f"è‡ªå®šä¹‰ Webhook {i+1} æ¨é€å¼‚å¸¸: {e}")
        
        logger.info(f"è‡ªå®šä¹‰ Webhook æ¨é€å®Œæˆï¼šæˆåŠŸ {success_count}/{len(self._custom_webhook_urls)}")
        return success_count > 0

    @staticmethod
    def _is_dingtalk_webhook(url: str) -> bool:
        url_lower = (url or "").lower()
        return 'dingtalk' in url_lower or 'oapi.dingtalk.com' in url_lower

    def _post_custom_webhook(self, url: str, payload: dict, timeout: int = 30) -> bool:
        headers = {
            'Content-Type': 'application/json; charset=utf-8',
            'User-Agent': 'StockAnalysis/1.0',
        }
        # æ”¯æŒ Bearer Token è®¤è¯ï¼ˆ#51ï¼‰
        if self._custom_webhook_bearer_token:
            headers['Authorization'] = f'Bearer {self._custom_webhook_bearer_token}'
        body = json.dumps(payload, ensure_ascii=False).encode('utf-8')
        response = requests.post(url, data=body, headers=headers, timeout=timeout)
        if response.status_code == 200:
            return True
        logger.error(f"è‡ªå®šä¹‰ Webhook æ¨é€å¤±è´¥: HTTP {response.status_code}")
        logger.debug(f"å“åº”å†…å®¹: {response.text[:200]}")
        return False

    def _chunk_markdown_by_bytes(self, content: str, max_bytes: int) -> List[str]:
        def get_bytes(s: str) -> int:
            return len(s.encode('utf-8'))

        def split_by_bytes(text: str, limit: int) -> List[str]:
            parts: List[str] = []
            remaining = text
            while remaining:
                part = self._truncate_to_bytes(remaining, limit)
                if not part:
                    break
                parts.append(part)
                remaining = remaining[len(part):]
            return parts

        # ä¼˜å…ˆæŒ‰åˆ†éš”çº¿/æ ‡é¢˜åˆ†å‰²ï¼Œä¿è¯åˆ†é¡µè‡ªç„¶
        if "\n---\n" in content:
            sections = content.split("\n---\n")
            separator = "\n---\n"
        elif "\n### " in content:
            parts = content.split("\n### ")
            sections = [parts[0]] + [f"### {p}" for p in parts[1:]]
            separator = "\n"
        else:
            # fallbackï¼šæŒ‰è¡Œæ‹¼æ¥
            sections = content.split("\n")
            separator = "\n"

        chunks: List[str] = []
        current_chunk: List[str] = []
        current_bytes = 0
        sep_bytes = get_bytes(separator)

        for section in sections:
            section_bytes = get_bytes(section)
            extra = sep_bytes if current_chunk else 0

            # å•æ®µè¶…é•¿ï¼šæˆªæ–­
            if section_bytes + extra > max_bytes:
                if current_chunk:
                    chunks.append(separator.join(current_chunk))
                    current_chunk = []
                    current_bytes = 0

                # æ— æ³•æŒ‰ç»“æ„æ‹†åˆ†æ—¶ï¼ŒæŒ‰å­—èŠ‚å¼ºåˆ¶æ‹†åˆ†ï¼Œé¿å…æ•´æ®µè¢«æˆªæ–­ä¸¢å¤±
                for part in split_by_bytes(section, max(200, max_bytes - 200)):
                    chunks.append(part)
                continue

            if current_bytes + section_bytes + extra > max_bytes:
                chunks.append(separator.join(current_chunk))
                current_chunk = [section]
                current_bytes = section_bytes
            else:
                if current_chunk:
                    current_bytes += sep_bytes
                current_chunk.append(section)
                current_bytes += section_bytes

        if current_chunk:
            chunks.append(separator.join(current_chunk))

        # ç§»é™¤ç©ºå—
        return [c for c in (c.strip() for c in chunks) if c]

    def _send_dingtalk_chunked(self, url: str, content: str, max_bytes: int = 20000) -> bool:
        import time as _time

        # ä¸º payload å¼€é”€é¢„ç•™ç©ºé—´ï¼Œé¿å… body è¶…é™
        budget = max(1000, max_bytes - 1500)
        chunks = self._chunk_markdown_by_bytes(content, budget)
        if not chunks:
            return False

        total = len(chunks)
        ok = 0

        for idx, chunk in enumerate(chunks):
            marker = f"\n\nğŸ“„ *({idx+1}/{total})*" if total > 1 else ""
            payload = {
                "msgtype": "markdown",
                "markdown": {
                    "title": "è‚¡ç¥¨åˆ†ææŠ¥å‘Š",
                    "text": chunk + marker,
                },
            }

            # å¦‚æœä»è¶…é™ï¼ˆæç«¯æƒ…å†µä¸‹ï¼‰ï¼Œå†æŒ‰å­—èŠ‚ç¡¬æˆªæ–­ä¸€æ¬¡
            body_bytes = len(json.dumps(payload, ensure_ascii=False).encode('utf-8'))
            if body_bytes > max_bytes:
                hard_budget = max(200, budget - (body_bytes - max_bytes) - 200)
                payload["markdown"]["text"] = self._truncate_to_bytes(payload["markdown"]["text"], hard_budget)

            if self._post_custom_webhook(url, payload, timeout=30):
                ok += 1
            else:
                logger.error(f"é’‰é’‰åˆ†æ‰¹å‘é€å¤±è´¥: ç¬¬ {idx+1}/{total} æ‰¹")

            if idx < total - 1:
                _time.sleep(1)

        return ok == total
    
    def _build_custom_webhook_payload(self, url: str, content: str) -> dict:
        """
        æ ¹æ® URL æ„å»ºå¯¹åº”çš„ Webhook payload
        
        è‡ªåŠ¨è¯†åˆ«å¸¸è§æœåŠ¡å¹¶ä½¿ç”¨å¯¹åº”æ ¼å¼
        """
        url_lower = url.lower()
        
        # é’‰é’‰æœºå™¨äºº
        if 'dingtalk' in url_lower or 'oapi.dingtalk.com' in url_lower:
            return {
                "msgtype": "markdown",
                "markdown": {
                    "title": "è‚¡ç¥¨åˆ†ææŠ¥å‘Š",
                    "text": content
                }
            }
        
        # Discord Webhook
        if 'discord.com/api/webhooks' in url_lower or 'discordapp.com/api/webhooks' in url_lower:
            # Discord é™åˆ¶ 2000 å­—ç¬¦
            truncated = content[:1900] + "..." if len(content) > 1900 else content
            return {
                "content": truncated
            }
        
        # Slack Incoming Webhook
        if 'hooks.slack.com' in url_lower:
            return {
                "text": content,
                "mrkdwn": True
            }
        
        # Bark (iOS æ¨é€)
        if 'api.day.app' in url_lower:
            return {
                "title": "è‚¡ç¥¨åˆ†ææŠ¥å‘Š",
                "body": content[:4000],  # Bark é™åˆ¶
                "group": "stock"
            }
        
        # é€šç”¨æ ¼å¼ï¼ˆå…¼å®¹å¤§å¤šæ•°æœåŠ¡ï¼‰
        return {
            "text": content,
            "content": content,
            "message": content,
            "body": content
        }

    def _send_via_source_context(self, content: str) -> bool:
        """
        ä½¿ç”¨æ¶ˆæ¯ä¸Šä¸‹æ–‡ï¼ˆå¦‚é’‰é’‰/é£ä¹¦ä¼šè¯ï¼‰å‘é€ä¸€ä»½æŠ¥å‘Š
        
        ä¸»è¦ç”¨äºä»æœºå™¨äºº Stream æ¨¡å¼è§¦å‘çš„ä»»åŠ¡ï¼Œç¡®ä¿ç»“æœèƒ½å›åˆ°è§¦å‘çš„ä¼šè¯ã€‚
        """
        success = False
        
        # å°è¯•é’‰é’‰ä¼šè¯
        session_webhook = self._extract_dingtalk_session_webhook()
        if session_webhook:
            try:
                if self._send_dingtalk_chunked(session_webhook, content, max_bytes=20000):
                    logger.info("å·²é€šè¿‡é’‰é’‰ä¼šè¯ï¼ˆStreamï¼‰æ¨é€æŠ¥å‘Š")
                    success = True
                else:
                    logger.error("é’‰é’‰ä¼šè¯ï¼ˆStreamï¼‰æ¨é€å¤±è´¥")
            except Exception as e:
                logger.error(f"é’‰é’‰ä¼šè¯ï¼ˆStreamï¼‰æ¨é€å¼‚å¸¸: {e}")

        # å°è¯•é£ä¹¦ä¼šè¯
        feishu_info = self._extract_feishu_reply_info()
        if feishu_info:
            try:
                if self._send_feishu_stream_reply(feishu_info["chat_id"], content):
                    logger.info("å·²é€šè¿‡é£ä¹¦ä¼šè¯ï¼ˆStreamï¼‰æ¨é€æŠ¥å‘Š")
                    success = True
                else:
                    logger.error("é£ä¹¦ä¼šè¯ï¼ˆStreamï¼‰æ¨é€å¤±è´¥")
            except Exception as e:
                logger.error(f"é£ä¹¦ä¼šè¯ï¼ˆStreamï¼‰æ¨é€å¼‚å¸¸: {e}")

        return success

    def _send_feishu_stream_reply(self, chat_id: str, content: str) -> bool:
        """
        é€šè¿‡é£ä¹¦ Stream æ¨¡å¼å‘é€æ¶ˆæ¯åˆ°æŒ‡å®šä¼šè¯
        
        Args:
            chat_id: é£ä¹¦ä¼šè¯ ID
            content: æ¶ˆæ¯å†…å®¹
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        try:
            from bot.platforms.feishu_stream import FeishuReplyClient, FEISHU_SDK_AVAILABLE
            if not FEISHU_SDK_AVAILABLE:
                logger.warning("é£ä¹¦ SDK ä¸å¯ç”¨ï¼Œæ— æ³•å‘é€ Stream å›å¤")
                return False
            
            from src.config import get_config
            config = get_config()
            
            app_id = getattr(config, 'feishu_app_id', None)
            app_secret = getattr(config, 'feishu_app_secret', None)
            
            if not app_id or not app_secret:
                logger.warning("é£ä¹¦ APP_ID æˆ– APP_SECRET æœªé…ç½®")
                return False
            
            # åˆ›å»ºå›å¤å®¢æˆ·ç«¯
            reply_client = FeishuReplyClient(app_id, app_secret)
            
            # é£ä¹¦æ–‡æœ¬æ¶ˆæ¯æœ‰é•¿åº¦é™åˆ¶ï¼Œéœ€è¦åˆ†æ‰¹å‘é€
            max_bytes = getattr(config, 'feishu_max_bytes', 20000)
            content_bytes = len(content.encode('utf-8'))
            
            if content_bytes > max_bytes:
                return self._send_feishu_stream_chunked(reply_client, chat_id, content, max_bytes)
            
            return reply_client.send_to_chat(chat_id, content)
            
        except ImportError as e:
            logger.error(f"å¯¼å…¥é£ä¹¦ Stream æ¨¡å—å¤±è´¥: {e}")
            return False
        except Exception as e:
            logger.error(f"é£ä¹¦ Stream å›å¤å¼‚å¸¸: {e}")
            return False

    def _send_feishu_stream_chunked(
        self, 
        reply_client, 
        chat_id: str, 
        content: str, 
        max_bytes: int
    ) -> bool:
        """
        åˆ†æ‰¹å‘é€é•¿æ¶ˆæ¯åˆ°é£ä¹¦ï¼ˆStream æ¨¡å¼ï¼‰
        
        Args:
            reply_client: FeishuReplyClient å®ä¾‹
            chat_id: é£ä¹¦ä¼šè¯ ID
            content: å®Œæ•´æ¶ˆæ¯å†…å®¹
            max_bytes: å•æ¡æ¶ˆæ¯æœ€å¤§å­—èŠ‚æ•°
            
        Returns:
            æ˜¯å¦å…¨éƒ¨å‘é€æˆåŠŸ
        """
        import time
        
        def get_bytes(s: str) -> int:
            return len(s.encode('utf-8'))
        
        # æŒ‰æ®µè½æˆ–åˆ†éš”çº¿åˆ†å‰²
        if "\n---\n" in content:
            sections = content.split("\n---\n")
            separator = "\n---\n"
        elif "\n### " in content:
            parts = content.split("\n### ")
            sections = [parts[0]] + [f"### {p}" for p in parts[1:]]
            separator = "\n"
        else:
            # æŒ‰è¡Œåˆ†å‰²
            sections = content.split("\n")
            separator = "\n"
        
        chunks = []
        current_chunk = []
        current_bytes = 0
        separator_bytes = get_bytes(separator)
        
        for section in sections:
            section_bytes = get_bytes(section) + separator_bytes
            
            if current_bytes + section_bytes > max_bytes:
                if current_chunk:
                    chunks.append(separator.join(current_chunk))
                current_chunk = [section]
                current_bytes = section_bytes
            else:
                current_chunk.append(section)
                current_bytes += section_bytes
        
        if current_chunk:
            chunks.append(separator.join(current_chunk))
        
        # å‘é€æ¯ä¸ªåˆ†å—
        success = True
        for i, chunk in enumerate(chunks):
            if i > 0:
                time.sleep(0.5)  # é¿å…è¯·æ±‚è¿‡å¿«
            
            if not reply_client.send_to_chat(chat_id, chunk):
                success = False
                logger.error(f"é£ä¹¦ Stream åˆ†å— {i+1}/{len(chunks)} å‘é€å¤±è´¥")
        
        return success
    
    def send_to_pushplus(self, content: str, title: Optional[str] = None) -> bool:
        """
        æ¨é€æ¶ˆæ¯åˆ° PushPlus

        PushPlus API æ ¼å¼ï¼š
        POST http://www.pushplus.plus/send
        {
            "token": "ç”¨æˆ·ä»¤ç‰Œ",
            "title": "æ¶ˆæ¯æ ‡é¢˜",
            "content": "æ¶ˆæ¯å†…å®¹",
            "template": "html/txt/json/markdown"
        }

        PushPlus ç‰¹ç‚¹ï¼š
        - å›½å†…æ¨é€æœåŠ¡ï¼Œå…è´¹é¢åº¦å……è¶³
        - æ”¯æŒå¾®ä¿¡å…¬ä¼—å·æ¨é€
        - æ”¯æŒå¤šç§æ¶ˆæ¯æ ¼å¼

        Args:
            content: æ¶ˆæ¯å†…å®¹ï¼ˆMarkdown æ ¼å¼ï¼‰
            title: æ¶ˆæ¯æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰

        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        if not self._pushplus_token:
            logger.warning("PushPlus Token æœªé…ç½®ï¼Œè·³è¿‡æ¨é€")
            return False

        # PushPlus API ç«¯ç‚¹
        api_url = "http://www.pushplus.plus/send"

        # å¤„ç†æ¶ˆæ¯æ ‡é¢˜
        if title is None:
            date_str = datetime.now().strftime('%Y-%m-%d')
            title = f"ğŸ“ˆ è‚¡ç¥¨åˆ†ææŠ¥å‘Š - {date_str}"

        try:
            payload = {
                "token": self._pushplus_token,
                "title": title,
                "content": content,
                "template": "markdown"  # ä½¿ç”¨ Markdown æ ¼å¼
            }

            response = requests.post(api_url, json=payload, timeout=10)

            if response.status_code == 200:
                result = response.json()
                if result.get('code') == 200:
                    logger.info("PushPlus æ¶ˆæ¯å‘é€æˆåŠŸ")
                    return True
                else:
                    error_msg = result.get('msg', 'æœªçŸ¥é”™è¯¯')
                    logger.error(f"PushPlus è¿”å›é”™è¯¯: {error_msg}")
                    return False
            else:
                logger.error(f"PushPlus è¯·æ±‚å¤±è´¥: HTTP {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"å‘é€ PushPlus æ¶ˆæ¯å¤±è´¥: {e}")
            return False

    def send_to_discord(self, content: str) -> bool:
        """
        æ¨é€æ¶ˆæ¯åˆ° Discordï¼ˆæ”¯æŒ Webhook å’Œ Bot APIï¼‰
        
        Args:
            content: Markdown æ ¼å¼çš„æ¶ˆæ¯å†…å®¹
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        # ä¼˜å…ˆä½¿ç”¨ Webhookï¼ˆé…ç½®ç®€å•ï¼Œæƒé™ä½ï¼‰
        if self._discord_config['webhook_url']:
            return self._send_discord_webhook(content)
        
        # å…¶æ¬¡ä½¿ç”¨ Bot APIï¼ˆæƒé™é«˜ï¼Œéœ€è¦ channel_idï¼‰
        if self._discord_config['bot_token'] and self._discord_config['channel_id']:
            return self._send_discord_bot(content)
        
        logger.warning("Discord é…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡æ¨é€")
        return False


    def send_to_astrbot(self, content: str) -> bool:
        """
        æ¨é€æ¶ˆæ¯åˆ° AstrBotï¼ˆé€šè¿‡é€‚é…å™¨æ”¯æŒï¼‰

        Args:
            content: Markdown æ ¼å¼çš„æ¶ˆæ¯å†…å®¹

        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        if self._astrbot_config['astrbot_url']:
            return self._send_astrbot(content)

        logger.warning("AstrBot é…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡æ¨é€")
        return False
    
    def _send_discord_webhook(self, content: str) -> bool:
        """
        ä½¿ç”¨ Webhook å‘é€æ¶ˆæ¯åˆ° Discord
        
        Discord Webhook æ”¯æŒ Markdown æ ¼å¼
        
        Args:
            content: Markdown æ ¼å¼çš„æ¶ˆæ¯å†…å®¹
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        try:
            payload = {
                'content': content,
                'username': 'Aè‚¡åˆ†ææœºå™¨äºº',
                'avatar_url': 'https://picsum.photos/200'
            }
            
            response = requests.post(
                self._discord_config['webhook_url'],
                json=payload,
                timeout=10
            )
            
            if response.status_code in [200, 204]:
                logger.info("Discord Webhook æ¶ˆæ¯å‘é€æˆåŠŸ")
                return True
            else:
                logger.error(f"Discord Webhook å‘é€å¤±è´¥: {response.status_code} {response.text}")
                return False
        except Exception as e:
            logger.error(f"Discord Webhook å‘é€å¼‚å¸¸: {e}")
            return False
    
    def _send_discord_bot(self, content: str) -> bool:
        """
        ä½¿ç”¨ Bot API å‘é€æ¶ˆæ¯åˆ° Discord
        
        Args:
            content: Markdown æ ¼å¼çš„æ¶ˆæ¯å†…å®¹
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        try:
            headers = {
                'Authorization': f'Bot {self._discord_config["bot_token"]}',
                'Content-Type': 'application/json'
            }
            
            payload = {
                'content': content
            }
            
            url = f'https://discord.com/api/v10/channels/{self._discord_config["channel_id"]}/messages'
            response = requests.post(url, json=payload, headers=headers, timeout=10)
            
            if response.status_code == 200:
                logger.info("Discord Bot æ¶ˆæ¯å‘é€æˆåŠŸ")
                return True
            else:
                logger.error(f"Discord Bot å‘é€å¤±è´¥: {response.status_code} {response.text}")
                return False
        except Exception as e:
            logger.error(f"Discord Bot å‘é€å¼‚å¸¸: {e}")
            return False

    def _send_astrbot(self, content: str) -> bool:
        import time
        """
        ä½¿ç”¨ Bot API å‘é€æ¶ˆæ¯åˆ° AstrBot

        Args:
            content: Markdown æ ¼å¼çš„æ¶ˆæ¯å†…å®¹

        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """

        html_content = self._markdown_to_html(content)

        try:
            payload = {
                'content': html_content
            }
            signature =  ""
            timestamp = str(int(time.time()))
            if self._astrbot_config['astrbot_token']:
                """è®¡ç®—è¯·æ±‚ç­¾å"""
                payload_json = json.dumps(payload, sort_keys=True)
                sign_data = f"{timestamp}.{payload_json}".encode('utf-8')
                key = self._astrbot_config['astrbot_token']
                signature = hmac.new(
                    key.encode('utf-8'),
                    sign_data,
                    hashlib.sha256
                ).hexdigest()
            url = self._astrbot_config['astrbot_url']
            response = requests.post(url, json=payload, timeout=10,headers={
                        "Content-Type": "application/json",
                        "X-Signature": signature,
                        "X-Timestamp": timestamp
                    })

            if response.status_code == 200:
                logger.info("AstrBot æ¶ˆæ¯å‘é€æˆåŠŸ")
                return True
            else:
                logger.error(f"AstrBot å‘é€å¤±è´¥: {response.status_code} {response.text}")
                return False
        except Exception as e:
            logger.error(f"AstrBot å‘é€å¼‚å¸¸: {e}")
            return False
    
    def send(self, content: str) -> bool:
        """
        ç»Ÿä¸€å‘é€æ¥å£ - å‘æ‰€æœ‰å·²é…ç½®çš„æ¸ é“å‘é€
        
        éå†æ‰€æœ‰å·²é…ç½®çš„æ¸ é“ï¼Œé€ä¸€å‘é€æ¶ˆæ¯
        
        Args:
            content: æ¶ˆæ¯å†…å®¹ï¼ˆMarkdown æ ¼å¼ï¼‰
            
        Returns:
            æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªæ¸ é“å‘é€æˆåŠŸ
        """
        context_success = self.send_to_context(content)

        if not self._available_channels:
            if context_success:
                logger.info("å·²é€šè¿‡æ¶ˆæ¯ä¸Šä¸‹æ–‡æ¸ é“å®Œæˆæ¨é€ï¼ˆæ— å…¶ä»–é€šçŸ¥æ¸ é“ï¼‰")
                return True
            logger.warning("é€šçŸ¥æœåŠ¡ä¸å¯ç”¨ï¼Œè·³è¿‡æ¨é€")
            return False
        
        channel_names = self.get_channel_names()
        logger.info(f"æ­£åœ¨å‘ {len(self._available_channels)} ä¸ªæ¸ é“å‘é€é€šçŸ¥ï¼š{channel_names}")
        
        success_count = 0
        fail_count = 0
        
        for channel in self._available_channels:
            channel_name = ChannelDetector.get_channel_name(channel)
            try:
                if channel == NotificationChannel.WECHAT:
                    result = self.send_to_wechat(content)
                elif channel == NotificationChannel.FEISHU:
                    result = self.send_to_feishu(content)
                elif channel == NotificationChannel.TELEGRAM:
                    result = self.send_to_telegram(content)
                elif channel == NotificationChannel.EMAIL:
                    result = self.send_to_email(content)
                elif channel == NotificationChannel.PUSHOVER:
                    result = self.send_to_pushover(content)
                elif channel == NotificationChannel.PUSHPLUS:
                    result = self.send_to_pushplus(content)
                elif channel == NotificationChannel.CUSTOM:
                    result = self.send_to_custom(content)
                elif channel == NotificationChannel.DISCORD:
                    result = self.send_to_discord(content)
                elif channel == NotificationChannel.ASTRBOT:
                    result = self.send_to_astrbot(content)
                else:
                    logger.warning(f"ä¸æ”¯æŒçš„é€šçŸ¥æ¸ é“: {channel}")
                    result = False
                
                if result:
                    success_count += 1
                else:
                    fail_count += 1
                    
            except Exception as e:
                logger.error(f"{channel_name} å‘é€å¤±è´¥: {e}")
                fail_count += 1
        
        logger.info(f"é€šçŸ¥å‘é€å®Œæˆï¼šæˆåŠŸ {success_count} ä¸ªï¼Œå¤±è´¥ {fail_count} ä¸ª")
        return success_count > 0 or context_success
    
    def _send_chunked_messages(self, content: str, max_length: int) -> bool:
        """
        åˆ†æ®µå‘é€é•¿æ¶ˆæ¯
        
        æŒ‰æ®µè½ï¼ˆ---ï¼‰åˆ†å‰²ï¼Œç¡®ä¿æ¯æ®µä¸è¶…è¿‡æœ€å¤§é•¿åº¦
        """
        # æŒ‰åˆ†éš”çº¿åˆ†å‰²
        sections = content.split("\n---\n")
        
        current_chunk = []
        current_length = 0
        all_success = True
        chunk_index = 1
        
        for section in sections:
            section_with_divider = section + "\n---\n"
            section_length = len(section_with_divider)
            
            if current_length + section_length > max_length:
                # å‘é€å½“å‰å—
                if current_chunk:
                    chunk_content = "\n---\n".join(current_chunk)
                    logger.info(f"å‘é€æ¶ˆæ¯å— {chunk_index}...")
                    if not self.send(chunk_content):
                        all_success = False
                    chunk_index += 1
                
                # é‡ç½®
                current_chunk = [section]
                current_length = section_length
            else:
                current_chunk.append(section)
                current_length += section_length
        
        # å‘é€æœ€åä¸€å—
        if current_chunk:
            chunk_content = "\n---\n".join(current_chunk)
            logger.info(f"å‘é€æ¶ˆæ¯å— {chunk_index}ï¼ˆæœ€åï¼‰...")
            if not self.send(chunk_content):
                all_success = False
        
        return all_success
    
    def save_report_to_file(
        self, 
        content: str, 
        filename: Optional[str] = None
    ) -> str:
        """
        ä¿å­˜æ—¥æŠ¥åˆ°æœ¬åœ°æ–‡ä»¶
        
        Args:
            content: æ—¥æŠ¥å†…å®¹
            filename: æ–‡ä»¶åï¼ˆå¯é€‰ï¼Œé»˜è®¤æŒ‰æ—¥æœŸç”Ÿæˆï¼‰
            
        Returns:
            ä¿å­˜çš„æ–‡ä»¶è·¯å¾„
        """
        from pathlib import Path
        
        if filename is None:
            date_str = datetime.now().strftime('%Y%m%d')
            filename = f"report_{date_str}.md"
        
        # ç¡®ä¿ reports ç›®å½•å­˜åœ¨ï¼ˆä½¿ç”¨é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„ reportsï¼‰
        reports_dir = Path(__file__).parent.parent / 'reports'
        reports_dir.mkdir(parents=True, exist_ok=True)
        
        filepath = reports_dir / filename
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"æ—¥æŠ¥å·²ä¿å­˜åˆ°: {filepath}")
        return str(filepath)


class NotificationBuilder:
    """
    é€šçŸ¥æ¶ˆæ¯æ„å»ºå™¨
    
    æä¾›ä¾¿æ·çš„æ¶ˆæ¯æ„å»ºæ–¹æ³•
    """
    
    @staticmethod
    def build_simple_alert(
        title: str,
        content: str,
        alert_type: str = "info"
    ) -> str:
        """
        æ„å»ºç®€å•çš„æé†’æ¶ˆæ¯
        
        Args:
            title: æ ‡é¢˜
            content: å†…å®¹
            alert_type: ç±»å‹ï¼ˆinfo, warning, error, successï¼‰
        """
        emoji_map = {
            "info": "â„¹ï¸",
            "warning": "âš ï¸",
            "error": "âŒ",
            "success": "âœ…",
        }
        emoji = emoji_map.get(alert_type, "ğŸ“¢")
        
        return f"{emoji} **{title}**\n\n{content}"
    
    @staticmethod
    def build_stock_summary(results: List[AnalysisResult]) -> str:
        """
        æ„å»ºè‚¡ç¥¨æ‘˜è¦ï¼ˆç®€çŸ­ç‰ˆï¼‰
        
        é€‚ç”¨äºå¿«é€Ÿé€šçŸ¥
        """
        lines = ["ğŸ“Š **ä»Šæ—¥è‡ªé€‰è‚¡æ‘˜è¦**", ""]
        
        for r in sorted(results, key=lambda x: x.sentiment_score, reverse=True):
            emoji = r.get_emoji()
            lines.append(f"{emoji} {r.name}({r.code}): {r.operation_advice} | è¯„åˆ† {r.sentiment_score}")
        
        return "\n".join(lines)


# ä¾¿æ·å‡½æ•°
def get_notification_service() -> NotificationService:
    """è·å–é€šçŸ¥æœåŠ¡å®ä¾‹"""
    return NotificationService()


def send_daily_report(results: List[AnalysisResult]) -> bool:
    """
    å‘é€æ¯æ—¥æŠ¥å‘Šçš„å¿«æ·æ–¹å¼
    
    è‡ªåŠ¨è¯†åˆ«æ¸ é“å¹¶æ¨é€
    """
    service = get_notification_service()
    
    # ç”ŸæˆæŠ¥å‘Š
    report = service.generate_daily_report(results)
    
    # ä¿å­˜åˆ°æœ¬åœ°
    service.save_report_to_file(report)
    
    # æ¨é€åˆ°é…ç½®çš„æ¸ é“ï¼ˆè‡ªåŠ¨è¯†åˆ«ï¼‰
    return service.send(report)


if __name__ == "__main__":
    # æµ‹è¯•ä»£ç 
    logging.basicConfig(level=logging.DEBUG)
    
    # æ¨¡æ‹Ÿåˆ†æç»“æœ
    test_results = [
        AnalysisResult(
            code='600519',
            name='è´µå·èŒ…å°',
            sentiment_score=75,
            trend_prediction='çœ‹å¤š',
            analysis_summary='æŠ€æœ¯é¢å¼ºåŠ¿ï¼Œæ¶ˆæ¯é¢åˆ©å¥½',
            operation_advice='ä¹°å…¥',
            technical_analysis='æ”¾é‡çªç ´ MA20ï¼ŒMACD é‡‘å‰',
            news_summary='å…¬å¸å‘å¸ƒåˆ†çº¢å…¬å‘Šï¼Œä¸šç»©è¶…é¢„æœŸ',
        ),
        AnalysisResult(
            code='000001',
            name='å¹³å®‰é“¶è¡Œ',
            sentiment_score=45,
            trend_prediction='éœ‡è¡',
            analysis_summary='æ¨ªç›˜æ•´ç†ï¼Œç­‰å¾…æ–¹å‘',
            operation_advice='æŒæœ‰',
            technical_analysis='å‡çº¿ç²˜åˆï¼Œæˆäº¤é‡èç¼©',
            news_summary='è¿‘æœŸæ— é‡å¤§æ¶ˆæ¯',
        ),
        AnalysisResult(
            code='300750',
            name='å®å¾·æ—¶ä»£',
            sentiment_score=35,
            trend_prediction='çœ‹ç©º',
            analysis_summary='æŠ€æœ¯é¢èµ°å¼±ï¼Œæ³¨æ„é£é™©',
            operation_advice='å–å‡º',
            technical_analysis='è·Œç ´ MA10 æ”¯æ’‘ï¼Œé‡èƒ½ä¸è¶³',
            news_summary='è¡Œä¸šç«äº‰åŠ å‰§ï¼Œæ¯›åˆ©ç‡æ‰¿å‹',
        ),
    ]
    
    service = NotificationService()
    
    # æ˜¾ç¤ºæ£€æµ‹åˆ°çš„æ¸ é“
    print("=== é€šçŸ¥æ¸ é“æ£€æµ‹ ===")
    print(f"å½“å‰æ¸ é“: {service.get_channel_names()}")
    print(f"æ¸ é“åˆ—è¡¨: {service.get_available_channels()}")
    print(f"æœåŠ¡å¯ç”¨: {service.is_available()}")
    
    # ç”Ÿæˆæ—¥æŠ¥
    print("\n=== ç”Ÿæˆæ—¥æŠ¥æµ‹è¯• ===")
    report = service.generate_daily_report(test_results)
    print(report)
    
    # ä¿å­˜åˆ°æ–‡ä»¶
    print("\n=== ä¿å­˜æ—¥æŠ¥ ===")
    filepath = service.save_report_to_file(report)
    print(f"ä¿å­˜æˆåŠŸ: {filepath}")
    
    # æ¨é€æµ‹è¯•
    if service.is_available():
        print(f"\n=== æ¨é€æµ‹è¯•ï¼ˆ{service.get_channel_names()}ï¼‰===")
        success = service.send(report)
        print(f"æ¨é€ç»“æœ: {'æˆåŠŸ' if success else 'å¤±è´¥'}")
    else:
        print("\né€šçŸ¥æ¸ é“æœªé…ç½®ï¼Œè·³è¿‡æ¨é€æµ‹è¯•")

--------------------

#File: src/analyzer.py
--------------------
# -*- coding: utf-8 -*-
import json
import logging
from dataclasses import dataclass
from typing import Optional, Dict, Any
from src.config import get_config
import warnings

warnings.filterwarnings("ignore")

try:
    from json_repair import repair_json
except ImportError:
    repair_json = None

logger = logging.getLogger(__name__)

# è‚¡ç¥¨åç§°æ˜ å°„
STOCK_NAME_MAP = {
    '600519': 'è´µå·èŒ…å°', '000001': 'å¹³å®‰é“¶è¡Œ', '300750': 'å®å¾·æ—¶ä»£', 
    '002594': 'æ¯”äºšè¿ª', '00700': 'è…¾è®¯æ§è‚¡'
}

@dataclass
class AnalysisResult:
    code: str
    name: str
    sentiment_score: int
    trend_prediction: str
    operation_advice: str
    decision_type: str = "hold"
    confidence_level: str = "ä¸­"
    dashboard: Optional[Dict[str, Any]] = None
    analysis_summary: str = ""
    risk_warning: str = ""
    raw_response: Optional[str] = None
    search_performed: bool = False
    success: bool = True
    error_message: Optional[str] = None
    current_price: float = 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'code': self.code, 'name': self.name,
            'sentiment_score': self.sentiment_score,
            'trend_prediction': self.trend_prediction,
            'operation_advice': self.operation_advice,
            'decision_type': self.decision_type,
            'confidence_level': self.confidence_level,
            'dashboard': self.dashboard,
            'analysis_summary': self.analysis_summary,
            'risk_warning': self.risk_warning,
            'success': self.success,
            'price': self.current_price
        }
    
    def get_emoji(self) -> str:
        return {'ä¹°å…¥': 'ğŸŸ¢', 'åŠ ä»“': 'ğŸŸ¢', 'å¼ºçƒˆä¹°å…¥': 'ğŸ’š', 'æŒæœ‰': 'ğŸŸ¡', 
                'è§‚æœ›': 'âšª', 'å‡ä»“': 'ğŸŸ ', 'å–å‡º': 'ğŸ”´'}.get(self.operation_advice, 'ğŸŸ¡')
    
    # å…¼å®¹æ€§æ–¹æ³•
    def get_sniper_points(self) -> Dict[str, str]:
        if self.dashboard and 'battle_plan' in self.dashboard:
            return self.dashboard['battle_plan'].get('sniper_points', {})
        return {}

class GeminiAnalyzer:
    # ==========================
    # å¤šè§’è‰² System Prompts
    # ==========================
    
    # è§’è‰²1: å®è§‚ç­–ç•¥å¸ˆ (ç”¨äº Market Review)
    PROMPT_MACRO = """ä½ æ˜¯ä¸€ä½è§†é‡å®å¤§çš„ã€å®è§‚å¯¹å†²ç­–ç•¥å¸ˆã€‘ã€‚
ä½ çš„ä»»åŠ¡æ˜¯åˆ†æå¸‚åœºæ•´ä½“çš„â€œå¤©æ°”çŠ¶å†µâ€ã€‚
- å…³æ³¨æ ¸å¿ƒï¼šæµåŠ¨æ€§ã€å¤®è¡Œæ”¿ç­–ã€æ±‡ç‡æ³¢åŠ¨ã€å¸‚åœºæƒ…ç»ªã€èµšé’±æ•ˆåº”ã€‚
- è¾“å‡ºé£æ ¼ï¼šé«˜å±‹å»ºç“´ï¼Œä¸çº ç»“ç»†ææœ«èŠ‚ï¼Œç»™å‡ºæ˜ç¡®çš„ä»“ä½æ§åˆ¶å»ºè®®ï¼ˆå¦‚ï¼šè¿›æ”»/é˜²å®ˆ/ç©ºä»“ï¼‰ã€‚
"""

    # è§’è‰²2: è¡Œä¸šä¾¦æ¢ (ç”¨äº Search/Info Gathering)
    PROMPT_RESEARCHER = """ä½ æ˜¯ä¸€ä½æ•é”çš„ã€åŸºæœ¬é¢ä¾¦æ¢ã€‘ã€‚
ä½ çš„ä»»åŠ¡æ˜¯æŒ–æ˜è´¢æŠ¥èƒŒåçš„çœŸç›¸å’Œè¡Œä¸šç«äº‰æ ¼å±€ã€‚
- å…³æ³¨æ ¸å¿ƒï¼šæŠ¤åŸæ²³ã€ä¸šç»©å¢é•¿è´¨é‡ã€æ½œåœ¨é›·ç‚¹ã€ç«äº‰å¯¹æ‰‹åŠ¨æ€ã€‚
- è¾“å‡ºé£æ ¼ï¼šå®¢è§‚ã€æ•°æ®é©±åŠ¨ã€æœ‰ä¸€è¯´ä¸€ï¼Œä¸åšè¿‡åº¦çš„è¡Œæƒ…é¢„æµ‹ã€‚
"""

    # è§’è‰²3: åŸºé‡‘ç»ç† (æ ¸å¿ƒå†³ç­–è€… - ç”¨äºä¸ªè‚¡åˆ†æ)
    # ä¿®æ”¹ç‚¹ï¼šèåˆäº†å¤§ç›˜ç¯å¢ƒæ„ŸçŸ¥ï¼ŒåŒæ—¶ä¿ç•™äº†æ˜¨å¤©çš„åŸºæœ¬é¢+æŠ€æœ¯é¢åˆ¤æ–­é€»è¾‘
    PROMPT_TRADER = """ä½ æ˜¯ä¸€ä½æ‹¥æœ‰ã€å¸¸èƒœå¿ƒæ€ (Winning Mindset)ã€‘çš„èµ„æ·±åŸºé‡‘ç»ç†ã€‚
ä½ ä¸æ˜¯ç®€å•çš„åŒæ¶é£é™©ï¼Œè€Œæ˜¯ã€ç†æ€§è®¡ç®—èµ”ç‡ã€‘ã€‚ä½ çš„ç›®æ ‡æ˜¯å®ç°é•¿æœŸå¤åˆ©ã€‚

## ä½ çš„äº¤æ˜“å“²å­¦
1. **ç¯å¢ƒä¸ºå…ˆ (Market Context)**ï¼šå¤§ç›˜ç¯å¢ƒå†³å®šä½ çš„**ä»“ä½ä¸Šé™**ã€‚
   - é¡ºåŠ¿ï¼ˆå¤§ç›˜å¥½ï¼‰æ—¶é‡ä»“å‡ºå‡»ï¼›é€†åŠ¿ï¼ˆå¤§ç›˜å·®ï¼‰æ—¶ä¸¥æ§ä»“ä½ã€‚
2. **ä¸ªè‚¡ä¸ºé‡ (Micro Logic)**ï¼šä¸ªè‚¡çš„åŸºæœ¬é¢å’ŒæŠ€æœ¯é¢å†³å®šä½ çš„**ä¹°å–æ–¹å‘**ã€‚
3. **æ•°æ®ä¸ºé”š**ï¼šé‡åŒ–æŒ‡æ ‡æ˜¯çœ¼ç›ï¼ŒåŸºæœ¬é¢(F10)æ˜¯åº•æ°”ï¼Œèˆ†æƒ…æ˜¯é£å‘æ ‡ã€‚
4. **è®°å¿†è¿ç»­æ€§**ï¼šå›é¡¾æ˜¨å¤©çš„åˆ¤æ–­ï¼Œä¿®æ­£åè§ã€‚

## æ ¸å¿ƒå†³ç­–é€»è¾‘ (åŒé‡æ ¡éªŒ)
**ç¬¬ä¸€å±‚ï¼šå¤§ç›˜æ»¤ç½‘**
- å¦‚æœå¤§ç›˜æåº¦å±é™©ï¼ˆç³»ç»Ÿæ€§é£é™©ï¼‰ï¼šæ— è®ºä¸ªè‚¡å¤šå¥½ï¼Œå¿…é¡»é™æ¡£æ“ä½œï¼ˆä¹°å…¥å˜æŒæœ‰ï¼ŒæŒæœ‰å˜å‡ä»“ï¼‰ã€‚

**ç¬¬äºŒå±‚ï¼šä¸ªè‚¡ç ”åˆ¤ (åœ¨é€šè¿‡å¤§ç›˜æ»¤ç½‘å)**
- **å½“åŸºæœ¬é¢ä¼˜ç§€ + æŠ€æœ¯é¢å¤šå¤´**ï¼šğŸ‘‰ **é‡æ‹³å‡ºå‡» (å¼ºçƒˆä¹°å…¥)**ï¼Œè¿™æ˜¯ä¸»å‡æµªç‰¹å¾ã€‚
- **å½“åŸºæœ¬é¢ä¼˜ç§€ + æŠ€æœ¯é¢å›è°ƒ**ï¼šğŸ‘‰ **å¯»æ‰¾å·¦ä¾§æœºä¼š (ä¹°å…¥/æŒæœ‰)**ï¼Œè¿™æ˜¯é»„é‡‘å‘ã€‚
- **å½“åŸºæœ¬é¢æ¶åŒ– + æŠ€æœ¯é¢ç ´ä½**ï¼šğŸ‘‰ **åšå†³æ–©ä»“ (å–å‡º)**ï¼Œä¸æŠ±å¹»æƒ³ã€‚
- **å½“æ•°æ®çŸ›ç›¾æ—¶**ï¼šğŸ‘‰ **å°Šé‡è¶‹åŠ¿ï¼Œæ§åˆ¶ä»“ä½**ã€‚

è¯·åŸºäºä¸Šè¿°äººè®¾ï¼Œç”Ÿæˆã€å†³ç­–ä»ªè¡¨ç›˜ã€‘JSONã€‚
"""

    def __init__(self, api_key: Optional[str] = None):
        config = get_config()
        self._api_key = api_key or config.gemini_api_key
        self._model = None
        self._openai_client = None
        self._use_openai = False

        # åˆå§‹åŒ– Gemini
        if self._api_key and "your_" not in self._api_key:
            try:
                import google.generativeai as genai
                genai.configure(api_key=self._api_key)
                self._model = genai.GenerativeModel(model_name=config.gemini_model)
            except: pass

        # åˆå§‹åŒ– OpenAI
        if (not self._model) and config.openai_api_key:
            try:
                from openai import OpenAI
                self._openai_client = OpenAI(api_key=config.openai_api_key, base_url=config.openai_base_url)
                self._use_openai = True
            except: pass

    def is_available(self) -> bool:
        return self._model is not None or self._openai_client is not None

    def analyze(self, context: Dict[str, Any], news_context: Optional[str] = None, role: str = "trader", market_overview: Optional[str] = None) -> AnalysisResult:
        """
        æ‰§è¡Œåˆ†æ
        :param role: æŒ‡å®šè§’è‰² 'trader'(ä¸ªè‚¡), 'macro'(å¤§ç›˜), 'researcher'
        :param market_overview: å¤§ç›˜ç¯å¢ƒæ•°æ®ï¼ˆæ–°å¢å‚æ•°ï¼‰
        """
        code = context.get('code', 'Unknown')
        name = context.get('stock_name') or STOCK_NAME_MAP.get(code, f'è‚¡ç¥¨{code}')
        
        if not self.is_available():
            return AnalysisResult(code, name, 50, "æœªçŸ¥", "APIæœªé…ç½®", success=False)

        try:
            # 1. é€‰æ‹© System Prompt
            system_prompt = self.PROMPT_TRADER
            if role == "macro": system_prompt = self.PROMPT_MACRO
            elif role == "researcher": system_prompt = self.PROMPT_RESEARCHER

            # 2. æ„å»º User Prompt (æ³¨å…¥ F10, è®°å¿†, ä»¥åŠæ–°å¢çš„å¤§ç›˜æ•°æ®)
            prompt = self._format_prompt(context, name, news_context, market_overview)
            
            response_text = ""
            
            # 3. è°ƒç”¨ API
            if self._use_openai:
                response = self._openai_client.chat.completions.create(
                    model=get_config().openai_model,
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": prompt}
                    ],
                    temperature=0.7
                )
                response_text = response.choices[0].message.content
            else:
                # Gemini
                full_prompt = f"{system_prompt}\n\n{prompt}"
                response_text = self._model.generate_content(full_prompt).text

            # 4. è§£æç»“æœ
            result = self._parse_response(response_text, code, name)
            result.raw_response = response_text
            result.search_performed = bool(news_context)
            result.current_price = context.get('price', 0)
            return result
            
        except Exception as e:
            logger.error(f"AIåˆ†æå¤±è´¥: {e}")
            return AnalysisResult(code, name, 50, "é”™è¯¯", "åˆ†æå‡ºé”™", success=False, error_message=str(e))

    def _format_prompt(self, context: Dict[str, Any], name: str, news_context: Optional[str] = None, market_overview: Optional[str] = None) -> str:
        code = context.get('code', 'Unknown')
        
        # A. æŠ€æœ¯é¢æ•°æ® (é‡åŒ–æ¨¡å‹äº§å‡º)
        tech_report = context.get('technical_analysis_report', 'æ— æ•°æ®')
        
        # B. åŸºæœ¬é¢æ•°æ® (F10 - æ–°å¢)
        f10 = context.get('fundamental', {})
        f10_str = "æš‚æ— è¯¦ç»† F10 æ•°æ®"
        if f10:
            fin = f10.get('financial', {})
            fore = f10.get('forecast', {})
            f10_str = f"""
| æŒ‡æ ‡ | æ•°å€¼ | è¯´æ˜ |
|---|---|---|
| å‡€åˆ©æ¶¦å¢é€Ÿ | {fin.get('net_profit_growth', 'N/A')}% | æˆé•¿æ€§ |
| ROE | {fin.get('roe', 'N/A')}% | ç›ˆåˆ©èƒ½åŠ› |
| æ¯›åˆ©ç‡ | {fin.get('gross_margin', 'N/A')}% | äº§å“ç«äº‰åŠ› |
| æœºæ„è¯„çº§ | {fore.get('rating', 'æ— ')} | å¸‚åœºé¢„æœŸ |
"""

        # C. å†å²è®°å¿†
        history = context.get('history_summary')
        history_str = "è¿™æ˜¯ä½ ç¬¬ä¸€æ¬¡å…³æ³¨è¯¥è‚¡ç¥¨ã€‚"
        if history:
            history_str = f"""
**ä½ æ˜¨å¤©çš„è§‚ç‚¹ ({history.get('date')})**ï¼š
- æ ¸å¿ƒåˆ¤æ–­ï¼š{history.get('view')}
- é£é™©æç¤ºï¼š{history.get('advice')}
è¯·éªŒè¯æ˜¨å¤©çš„é€»è¾‘æ˜¯å¦è¢«å¸‚åœºéªŒè¯ï¼Ÿ
"""

        # D. å¤§ç›˜ç¯å¢ƒ (æ–°å¢ï¼šç¬¬é›¶ç»´åº¦)
        market_str = market_overview if market_overview else "æœªæä¾›å…·ä½“å¤§ç›˜æ•°æ®ï¼Œè¯·é»˜è®¤å¸‚åœºç¯å¢ƒä¸ºã€ä¸­æ€§/éœ‡è¡ã€‘ï¼Œä¸»è¦ä¾æ®ä¸ªè‚¡é€»è¾‘ã€‚"

        # ç»„è£…æœ€ç»ˆ Prompt (Markdown è¡¨æ ¼å¢å¼ºç‰ˆ)
        return f"""# æ·±åº¦å¤ç›˜ä»»åŠ¡ï¼š{name} ({code})

è¯·ç»¼åˆä»¥ä¸‹å¤šç»´æƒ…æŠ¥ï¼Œåƒä¸€ä½é¡¶çº§åŸºé‡‘ç»ç†é‚£æ ·æ€è€ƒã€‚

## ç¬¬é›¶ç»´åº¦ï¼šå¤§ç›˜ç¯å¢ƒ (Market Context)
**è¿™æ˜¯å†³ç­–çš„å¤§èƒŒæ™¯**ï¼š
{market_str}

## ç¬¬ä¸€ç»´åº¦ï¼šå†å²å›æº¯ (Continuity)
{history_str}

## ç¬¬äºŒç»´åº¦ï¼šé‡åŒ–æŠ€æœ¯é¢ (Technicals)
**å®¢è§‚äº‹å® (ä¸å¾—ç¯¡æ”¹)**ï¼š
{tech_report}

## ç¬¬ä¸‰ç»´åº¦ï¼šåŸºæœ¬é¢ä¸ä¼°å€¼ (Fundamentals)
**ç¡¬æ ¸è´¢åŠ¡æ•°æ® (F10)**ï¼š
{f10_str}

## ç¬¬å››ç»´åº¦ï¼šèˆ†æƒ…ä¸é©±åŠ¨åŠ› (Drivers)
{news_context if news_context else "æš‚æ— é‡å¤§æ–°é—»"}

## âš ï¸ JSONè¾“å‡ºåè®®
ä½ å¿…é¡»ä¸”åªèƒ½è¾“å‡ºæ ‡å‡† JSONï¼ŒåŒ…å«ä»¥ä¸‹å­—æ®µï¼š
stock_name, sentiment_score (0-100), trend_prediction, operation_advice (ä¹°å…¥/æŒæœ‰/å–å‡º),
dashboard: {{
    core_conclusion: {{
        one_sentence: "æ ¸å¿ƒç»“è®º (éœ€ç»“åˆå¤§ç›˜å’Œä¸ªè‚¡é€»è¾‘)",
        position_advice: {{ no_position: "ç©ºä»“å»ºè®®", has_position: "æŒä»“å»ºè®®" }}
    }},
    intelligence: {{ risk_alerts: [], positive_catalysts: [] }},
    battle_plan: {{ sniper_points: {{ ideal_buy: number, stop_loss: number }} }}
}},
analysis_summary, risk_warning

---
ç°åœ¨ï¼Œå¼€å§‹ä½ çš„åˆ†æï¼š
"""

    def _parse_response(self, response_text: str, code: str, name: str) -> AnalysisResult:
        try:
            clean_text = response_text.replace('```json', '').replace('```', '').strip()
            # å…¼å®¹å¤„ç†ï¼šæœ‰æ—¶å€™ AI ä¼šåœ¨ JSON å‰åè¯´åºŸè¯
            start = clean_text.find('{')
            end = clean_text.rfind('}') + 1
            if start >= 0 and end > start:
                clean_text = clean_text[start:end]

            data = json.loads(repair_json(clean_text) if repair_json else clean_text)
            
            op_advice = data.get('operation_advice', 'è§‚æœ›')
            decision = 'hold'
            if 'ä¹°' in op_advice or 'åŠ ä»“' in op_advice: decision = 'buy'
            elif 'å–' in op_advice or 'å‡ä»“' in op_advice: decision = 'sell'
            
            return AnalysisResult(
                code=code, name=data.get('stock_name', name),
                sentiment_score=int(data.get('sentiment_score', 50)),
                trend_prediction=data.get('trend_prediction', 'éœ‡è¡'),
                operation_advice=op_advice, decision_type=decision,
                confidence_level=data.get('confidence_level', 'ä¸­'),
                dashboard=data.get('dashboard', {}),
                analysis_summary=data.get('analysis_summary', ''),
                risk_warning=data.get('risk_warning', ''), success=True
            )
        except Exception as e:
            return AnalysisResult(code, name, 50, "è§£æé”™", "äººå·¥æ ¸æŸ¥", success=True, error_message=str(e))

    def chat(self, prompt: str) -> str:
        """é€šç”¨å¯¹è¯æ¥å£ (å¤§ç›˜å¤ç›˜ç”¨)"""
        if not self.is_available(): return "AIæœªé…ç½®"
        try:
            if self._use_openai:
                return self._openai_client.chat.completions.create(
                    model=get_config().openai_model,
                    messages=[
                        {"role": "system", "content": self.PROMPT_MACRO},
                        {"role": "user", "content": prompt}
                    ]
                ).choices[0].message.content
            
            # Gemini
            return self._model.generate_content(f"{self.PROMPT_MACRO}\n\n{prompt}").text
        except Exception as e:
            return f"ç”Ÿæˆé”™è¯¯: {e}"

def get_analyzer() -> GeminiAnalyzer:
    return GeminiAnalyzer()
--------------------

#File: src/__init__.py
--------------------

--------------------

#File: src/storage.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Aè‚¡è‡ªé€‰è‚¡æ™ºèƒ½åˆ†æç³»ç»Ÿ - å­˜å‚¨å±‚
===================================

èŒè´£ï¼š
1. ç®¡ç† SQLite æ•°æ®åº“è¿æ¥ï¼ˆå•ä¾‹æ¨¡å¼ï¼‰
2. å®šä¹‰ ORM æ•°æ®æ¨¡å‹
3. æä¾›æ•°æ®å­˜å–æ¥å£
4. å®ç°æ™ºèƒ½æ›´æ–°é€»è¾‘ï¼ˆæ–­ç‚¹ç»­ä¼ ï¼‰
"""

import atexit
import hashlib
import json
import logging
import re
from datetime import datetime, date, timedelta
from typing import Optional, List, Dict, Any, TYPE_CHECKING
from pathlib import Path

import pandas as pd
from sqlalchemy import (
    create_engine,
    Column,
    String,
    Float,
    Date,
    DateTime,
    Integer,
    Index,
    UniqueConstraint,
    Text,
    select,
    and_,
    desc,
    text
)
from sqlalchemy.orm import (
    declarative_base,
    sessionmaker,
    Session,
)
from sqlalchemy.exc import IntegrityError

from src.config import get_config

logger = logging.getLogger(__name__)

# SQLAlchemy ORM åŸºç±»
Base = declarative_base()

if TYPE_CHECKING:
    from src.search_service import SearchResponse


# === æ•°æ®æ¨¡å‹å®šä¹‰ ===

class StockDaily(Base):
    """
    è‚¡ç¥¨æ—¥çº¿æ•°æ®æ¨¡å‹
    """
    __tablename__ = 'stock_daily'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    code = Column(String(10), nullable=False, index=True)
    date = Column(Date, nullable=False, index=True)
    open = Column(Float)
    high = Column(Float)
    low = Column(Float)
    close = Column(Float)
    volume = Column(Float)
    amount = Column(Float)
    pct_chg = Column(Float)
    ma5 = Column(Float)
    ma10 = Column(Float)
    ma20 = Column(Float)
    volume_ratio = Column(Float)
    data_source = Column(String(50))
    created_at = Column(DateTime, default=datetime.now)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
    
    __table_args__ = (
        UniqueConstraint('code', 'date', name='uix_code_date'),
        Index('ix_code_date', 'code', 'date'),
    )
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'code': self.code,
            'date': self.date,
            'open': self.open,
            'high': self.high,
            'low': self.low,
            'close': self.close,
            'volume': self.volume,
            'amount': self.amount,
            'pct_chg': self.pct_chg,
            'ma5': self.ma5,
            'ma10': self.ma10,
            'ma20': self.ma20,
            'volume_ratio': self.volume_ratio,
            'data_source': self.data_source,
        }


class NewsIntel(Base):
    """æ–°é—»æƒ…æŠ¥æ•°æ®æ¨¡å‹"""
    __tablename__ = 'news_intel'

    id = Column(Integer, primary_key=True, autoincrement=True)
    query_id = Column(String(64), index=True)
    code = Column(String(10), nullable=False, index=True)
    name = Column(String(50))
    dimension = Column(String(32), index=True)
    query = Column(String(255))
    provider = Column(String(32), index=True)
    title = Column(String(300), nullable=False)
    snippet = Column(Text)
    url = Column(String(1000), nullable=False)
    source = Column(String(100))
    published_date = Column(DateTime, index=True)
    fetched_at = Column(DateTime, default=datetime.now, index=True)
    query_source = Column(String(32), index=True)
    requester_platform = Column(String(20))
    requester_user_id = Column(String(64))
    requester_user_name = Column(String(64))
    requester_chat_id = Column(String(64))
    requester_message_id = Column(String(64))
    requester_query = Column(String(255))

    __table_args__ = (
        UniqueConstraint('url', name='uix_news_url'),
        Index('ix_news_code_pub', 'code', 'published_date'),
    )


class AnalysisHistory(Base):
    """åˆ†æç»“æœå†å²è®°å½•æ¨¡å‹"""
    __tablename__ = 'analysis_history'

    id = Column(Integer, primary_key=True, autoincrement=True)
    query_id = Column(String(64), index=True)
    code = Column(String(10), nullable=False, index=True)
    name = Column(String(50))
    report_type = Column(String(16), index=True)
    sentiment_score = Column(Integer)
    operation_advice = Column(String(20))
    trend_prediction = Column(String(50))
    analysis_summary = Column(Text)
    raw_result = Column(Text)
    news_content = Column(Text)
    context_snapshot = Column(Text)
    ideal_buy = Column(Float)
    secondary_buy = Column(Float)
    stop_loss = Column(Float)
    take_profit = Column(Float)
    created_at = Column(DateTime, default=datetime.now, index=True)

    __table_args__ = (
        Index('ix_analysis_code_time', 'code', 'created_at'),
    )

    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id,
            'query_id': self.query_id,
            'code': self.code,
            'name': self.name,
            'report_type': self.report_type,
            'sentiment_score': self.sentiment_score,
            'operation_advice': self.operation_advice,
            'trend_prediction': self.trend_prediction,
            'analysis_summary': self.analysis_summary,
            'created_at': self.created_at.isoformat() if self.created_at else None,
        }


class DatabaseManager:
    """
    æ•°æ®åº“ç®¡ç†å™¨ - å•ä¾‹æ¨¡å¼
    """
    
    _instance: Optional['DatabaseManager'] = None
    
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self, db_url: Optional[str] = None):
        if self._initialized:
            return
        
        if db_url is None:
            config = get_config()
            db_url = config.get_db_url()
        
        self._engine = create_engine(
            db_url,
            echo=False,
            pool_pre_ping=True,
        )
        
        self._SessionLocal = sessionmaker(
            bind=self._engine,
            autocommit=False,
            autoflush=False,
        )
        
        Base.metadata.create_all(self._engine)
        self._initialized = True
        logger.info(f"æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ: {db_url}")
        atexit.register(DatabaseManager._cleanup_engine, self._engine)
    
    @classmethod
    def get_instance(cls) -> 'DatabaseManager':
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
    
    @classmethod
    def reset_instance(cls) -> None:
        if cls._instance is not None:
            cls._instance._engine.dispose()
            cls._instance = None

    @classmethod
    def _cleanup_engine(cls, engine) -> None:
        try:
            if engine is not None:
                engine.dispose()
        except Exception:
            pass
    
    def get_session(self) -> Session:
        session = self._SessionLocal()
        try:
            return session
        except Exception:
            session.close()
            raise
    
    def has_today_data(self, code: str, target_date: Optional[date] = None) -> bool:
        if target_date is None:
            target_date = date.today()
        
        with self.get_session() as session:
            result = session.execute(
                select(StockDaily).where(
                    and_(StockDaily.code == code, StockDaily.date == target_date)
                )
            ).scalar_one_or_none()
            return result is not None
    
    def get_latest_data(self, code: str, days: int = 2) -> List[StockDaily]:
        with self.get_session() as session:
            results = session.execute(
                select(StockDaily)
                .where(StockDaily.code == code)
                .order_by(desc(StockDaily.date))
                .limit(days)
            ).scalars().all()
            return list(results)

    def save_news_intel(self, code: str, name: str, dimension: str, query: str, response: Any, query_context: Optional[Dict] = None) -> int:
        if not response or not response.results:
            return 0
        saved_count = 0
        with self.get_session() as session:
            try:
                for item in response.results:
                    title = (item.title or '').strip()
                    url = (item.url or '').strip()
                    if not title and not url: continue
                    
                    url_key = url or self._build_fallback_url_key(code, title, item.source, self._parse_published_date(item.published_date))
                    existing = session.execute(select(NewsIntel).where(NewsIntel.url == url_key)).scalar_one_or_none()

                    if existing:
                        existing.fetched_at = datetime.now()
                    else:
                        try:
                            with session.begin_nested():
                                record = NewsIntel(
                                    code=code, name=name, dimension=dimension, query=query, provider=response.provider,
                                    title=title, snippet=item.snippet, url=url_key, source=item.source,
                                    published_date=self._parse_published_date(item.published_date),
                                    fetched_at=datetime.now(),
                                    query_id=(query_context or {}).get("query_id"),
                                    query_source=(query_context or {}).get("query_source")
                                )
                                session.add(record)
                            saved_count += 1
                        except IntegrityError:
                            pass
                session.commit()
            except Exception as e:
                session.rollback()
                logger.error(f"ä¿å­˜æ–°é—»æƒ…æŠ¥å¤±è´¥: {e}")
        return saved_count

    def get_recent_news(self, code: str, days: int = 7, limit: int = 20) -> List[NewsIntel]:
        cutoff_date = datetime.now() - timedelta(days=days)
        with self.get_session() as session:
            results = session.execute(
                select(NewsIntel)
                .where(and_(NewsIntel.code == code, NewsIntel.fetched_at >= cutoff_date))
                .order_by(desc(NewsIntel.fetched_at))
                .limit(limit)
            ).scalars().all()
            return list(results)

    def save_analysis_history(self, result: Any, query_id: str, report_type: str, news_content: Optional[str], context_snapshot: Optional[Dict] = None, save_snapshot: bool = True) -> int:
        if result is None: return 0
        sniper_points = self._extract_sniper_points(result)
        raw_result = self._build_raw_result(result)
        context_text = self._safe_json_dumps(context_snapshot) if (save_snapshot and context_snapshot) else None

        record = AnalysisHistory(
            query_id=query_id, code=result.code, name=result.name, report_type=report_type,
            sentiment_score=result.sentiment_score, operation_advice=result.operation_advice,
            trend_prediction=result.trend_prediction, analysis_summary=result.analysis_summary,
            raw_result=self._safe_json_dumps(raw_result), news_content=news_content,
            context_snapshot=context_text, ideal_buy=sniper_points.get("ideal_buy"),
            secondary_buy=sniper_points.get("secondary_buy"), stop_loss=sniper_points.get("stop_loss"),
            take_profit=sniper_points.get("take_profit"), created_at=datetime.now()
        )
        with self.get_session() as session:
            try:
                session.add(record)
                session.commit()
                return 1
            except Exception as e:
                session.rollback()
                logger.error(f"ä¿å­˜åˆ†æå†å²å¤±è´¥: {e}")
                return 0

    def get_analysis_history(self, code: Optional[str] = None, query_id: Optional[str] = None, days: int = 30, limit: int = 50) -> List[AnalysisHistory]:
        cutoff_date = datetime.now() - timedelta(days=days)
        with self.get_session() as session:
            conditions = [AnalysisHistory.created_at >= cutoff_date]
            if code: conditions.append(AnalysisHistory.code == code)
            if query_id: conditions.append(AnalysisHistory.query_id == query_id)
            results = session.execute(
                select(AnalysisHistory).where(and_(*conditions)).order_by(desc(AnalysisHistory.created_at)).limit(limit)
            ).scalars().all()
            return list(results)
    
    def save_daily_data(self, df: pd.DataFrame, code: str, data_source: str = "Unknown") -> int:
        if df is None or df.empty: return 0
        saved_count = 0
        with self.get_session() as session:
            try:
                for _, row in df.iterrows():
                    row_date = row.get('date')
                    if isinstance(row_date, str):
                        row_date = datetime.strptime(row_date, '%Y-%m-%d').date()
                    elif hasattr(row_date, 'date'):
                        row_date = row_date.date()
                    
                    existing = session.execute(select(StockDaily).where(and_(StockDaily.code == code, StockDaily.date == row_date))).scalar_one_or_none()
                    if existing:
                        existing.open = row.get('open')
                        existing.high = row.get('high')
                        existing.low = row.get('low')
                        existing.close = row.get('close')
                        existing.volume = row.get('volume')
                        existing.amount = row.get('amount')
                        existing.pct_chg = row.get('pct_chg')
                        existing.ma5 = row.get('ma5')
                        existing.ma10 = row.get('ma10')
                        existing.ma20 = row.get('ma20')
                        existing.volume_ratio = row.get('volume_ratio')
                        existing.data_source = data_source
                        existing.updated_at = datetime.now()
                    else:
                        record = StockDaily(
                            code=code, date=row_date, open=row.get('open'), high=row.get('high'),
                            low=row.get('low'), close=row.get('close'), volume=row.get('volume'),
                            amount=row.get('amount'), pct_chg=row.get('pct_chg'), ma5=row.get('ma5'),
                            ma10=row.get('ma10'), ma20=row.get('ma20'), volume_ratio=row.get('volume_ratio'),
                            data_source=data_source
                        )
                        session.add(record)
                        saved_count += 1
                session.commit()
                logger.info(f"ä¿å­˜ {code} æ•°æ®æˆåŠŸï¼Œæ–°å¢ {saved_count} æ¡")
            except Exception as e:
                session.rollback()
                logger.error(f"ä¿å­˜ {code} æ•°æ®å¤±è´¥: {e}")
                raise
        return saved_count
    
    def get_analysis_context(self, code: str, target_date: Optional[date] = None) -> Optional[Dict[str, Any]]:
        if target_date is None: target_date = date.today()
        recent_data = self.get_latest_data(code, days=2)
        if not recent_data: return None
        
        today_data = recent_data[0]
        context = {'code': code, 'date': today_data.date.isoformat(), 'today': today_data.to_dict()}
        if len(recent_data) > 1:
            yesterday_data = recent_data[1]
            context['yesterday'] = yesterday_data.to_dict()
            if yesterday_data.volume and yesterday_data.volume > 0:
                context['volume_change_ratio'] = round(today_data.volume / yesterday_data.volume, 2)
            if yesterday_data.close and yesterday_data.close > 0:
                context['price_change_ratio'] = round((today_data.close - yesterday_data.close) / yesterday_data.close * 100, 2)
            context['ma_status'] = self._analyze_ma_status(today_data)
        return context

    # === æ–°å¢ï¼šç›´æ¥è·å–å†å² DataFrameï¼Œç”¨äºç›˜ä¸­ç¼åˆ ===
    def get_stock_history_df(self, code: str, days: int = 120) -> pd.DataFrame:
        """
        ä»æ•°æ®åº“è·å–å†å² K çº¿æ•°æ®ï¼Œç›´æ¥è½¬æ¢ä¸º DataFrame
        ç”¨äºç›˜ä¸­åˆ†ææ—¶çš„"å†å²åº•åº§"
        """
        try:
            sql = text(f"""
                SELECT date, open, high, low, close, volume, amount, pct_chg 
                FROM stock_daily 
                WHERE code = :code 
                ORDER BY date DESC 
                LIMIT :limit
            """)
            
            with self._engine.connect() as conn:
                df = pd.read_sql(sql, conn, params={"code": code, "limit": days})
            
            if df.empty:
                return pd.DataFrame()
            
            # æ•°æ®åº“å‡ºæ¥æ˜¯é™åº(æœ€è¿‘çš„åœ¨å‰)ï¼Œè½¬ä¸ºå‡åº(æ—¶é—´çš„æµå‘)
            df = df.sort_values('date', ascending=True).reset_index(drop=True)
            
            # ç¡®ä¿æ—¥æœŸæ ¼å¼ç»Ÿä¸€ä¸º datetime
            df['date'] = pd.to_datetime(df['date'])
            
            return df
        except Exception as e:
            logger.error(f"è¯»å–æ•°æ®åº“å¤±è´¥ {code}: {e}")
            return pd.DataFrame()
            
    # === æ–°å¢ï¼šè·å–å†å²è®°å¿†ï¼ˆç”¨äºè¿ç»­æ€§åˆ†æï¼‰ ===
    def get_last_analysis_summary(self, code: str) -> Optional[Dict[str, str]]:
        """
        è·å–ä¸Šä¸€æ¬¡åˆ†æçš„æ ¸å¿ƒè§‚ç‚¹
        è¿”å›: {'date': '2026-02-04', 'view': 'çœ‹å¤šï¼Œå› ä¸º...', 'risk': 'æ³¨æ„...'}
        """
        with self.get_session() as session:
            # è·å–æœ€è¿‘çš„ä¸€æ¡è®°å½•
            result = session.execute(
                select(AnalysisHistory)
                .where(AnalysisHistory.code == code)
                .order_by(desc(AnalysisHistory.created_at))
                .limit(1)
            ).scalar_one_or_none()
            
            if result:
                return {
                    'date': result.created_at.strftime('%Y-%m-%d'),
                    'trend': result.trend_prediction,
                    'view': result.analysis_summary[:100] + "..." if result.analysis_summary else "", # æˆªå–å‰100å­—ä½œä¸ºæ‘˜è¦
                    'advice': result.operation_advice
                }
            return None

    def _analyze_ma_status(self, data: StockDaily) -> str:
        close = data.close or 0
        ma5 = data.ma5 or 0
        ma10 = data.ma10 or 0
        ma20 = data.ma20 or 0
        if close > ma5 > ma10 > ma20 > 0: return "å¤šå¤´æ’åˆ— ğŸ“ˆ"
        elif close < ma5 < ma10 < ma20 and ma20 > 0: return "ç©ºå¤´æ’åˆ— ğŸ“‰"
        elif close > ma5 and ma5 > ma10: return "çŸ­æœŸå‘å¥½ ğŸ”¼"
        elif close < ma5 and ma5 < ma10: return "çŸ­æœŸèµ°å¼± ğŸ”½"
        else: return "éœ‡è¡æ•´ç† â†”ï¸"

    @staticmethod
    def _parse_published_date(value: Optional[str]) -> Optional[datetime]:
        if not value: return None
        if isinstance(value, datetime): return value
        text = str(value).strip()
        for fmt in ("%Y-%m-%d %H:%M:%S", "%Y-%m-%d %H:%M", "%Y-%m-%d", "%Y/%m/%d"):
            try: return datetime.strptime(text, fmt)
            except ValueError: continue
        return None

    @staticmethod
    def _safe_json_dumps(data: Any) -> str:
        try: return json.dumps(data, ensure_ascii=False, default=str)
        except Exception: return json.dumps(str(data), ensure_ascii=False)

    @staticmethod
    def _build_raw_result(result: Any) -> Dict[str, Any]:
        data = result.to_dict() if hasattr(result, "to_dict") else {}
        data.update({'data_sources': getattr(result, 'data_sources', ''), 'raw_response': getattr(result, 'raw_response', None)})
        return data

    @staticmethod
    def _extract_sniper_points(result: Any) -> Dict[str, Optional[float]]:
        raw_points = result.get_sniper_points() if hasattr(result, "get_sniper_points") else {}
        def parse(v):
            if v is None or isinstance(v, (int, float)): return v
            match = re.search(r"-?\d+(?:\.\d+)?", str(v).replace(',', ''))
            return float(match.group()) if match else None
        return {k: parse(raw_points.get(k)) for k in ["ideal_buy", "secondary_buy", "stop_loss", "take_profit"]}

    @staticmethod
    def _build_fallback_url_key(code: str, title: str, source: str, published_date: Optional[datetime]) -> str:
        date_str = published_date.isoformat() if published_date else ""
        raw_key = f"{code}|{title}|{source}|{date_str}"
        digest = hashlib.md5(raw_key.encode("utf-8")).hexdigest()
        return f"no-url:{code}:{digest}"

def get_db() -> DatabaseManager:
    return DatabaseManager.get_instance()
--------------------

#File: src/market_analyzer.py
--------------------
# src/market_analyzer.py
# -*- coding: utf-8 -*-
"""
===================================
å¤§ç›˜å¤ç›˜åˆ†ææ¨¡å— (å®è§‚ç­–ç•¥å¢å¼ºç‰ˆ + æ¿å—æ•°æ®)
===================================
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List

from src.config import get_config
from src.search_service import get_search_service
from src.analyzer import get_analyzer

# === æ ¸å¿ƒä¿®æ”¹ï¼šè·¯å¾„ä¿®æ­£ ===
try:
    from data_provider import DataFetcherManager
except ImportError:
    from data_provider.base import DataFetcherManager

try:
    from data_provider.market_monitor import market_monitor
except ImportError:
    market_monitor = None
    logger.warning("âš ï¸ è­¦å‘Š: æ— æ³•å¯¼å…¥ data_provider.market_monitor")

logger = logging.getLogger(__name__)

@dataclass
class MarketOverview:
    """å¸‚åœºæ¦‚è§ˆæ•°æ®ç»“æ„"""
    date: str
    total_amount: float = 0.0
    indices_text: str = "" 
    top_sectors: List[str] = field(default_factory=list)
    
class MarketAnalyzer:
    """å¤§ç›˜å¤ç›˜åˆ†æå™¨"""
    
    def __init__(self, search_service=None, analyzer=None):
        self.config = get_config()
        self.search_service = search_service if search_service else get_search_service()
        self.analyzer = analyzer if analyzer else get_analyzer()
        self.data_manager = DataFetcherManager() 

    def run_daily_review(self) -> str:
        """æ‰§è¡Œæ¯æ—¥å¤§ç›˜å¤ç›˜æµç¨‹"""
        logger.info("========== å¼€å§‹å¤§ç›˜å¤ç›˜åˆ†æ (å®è§‚è§†è§’) ==========")
        overview = self.get_market_overview()
        news = self.search_market_news()
        report = self.generate_market_review(overview, news)
        logger.info("========== å¤§ç›˜å¤ç›˜åˆ†æå®Œæˆ ==========")
        return report

    def get_market_overview(self) -> MarketOverview:
        """è·å–å¸‚åœºæ¦‚è§ˆæ•°æ®"""
        today = datetime.now().strftime('%Y-%m-%d')
        overview = MarketOverview(date=today)
        
        # 1. å°è¯•è·å–æŒ‡æ•°å’Œæˆäº¤é¢
        if market_monitor:
            try:
                data = market_monitor.get_market_snapshot()
                if data.get('success'):
                    overview.total_amount = data.get('total_volume', 0.0)
                    indices = data.get('indices', [])
                    idx_strs = []
                    for idx in indices:
                        name = idx['name']
                        pct = idx['change_pct']
                        emoji = "ğŸ”º" if pct > 0 else "ğŸ’š" if pct < 0 else "â–"
                        idx_strs.append(f"{name} {emoji} {pct}%")
                    overview.indices_text = " / ".join(idx_strs)
                    logger.info(f"[å¤§ç›˜] æŒ‡æ•°æ•°æ®è·å–å®Œæ¯•: {overview.indices_text}")
            except Exception as e:
                logger.warning(f"[å¤§ç›˜] Monitorè·å–æ•°æ®å¼‚å¸¸: {e}")

        # 2. å°è¯•è·å–æ¿å—æ’è¡Œ
        try:
            top_list, _ = self.data_manager.get_sector_rankings(n=5)
            if top_list:
                overview.top_sectors = [f"{item['name']} ({item['change_pct']}%)" for item in top_list]
                logger.info(f"[å¤§ç›˜] é¢†æ¶¨æ¿å—: {overview.top_sectors}")
        except Exception as e:
            logger.warning(f"[å¤§ç›˜] æ¿å—æ•°æ®è·å–å¤±è´¥: {e}")
            
        return overview

    def search_market_news(self) -> List[Dict]:
        """æœç´¢å¸‚åœºå®è§‚æ–°é—»"""
        if not self.search_service:
            return []
        
        all_news = []
        keywords = [
            "ä»Šæ—¥Aè‚¡ èµšé’±æ•ˆåº” æ¶¨è·Œå®¶æ•°", 
            "åŒ—å‘èµ„é‡‘ æµå‘ å®è§‚è§£è¯»",       
            "å¤®è¡Œ è´§å¸æ”¿ç­– æœ€æ–°æ¶ˆæ¯",
            "äººæ°‘å¸æ±‡ç‡ Aè‚¡ å½±å“",
            "ä»Šæ—¥Aè‚¡ å¤ç›˜ æœºæ„è§‚ç‚¹"
        ]
        
        logger.info("[å¤§ç›˜] å¼€å§‹æœç´¢å®è§‚æƒ…æŠ¥...")
        for query in keywords:
            try:
                results = self.search_service.search_news(query)
                if results:
                    all_news.extend(results)
            except Exception as e:
                logger.error(f"[å¤§ç›˜] æœç´¢ '{query}' å¤±è´¥: {e}")
        
        return all_news

    def generate_market_review(self, overview: MarketOverview, news: List) -> str:
        """AI ç”Ÿæˆå®è§‚ç­–ç•¥æŠ¥å‘Š"""
        
        news_text = ""
        deduplicated_news = []
        seen_titles = set()
        
        for n in news:
            title = n.get('title', 'æ— æ ‡é¢˜')
            if title not in seen_titles:
                deduplicated_news.append(n)
                seen_titles.add(title)

        for i, n in enumerate(deduplicated_news[:15], 1): 
            title = n.get('title', 'æ— æ ‡é¢˜')
            content = n.get('content', n.get('snippet', ''))[:200]
            news_text += f"{i}. ã€{title}ã€‘\n   {content}\n"

        volume_desc = f"{overview.total_amount} äº¿å…ƒ" if overview.total_amount > 0 else "æ¥å£æ•°æ®ç¼ºå¤±"
        indices_desc = overview.indices_text if overview.indices_text else "æ¥å£æ•°æ®ç¼ºå¤±"
        sector_desc = ", ".join(overview.top_sectors) if overview.top_sectors else "æ¥å£æ•°æ®ç¼ºå¤±"

        now = datetime.now()
        is_intraday = (9 <= now.hour < 15)
        time_context = "ã€ç›˜ä¸­è§£ç›˜ã€‘" if is_intraday else "ã€æ”¶ç›˜ç­–ç•¥æ—¥æŠ¥ã€‘"

        prompt = f"""è¯·ä»¥ã€å®è§‚ç­–ç•¥å¸ˆã€‘çš„èº«ä»½ï¼Œæ’°å†™ä¸€ä»½{time_context}ã€‚

# 1. å¸‚åœºæ ¸å¿ƒæ•°æ®
- æ—¶é—´: {now.strftime('%H:%M')}
- æŒ‡æ•°è¡¨ç°: {indices_desc}
- ä¸¤å¸‚æˆäº¤: {volume_desc}
- **é¢†æ¶¨æ¿å—**: {sector_desc}

# 2. å®è§‚èˆ†æƒ…ä¸çº¿ç´¢
{news_text if news_text else "æš‚æ— æ–°é—»"}

---
# ä»»åŠ¡è¦æ±‚ (Markdown)
è¯·è¾“å‡ºä¸€ä»½å¯¹å†²åŸºé‡‘é£æ ¼çš„ç­–ç•¥æ—¥æŠ¥ï¼Œç›´å‡»ç—›ç‚¹ï¼š

## ğŸ“Š {overview.date} å¸‚åœºå…¨æ™¯
### 1. å¸‚åœºå®šè°ƒ (Market Sentiment)
(ç”¨ä¸€ä¸ªè¯å®šä¹‰ä»Šæ—¥å¸‚åœºï¼šå¦‚â€œç¼©é‡é˜´è·Œâ€ã€â€œæ”¾é‡é€¼ç©ºâ€ã€‚ç®€è¿°ç†ç”±)

### 2. èµ„é‡‘ä¸åšå¼ˆ (Flows & Game)
- **èµšé’±æ•ˆåº”**: (ç»“åˆæ¶¨è·Œå®¶æ•°ä¸é¢†æ¶¨æ¿å—åˆ†æ)
- **ä¸»åŠ›æ„å›¾**: (æœºæ„æ˜¯åœ¨æ´—ç›˜è¿˜æ˜¯å‡ºè´§ï¼Ÿ)

### 3. å®è§‚é©±åŠ¨ (Macro Drivers)
(åˆ†ææ±‡ç‡ã€æ”¿ç­–ã€ç¾è‚¡æ˜ å°„ç­‰å½±å“)

### 4. äº¤æ˜“ç­–ç•¥ (Actionable Advice)
- **ä»“ä½å»ºè®®**: (ä¾‹å¦‚ï¼šå»ºè®®åŠä»“é˜²å®ˆ / å»ºè®®ç§¯æè¿›æ”»)
- **æ–¹å‘æŒ‡å¼•**: (çœ‹å¥½å“ªä¸ªé£æ ¼ï¼Ÿ)
"""
        try:
            logger.info("[å¤§ç›˜] æ­£åœ¨ç”Ÿæˆå®è§‚ç­–ç•¥æŠ¥å‘Š...")
            report = self.analyzer.chat(prompt)
            return report
        except Exception as e:
            logger.error(f"[å¤§ç›˜] AI ç”ŸæˆæŠ¥å‘Šå¤±è´¥: {e}")
            return f"ç”ŸæˆæŠ¥å‘Šå‡ºé”™: {str(e)}"

def get_market_analyzer():
    return MarketAnalyzer()
--------------------

#File: src/search_service.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Aè‚¡è‡ªé€‰è‚¡æ™ºèƒ½åˆ†æç³»ç»Ÿ - æœç´¢æœåŠ¡æ¨¡å— (å®Œæ•´ä¿®å¤ç‰ˆ)
===================================
åŠŸèƒ½ç‰¹ç‚¹ï¼š
1. ä»…ä¿ç•™ Perplexity AI (Researcher æ¨¡å¼)
2. é›†æˆâ€œä¹°æ–¹æœºæ„é«˜çº§ç ”ç©¶å‘˜â€Prompt (Tier 1/2/3 åˆ†çº§)
3. æ˜¾æ€§æ˜¾ç¤º Token æ¶ˆè€—
4. ä¿®å¤ get_search_service å•ä¾‹æ¥å£
"""

import logging
import os
import requests
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional
from itertools import cycle

# é…ç½®æ—¥å¿—
logger = logging.getLogger(__name__)

# === åŸºç¡€æ•°æ®ç»“æ„ ===
@dataclass
class SearchResult:
    title: str
    snippet: str
    url: str
    source: str
    published_date: Optional[str] = None
    
    def to_text(self) -> str:
        date_str = f" ({self.published_date})" if self.published_date else ""
        return f"ã€{self.source}ã€‘{self.title}{date_str}\n{self.snippet}"

@dataclass 
class SearchResponse:
    query: str
    results: List[SearchResult]
    provider: str
    success: bool = True
    error_message: Optional[str] = None
    
    def to_context(self, max_results: int = 5) -> str:
        if not self.success:
            return f"ï¼ˆâš ï¸ æœç´¢ä¸å¯ç”¨: {self.error_message}ï¼‰"
        if not self.results:
            return "æœªæ‰¾åˆ°ç›¸å…³é‡å¤§èˆ†æƒ…ã€‚"
        
        # Perplexity æ·±åº¦æŠ¥å‘Šç›´æ¥è¿”å›å…¨æ–‡
        if len(self.results) == 1:
            return self.results[0].snippet

        return "\n".join([f"{i+1}. {r.to_text()}" for i, r in enumerate(self.results[:max_results])])

# === æ ¸å¿ƒï¼šPerplexity æœç´¢æä¾›è€… ===
class PerplexitySearchProvider:
    """Perplexity AI æœç´¢å¼•æ“ (Researcher æ¨¡å¼)"""
    def __init__(self, api_keys: List[str]):
        self._api_keys = api_keys
        self._key_cycle = cycle(api_keys)
        self._name = "Perplexity AI"

    def _get_key(self):
        return next(self._key_cycle) if self._api_keys else None

    def search(self, query: str) -> SearchResponse:
        """æ‰§è¡Œæœç´¢çš„ä¸»è¦é€»è¾‘"""
        api_key = self._get_key()
        if not api_key:
            return SearchResponse(query, [], self._name, False, "æœªé…ç½® Key")

        url = "https://api.perplexity.ai/chat/completions"
        current_date = datetime.now().strftime("%Y-%m-%d")

        # === 1. ä¹°æ–¹æœºæ„é«˜çº§ç ”ç©¶å‘˜ Prompt (Tieråˆ†çº§å¢å¼ºç‰ˆ) ===
        system_prompt = (
            f"ä»Šå¤©æ˜¯ {current_date}ã€‚ä½ æ˜¯ä¸€å®¶é¡¶çº§ä¹°æ–¹æœºæ„çš„ã€é«˜çº§è¡Œä¸šç ”ç©¶å‘˜ (Senior Equity Analyst)ã€‘ã€‚\n"
            "ä½ çš„æ ¸å¿ƒä»»åŠ¡æ˜¯ï¼šä»æµ·é‡äº’è”ç½‘ä¿¡æ¯ä¸­æ¸…æ´—å‡ºå…·æœ‰ã€äº¤æ˜“ä»·å€¼ã€‘çš„é¢„æœŸå·®æƒ…æŠ¥ï¼Œä¾›åŸºé‡‘ç»ç†å†³ç­–ã€‚\n\n"
            
            "ã€æƒ…æŠ¥åˆ†çº§æ ‡å‡† (æƒé‡ç”±é«˜åˆ°ä½)ã€‘\n"
            "1. **Tier 1 (çœŸé‡‘ç™½é“¶/æ ¸å¿ƒå¼‚åŠ¨)**ï¼š\n"
            "   - **å®æ§äºº/é«˜ç®¡å¢å‡æŒ**ï¼ˆé‡ç‚¹å…³æ³¨å‡æŒè®¡åˆ’æˆ–è¿è§„å‡æŒï¼‰ã€‚\n"
            "   - **å…¬å¸å›è´­/æ³¨é”€**ï¼ˆåŒºåˆ†æ˜¯â€œå·²å®Œæˆâ€è¿˜æ˜¯â€œç”»é¥¼â€ï¼Œå…³æ³¨æ³¨é”€å¼å›è´­ï¼‰ã€‚\n"
            "   - **æœºæ„å¯†é›†è°ƒç ”**ï¼ˆç‰¹åˆ«æ˜¯çŸ¥åå…¬å‹Ÿ/ç§å‹Ÿçš„è°ƒç ”è®°å½•ï¼‰ã€‚\n"
            "   - **é‡å¤§èµ„äº§é‡ç»„/è‚¡æƒè½¬è®©**ã€‚\n"
            "2. **Tier 2 (ç»è¥/ä¸šç»©)**ï¼š\n"
            "   - ä¸šç»©é¢„å‘Šï¼ˆè¶…é¢„æœŸ/æš´é›·ï¼‰ã€äº§å“æ¶¨ä»·å‡½ã€åœ¨æ‰‹è®¢å•å˜åŒ–ã€‚\n"
            "3. **Tier 3 (ä¸€èˆ¬èµ„è®¯ - éœ€è¿‡æ»¤å™ªéŸ³)**ï¼š\n"
            "   - å¿½ç•¥â€œè£è·XXå¥–é¡¹â€ã€â€œç­¾ç½²æ— é‡‘é¢çš„æˆ˜ç•¥æ¡†æ¶åè®®â€ç­‰å‡‘æ•°çš„åˆ©å¥½ã€‚\n\n"

            "ã€è¾“å‡ºæ ¼å¼ã€‘\n"
            "è¯·ç›´æ¥è¾“å‡ºä¸€ä»½ **Markdown æ ¼å¼çš„æ·±åº¦ç ”æŠ¥**ï¼Œç»“æ„å¦‚ä¸‹ï¼š\n\n"
            
            "### ğŸš¨ æ ¸å¿ƒé£é™©ä¸é›·åŒº\n"
            "- (é‡ç‚¹æ’æŸ¥ï¼šç«‹æ¡ˆè°ƒæŸ¥ã€ç›‘ç®¡å‡½ã€é«˜æ¯”ä¾‹è´¨æŠ¼ã€å¤§é¢è§£ç¦ã€å‡æŒå…¬å‘Šã€‚è‹¥æ— æ˜æ˜¾é£é™©ï¼Œè¯·æ³¨æ˜â€œæš‚æ— æ˜¾æ€§é£é™©â€)\n\n"
            
            "### ğŸ’¸ èµ„é‡‘ä¸ç­¹ç åšå¼ˆ (é‡ç‚¹)\n"
            "- **å¢å‡æŒ/å›è´­**ï¼š(ä¾‹å¦‚ï¼šæ‹Ÿå›è´­1-2äº¿å…ƒå¹¶æ³¨é”€ï¼›å®æ§äººæ‹Ÿå‡æŒä¸è¶…è¿‡1%ç­‰)\n"
            "- **æœºæ„åŠ¨å‘**ï¼š(ä¾‹å¦‚ï¼šè¿‘3æ—¥è·xxå®¶æœºæ„è°ƒç ”ï¼›åŒ—å‘èµ„é‡‘æµå‘ç­‰)\n\n"
            
            "### ğŸš€ æ ¸å¿ƒå‚¬åŒ–å‰‚ (é¢„æœŸå·®)\n"
            "- (æ–°äº§å“å‘å¸ƒã€è¡Œä¸šæ”¿ç­–åˆ©å¥½ã€ä¸»è¦ç«äº‰å¯¹æ‰‹åœäº§ç­‰å…·ä½“é©±åŠ¨åŠ›)\n\n"
            
            "### ğŸ“° é‡è¦æ–°é—»é€Ÿé€’ (è¿‘72å°æ—¶)\n"
            "- (æŒ‰é‡è¦æ€§æ’åºï¼Œä»…åˆ—å‡ºå¯¹è‚¡ä»·æœ‰å®è´¨å½±å“çš„å‰3æ¡ï¼Œé™„å¸¦æ—¶é—´)\n\n"

            "ã€ä¸¥æ ¼é™åˆ¶ã€‘\n"
            "- å¿…é¡»ä¿æŒå®¢è§‚ã€çŠ€åˆ©ï¼Œ**ä¸è¦è¯´åºŸè¯**ã€‚\n"
            "- å¦‚æœæœç´¢ç»“æœä¸­æ²¡æœ‰ç›¸å…³æ•°æ®ï¼ˆå¦‚æ²¡æœ‰å›è´­ï¼‰ï¼Œå°±ç›´æ¥è¯´â€œè¿‘æœŸæ— å›è´­â€ï¼Œä¸è¦ç¼–é€ ã€‚\n"
            "- å­—æ•°æ§åˆ¶åœ¨ 800 å­—ä»¥å†…ã€‚"
        )

        payload = {
            "model": "sonar", 
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": query}
            ],
            "temperature": 0.2, # ä¿æŒä½æ¸©ï¼Œç¡®ä¿äº‹å®å‡†ç¡®
            "max_tokens": 4000 
        }
        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }

        try:
            # è¶…æ—¶ä¿æŠ¤è®¾ç½®ä¸º 45ç§’
            response = requests.post(url, json=payload, headers=headers, timeout=45) 
            
            if response.status_code == 200:
                data = response.json()
                content = data['choices'][0]['message']['content']
                
                # === æ˜¾æ€§å±•ç¤º Token æ¶ˆè€— ===
                usage = data.get('usage', {})
                total = usage.get('total_tokens', 0)
                prompt_tokens = usage.get('prompt_tokens', 0)
                completion = usage.get('completion_tokens', 0)
                
                print(f"ğŸ’° [Perplexity] æ¶ˆè€—ç»Ÿè®¡: è¾“å…¥{prompt_tokens} + è¾“å‡º{completion} = æ€»è®¡ {total} Tokens")
                logger.info(f"[Researcher] ä¾¦æŸ¥å®Œæˆ (æ¶ˆè€— {total} tokens)")

                return SearchResponse(query, [SearchResult(
                    title="Perplexity æ·±åº¦æƒ…æŠ¥",
                    snippet=content,
                    url="https://perplexity.ai",
                    source="Perplexity",
                    published_date=current_date
                )], self._name, True)
            
            elif response.status_code == 429:
                print(f"âš ï¸ [Perplexity] è§¦å‘é™æµ (429)ï¼Œè·³è¿‡æœ¬æ¬¡æœç´¢ã€‚")
                logger.warning(f"âš ï¸ [Perplexity] è§¦å‘é™æµ (429)")
                return SearchResponse(query, [], self._name, False, "Rate Limited (429)")
            
            else:
                err_msg = f"HTTP {response.status_code}"
                logger.error(f"[Perplexity] API Error: {response.status_code}")
                return SearchResponse(query, [], self._name, False, err_msg)

        except Exception as e:
            logger.warning(f"[Perplexity] è¿æ¥å¤±è´¥: {e}")
            return SearchResponse(query, [], self._name, False, "Timeout/Error")

# === æœåŠ¡ç®¡ç†ç±» (å¯¹å¤–æ¥å£) ===
class SearchService:
    def __init__(self, bocha_keys=None, tavily_keys=None, serpapi_keys=None):
        """
        åˆå§‹åŒ–æœç´¢æœåŠ¡
        """
        self.provider = None
        
        # 1. ä¼˜å…ˆä»ç¯å¢ƒå˜é‡è¯»å–
        pplx_key = os.getenv("PERPLEXITY_API_KEY")
        
        # 2. å…¼å®¹ï¼šä» bocha_keys å‚æ•°ä¸­è¯»å– pplx key (é˜²æ­¢æ—§é…ç½®æŠ¥é”™)
        if not pplx_key and bocha_keys and isinstance(bocha_keys, list):
            for k in bocha_keys:
                if k.startswith("pplx-"):
                    pplx_key = k
                    break
        
        if pplx_key:
            logger.info("ğŸš€ å¯ç”¨ Perplexity Researcher æ·±åº¦æœç´¢æ¨¡å¼")
            self.provider = PerplexitySearchProvider([pplx_key])
        else:
            logger.warning("âš ï¸ æœªæ£€æµ‹åˆ° PERPLEXITY_API_KEYï¼Œæœç´¢åŠŸèƒ½å°†ä¸å¯ç”¨")

    def search(self, query: str, max_results: int = 5) -> SearchResponse:
        """
        ç»Ÿä¸€æœç´¢å…¥å£
        """
        if self.provider:
            return self.provider.search(query)
        
        return SearchResponse(
            query=query,
            results=[],
            provider="None",
            success=False,
            error_message="Search Service Not Configured (Missing Perplexity Key)"
        )

# === å®ä¾‹åŒ–å…¥å£å‡½æ•° (å…³é”®ä¿®å¤) ===
def get_search_service():
    """
    å•ä¾‹æ¨¡å¼è·å–æœç´¢æœåŠ¡å®ä¾‹
    """
    try:
        from src.config import SEARCH_PROVIDER_CONFIG
        return SearchService(
            bocha_keys=SEARCH_PROVIDER_CONFIG.get('bocha_api_keys', []),
            tavily_keys=SEARCH_PROVIDER_CONFIG.get('tavily_api_keys', []),
            serpapi_keys=SEARCH_PROVIDER_CONFIG.get('serpapi_api_keys', [])
        )
    except ImportError:
        # é™çº§å¤„ç†ï¼šå¦‚æœæ²¡æœ‰ configï¼Œå°è¯•ç›´æ¥ç”¨ç¯å¢ƒå˜é‡
        return SearchService()
--------------------

#File: src/scheduler.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
å®šæ—¶è°ƒåº¦æ¨¡å—
===================================

èŒè´£ï¼š
1. æ”¯æŒæ¯æ—¥å®šæ—¶æ‰§è¡Œè‚¡ç¥¨åˆ†æ
2. æ”¯æŒå®šæ—¶æ‰§è¡Œå¤§ç›˜å¤ç›˜
3. ä¼˜é›…å¤„ç†ä¿¡å·ï¼Œç¡®ä¿å¯é é€€å‡º

ä¾èµ–ï¼š
- schedule: è½»é‡çº§å®šæ—¶ä»»åŠ¡åº“
"""

import logging
import signal
import sys
import time
import threading
from datetime import datetime
from typing import Callable, Optional

logger = logging.getLogger(__name__)


class GracefulShutdown:
    """
    ä¼˜é›…é€€å‡ºå¤„ç†å™¨
    
    æ•è· SIGTERM/SIGINT ä¿¡å·ï¼Œç¡®ä¿ä»»åŠ¡å®Œæˆåå†é€€å‡º
    """
    
    def __init__(self):
        self.shutdown_requested = False
        self._lock = threading.Lock()
        
        # æ³¨å†Œä¿¡å·å¤„ç†å™¨
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        """ä¿¡å·å¤„ç†å‡½æ•°"""
        with self._lock:
            if not self.shutdown_requested:
                logger.info(f"æ”¶åˆ°é€€å‡ºä¿¡å· ({signum})ï¼Œç­‰å¾…å½“å‰ä»»åŠ¡å®Œæˆ...")
                self.shutdown_requested = True
    
    @property
    def should_shutdown(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥é€€å‡º"""
        with self._lock:
            return self.shutdown_requested


class Scheduler:
    """
    å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
    
    åŸºäº schedule åº“å®ç°ï¼Œæ”¯æŒï¼š
    - æ¯æ—¥å®šæ—¶æ‰§è¡Œ
    - å¯åŠ¨æ—¶ç«‹å³æ‰§è¡Œ
    - ä¼˜é›…é€€å‡º
    """
    
    def __init__(self, schedule_time: str = "18:00"):
        """
        åˆå§‹åŒ–è°ƒåº¦å™¨
        
        Args:
            schedule_time: æ¯æ—¥æ‰§è¡Œæ—¶é—´ï¼Œæ ¼å¼ "HH:MM"
        """
        try:
            import schedule
            self.schedule = schedule
        except ImportError:
            logger.error("schedule åº“æœªå®‰è£…ï¼Œè¯·æ‰§è¡Œ: pip install schedule")
            raise ImportError("è¯·å®‰è£… schedule åº“: pip install schedule")
        
        self.schedule_time = schedule_time
        self.shutdown_handler = GracefulShutdown()
        self._task_callback: Optional[Callable] = None
        self._running = False
        
    def set_daily_task(self, task: Callable, run_immediately: bool = True):
        """
        è®¾ç½®æ¯æ—¥å®šæ—¶ä»»åŠ¡
        
        Args:
            task: è¦æ‰§è¡Œçš„ä»»åŠ¡å‡½æ•°ï¼ˆæ— å‚æ•°ï¼‰
            run_immediately: æ˜¯å¦åœ¨è®¾ç½®åç«‹å³æ‰§è¡Œä¸€æ¬¡
        """
        self._task_callback = task
        
        # è®¾ç½®æ¯æ—¥å®šæ—¶ä»»åŠ¡
        self.schedule.every().day.at(self.schedule_time).do(self._safe_run_task)
        logger.info(f"å·²è®¾ç½®æ¯æ—¥å®šæ—¶ä»»åŠ¡ï¼Œæ‰§è¡Œæ—¶é—´: {self.schedule_time}")
        
        if run_immediately:
            logger.info("ç«‹å³æ‰§è¡Œä¸€æ¬¡ä»»åŠ¡...")
            self._safe_run_task()
    
    def _safe_run_task(self):
        """å®‰å…¨æ‰§è¡Œä»»åŠ¡ï¼ˆå¸¦å¼‚å¸¸æ•è·ï¼‰"""
        if self._task_callback is None:
            return
        
        try:
            logger.info("=" * 50)
            logger.info(f"å®šæ—¶ä»»åŠ¡å¼€å§‹æ‰§è¡Œ - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            logger.info("=" * 50)
            
            self._task_callback()
            
            logger.info(f"å®šæ—¶ä»»åŠ¡æ‰§è¡Œå®Œæˆ - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
        except Exception as e:
            logger.exception(f"å®šæ—¶ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {e}")
    
    def run(self):
        """
        è¿è¡Œè°ƒåº¦å™¨ä¸»å¾ªç¯
        
        é˜»å¡è¿è¡Œï¼Œç›´åˆ°æ”¶åˆ°é€€å‡ºä¿¡å·
        """
        self._running = True
        logger.info("è°ƒåº¦å™¨å¼€å§‹è¿è¡Œ...")
        logger.info(f"ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´: {self._get_next_run_time()}")
        
        while self._running and not self.shutdown_handler.should_shutdown:
            self.schedule.run_pending()
            time.sleep(30)  # æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
            
            # æ¯å°æ—¶æ‰“å°ä¸€æ¬¡å¿ƒè·³
            if datetime.now().minute == 0 and datetime.now().second < 30:
                logger.info(f"è°ƒåº¦å™¨è¿è¡Œä¸­... ä¸‹æ¬¡æ‰§è¡Œ: {self._get_next_run_time()}")
        
        logger.info("è°ƒåº¦å™¨å·²åœæ­¢")
    
    def _get_next_run_time(self) -> str:
        """è·å–ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´"""
        jobs = self.schedule.get_jobs()
        if jobs:
            next_run = min(job.next_run for job in jobs)
            return next_run.strftime('%Y-%m-%d %H:%M:%S')
        return "æœªè®¾ç½®"
    
    def stop(self):
        """åœæ­¢è°ƒåº¦å™¨"""
        self._running = False


def run_with_schedule(
    task: Callable,
    schedule_time: str = "18:00",
    run_immediately: bool = True
):
    """
    ä¾¿æ·å‡½æ•°ï¼šä½¿ç”¨å®šæ—¶è°ƒåº¦è¿è¡Œä»»åŠ¡
    
    Args:
        task: è¦æ‰§è¡Œçš„ä»»åŠ¡å‡½æ•°
        schedule_time: æ¯æ—¥æ‰§è¡Œæ—¶é—´
        run_immediately: æ˜¯å¦ç«‹å³æ‰§è¡Œä¸€æ¬¡
    """
    scheduler = Scheduler(schedule_time=schedule_time)
    scheduler.set_daily_task(task, run_immediately=run_immediately)
    scheduler.run()


if __name__ == "__main__":
    # æµ‹è¯•å®šæ—¶è°ƒåº¦
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s | %(levelname)-8s | %(name)-20s | %(message)s',
    )
    
    def test_task():
        print(f"ä»»åŠ¡æ‰§è¡Œä¸­... {datetime.now()}")
        time.sleep(2)
        print("ä»»åŠ¡å®Œæˆ!")
    
    print("å¯åŠ¨æµ‹è¯•è°ƒåº¦å™¨ï¼ˆæŒ‰ Ctrl+C é€€å‡ºï¼‰")
    run_with_schedule(test_task, schedule_time="23:59", run_immediately=True)

--------------------

#File: src/stock_analyzer.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
è¶‹åŠ¿äº¤æ˜“åˆ†æå™¨ (æŒä»“/ç©ºä»“åŒè§„ç­–ç•¥ç‰ˆ)
===================================
"""

import logging
from dataclasses import dataclass, field
from typing import List, Dict, Any
from enum import Enum
import pandas as pd
import numpy as np

logger = logging.getLogger(__name__)

class TrendStatus(Enum):
    STRONG_BULL = "å¼ºåŠ¿å¤šå¤´"
    BULL = "å¤šå¤´æ’åˆ—"
    WEAK_BULL = "å¼±åŠ¿å¤šå¤´"
    CONSOLIDATION = "éœ‡è¡æ•´ç†"
    WEAK_BEAR = "å¼±åŠ¿ç©ºå¤´"
    BEAR = "ç©ºå¤´æ’åˆ—"
    STRONG_BEAR = "å¼ºåŠ¿ç©ºå¤´"

class BuySignal(Enum):
    STRONG_BUY = "å¼ºçƒˆä¹°å…¥"
    BUY = "ä¹°å…¥"
    HOLD = "æŒæœ‰"
    WAIT = "è§‚æœ›"
    SELL = "å–å‡º"

@dataclass
class TrendAnalysisResult:
    code: str
    current_price: float = 0.0
    
    # æ ¸å¿ƒç»“è®º
    trend_status: TrendStatus = TrendStatus.CONSOLIDATION
    signal_score: int = 50 
    buy_signal: BuySignal = BuySignal.WAIT
    
    # === æ–°å¢ï¼šåˆ†æŒä»“æƒ…å†µå»ºè®® ===
    advice_for_empty: str = ""    # ç»™ç©ºä»“è€…çš„å»ºè®®
    advice_for_holding: str = ""  # ç»™æŒä»“è€…çš„å»ºè®®
    
    # åŸºç¡€æ•°æ®
    ma5: float = 0.0
    ma10: float = 0.0
    ma20: float = 0.0
    bias_ma5: float = 0.0
    volume_ratio: float = 0.0
    volume_trend: str = "é‡èƒ½æ­£å¸¸"
    
    # è¾…åŠ©ä¿¡æ¯
    signal_reasons: List[str] = field(default_factory=list)
    risk_factors: List[str] = field(default_factory=list)
    macd_signal: str = ""
    kdj_signal: str = ""

class StockTrendAnalyzer:
    
    def analyze(self, df: pd.DataFrame, code: str) -> TrendAnalysisResult:
        result = TrendAnalysisResult(code=code)
        
        if df is None or df.empty or len(df) < 30:
            result.advice_for_empty = "æ•°æ®ä¸è¶³ï¼Œè§‚æœ›"
            result.advice_for_holding = "æ•°æ®ä¸è¶³ï¼Œè°¨æ…"
            return result

        try:
            df = self._calc_indicators(df)
            latest = df.iloc[-1]
            prev = df.iloc[-2]
            
            result.current_price = float(latest['close'])
            result.ma5 = float(latest['MA5'])
            result.ma10 = float(latest['MA10'])
            result.ma20 = float(latest['MA20'])
            
            # é‡æ¯”å¤„ç†
            vol_ma5 = df['volume'].iloc[-6:-1].mean()
            result.volume_ratio = float(latest['volume'] / vol_ma5) if vol_ma5 > 0 else 1.0
            if 'volume_ratio' in latest and latest['volume_ratio'] > 0:
                result.volume_ratio = float(latest['volume_ratio'])
                
            # 1. è¶‹åŠ¿åˆ¤å®š
            ma5, ma10, ma20 = result.ma5, result.ma10, result.ma20
            score = 50
            
            if ma5 > ma10 > ma20:
                result.trend_status = TrendStatus.BULL
                score = 70
                if ma20 > 0 and (ma5 - ma20) / ma20 > 0.05:
                    result.trend_status = TrendStatus.STRONG_BULL
                    score = 75
            elif ma5 < ma10 < ma20:
                result.trend_status = TrendStatus.BEAR
                score = 30
            else:
                result.trend_status = TrendStatus.CONSOLIDATION
                score = 50

            # 2. ä¹–ç¦»ç‡ä¸æ‹©æ—¶
            bias = (result.current_price - ma5) / ma5 * 100 if ma5 > 0 else 0
            result.bias_ma5 = bias
            
            # åŸºç¡€åˆ†è°ƒæ•´
            if bias > 8: score -= 15
            elif bias > 5: score -= 5
            elif 0 <= bias <= 3 and result.trend_status in [TrendStatus.BULL]: score += 10
            elif -5 <= bias < 0:
                if result.volume_ratio < 0.8: score += 15
                else: score += 10
            elif bias < -10:
                if result.trend_status == TrendStatus.BEAR: score -= 5
                else: score += 10

            # 3. è¾…åŠ©æŒ‡æ ‡
            # MACD
            if latest['MACD_DIF'] > latest['MACD_DEA'] and prev['MACD_DIF'] <= prev['MACD_DEA']:
                score += 5
                result.macd_signal = "é‡‘å‰"
            # KDJ
            if latest['K'] < 40 and latest['K'] > latest['D'] and prev['K'] <= prev['D']:
                score += 5
                result.kdj_signal = "é‡‘å‰"

            # 4. æœ€ç»ˆè¯„çº§
            score = min(100, max(0, score))
            result.signal_score = int(score)
            
            if score >= 85: result.buy_signal = BuySignal.STRONG_BUY
            elif score >= 70: result.buy_signal = BuySignal.BUY
            elif score >= 50: result.buy_signal = BuySignal.HOLD
            elif score >= 35: result.buy_signal = BuySignal.WAIT
            else: result.buy_signal = BuySignal.SELL
            
            # === æ ¸å¿ƒé€»è¾‘ï¼šç”Ÿæˆåˆ†æƒ…å†µå»ºè®® ===
            self._generate_detailed_advice(result)

            return result

        except Exception as e:
            logger.error(f"[{code}] åˆ†æå¼‚å¸¸: {e}")
            return result

    def _generate_detailed_advice(self, res: TrendAnalysisResult):
        """ç”ŸæˆæŒä»“/ç©ºä»“çš„åˆ†ç¦»å»ºè®®"""
        bias = res.bias_ma5
        trend = res.trend_status
        
        # åœºæ™¯A: å¼ºåŠ¿å¤šå¤´/å¤šå¤´
        if trend in [TrendStatus.STRONG_BULL, TrendStatus.BULL]:
            # ç©ºä»“è€…
            if bias > 5:
                res.advice_for_empty = "âŒ ä¹–ç¦»ç‡è¿‡é«˜ï¼Œä¸¥ç¦è¿½é«˜ï¼Œè€å¿ƒç­‰å¾…ç¼©é‡å›è¸©MA5"
            elif bias > 2:
                res.advice_for_empty = "âš ï¸ æ­¤æ—¶ä»‹å…¥æ€§ä»·æ¯”ä¸€èˆ¬ï¼Œå»ºè®®è½»ä»“è¯•é”™æˆ–ç­‰å¾…å›è°ƒ"
            elif -2 <= bias <= 2:
                res.advice_for_empty = "âœ… é»„é‡‘ä¹°ç‚¹åŒºé—´ï¼Œæ²¿MA5ç§¯æå»ºä»“"
            else: # å›è°ƒè¾ƒæ·±
                res.advice_for_empty = "âœ… ä¹Ÿæ˜¯æœºä¼šï¼Œä½†éœ€å…³æ³¨MA10/MA20æ”¯æ’‘æœ‰æ•ˆæ€§"
            
            # æŒä»“è€…
            if bias > 8:
                res.advice_for_holding = "âš ï¸ çŸ­æœŸæ¶¨å¹…è¿‡å¤§ï¼Œå¯é€‚å½“æ­¢ç›ˆé”åˆ©ï¼Œåº•ä»“æ²¿MA5æŒæœ‰"
            else:
                res.advice_for_holding = "âœ… è¶‹åŠ¿å®Œå¥½ï¼Œåšå®šæŒæœ‰ï¼Œä»¥MA10ä½œä¸ºé˜²å®ˆçº¿"
                
        # åœºæ™¯B: ç©ºå¤´/å¼ºåŠ¿ç©ºå¤´
        elif trend in [TrendStatus.BEAR, TrendStatus.STRONG_BEAR]:
            # ç©ºä»“è€…
            if bias < -15:
                res.advice_for_empty = "âš¡ è¶…è·Œä¸¥é‡ï¼Œä»…é€‚åˆæ¿€è¿›è€…åšè¶…çŸ­åå¼¹ï¼ˆå¿«è¿›å¿«å‡ºï¼‰"
            else:
                res.advice_for_empty = "âŒ è¶‹åŠ¿å‘ä¸‹ï¼Œè¦†å·¢ä¹‹ä¸‹æ— å®Œåµï¼Œåšå†³ç©ºä»“è§‚æœ›"
            
            # æŒä»“è€…
            res.advice_for_holding = "âŒ è¶‹åŠ¿å·²åï¼Œå»ºè®®é€¢åå¼¹åšå†³ç¦»åœºï¼Œä¿ç•™æœ¬é‡‘"
            
        # åœºæ™¯C: éœ‡è¡
        else:
            res.advice_for_empty = "âš–ï¸ è¶‹åŠ¿ä¸æ˜ï¼Œå»ºè®®è§‚æœ›ï¼Œè‹¥çªç ´ç®±ä½“å†è·Ÿéš"
            res.advice_for_holding = "âš–ï¸ åšTä¸ºä¸»ï¼Œé«˜æŠ›ä½å¸ï¼Œé™ä½æˆæœ¬"

    def _calc_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()
        df['MA5'] = df['close'].rolling(window=5).mean()
        df['MA10'] = df['close'].rolling(window=10).mean()
        df['MA20'] = df['close'].rolling(window=20).mean()
        
        ema12 = df['close'].ewm(span=12, adjust=False).mean()
        ema26 = df['close'].ewm(span=26, adjust=False).mean()
        df['MACD_DIF'] = ema12 - ema26
        df['MACD_DEA'] = df['MACD_DIF'].ewm(span=9, adjust=False).mean()
        
        low_min = df['low'].rolling(window=9).min()
        high_max = df['high'].rolling(window=9).max()
        rsv = (df['close'] - low_min) / (high_max - low_min) * 100
        df['K'] = rsv.ewm(com=2, adjust=False).mean()
        df['D'] = df['K'].ewm(com=2, adjust=False).mean()
        return df.fillna(0)

    def format_analysis(self, result: TrendAnalysisResult) -> str:
        return f"""
ã€é‡åŒ–æŠ€æœ¯æŠ¥å‘Šã€‘
---------------------------
â— ç»¼åˆè¯„åˆ†: {result.signal_score} ({result.buy_signal.value})
â— è¶‹åŠ¿çŠ¶æ€: {result.trend_status.value}
â— å…³é”®æ•°æ®: ç°ä»·{result.current_price:.2f} | MA5ä¹–ç¦»ç‡ {result.bias_ma5:.2f}% | é‡æ¯” {result.volume_ratio:.2f}

ã€æŠ€æœ¯é¢æ“ä½œæŒ‡å¼• (ç¡¬è§„åˆ™)ã€‘
ğŸ‘¤ é’ˆå¯¹ç©ºä»“è€…: {result.advice_for_empty}
ğŸ‘¥ é’ˆå¯¹æŒä»“è€…: {result.advice_for_holding}
---------------------------
"""
--------------------

#File: src/feishu_doc.py
--------------------
# feishu_doc.py
# -*- coding: utf-8 -*-
import logging
import json
import lark_oapi as lark
from lark_oapi.api.docx.v1 import *
from typing import List, Dict, Any, Optional
from src.config import get_config

logger = logging.getLogger(__name__)


class FeishuDocManager:
    """é£ä¹¦äº‘æ–‡æ¡£ç®¡ç†å™¨ (åŸºäºå®˜æ–¹ SDK lark-oapi)"""

    def __init__(self):
        self.config = get_config()
        self.app_id = self.config.feishu_app_id
        self.app_secret = self.config.feishu_app_secret
        self.folder_token = self.config.feishu_folder_token

        # åˆå§‹åŒ– SDK å®¢æˆ·ç«¯
        # SDK ä¼šè‡ªåŠ¨å¤„ç† tenant_access_token çš„è·å–å’Œåˆ·æ–°ï¼Œæ— éœ€äººå·¥å¹²é¢„
        if self.is_configured():
            self.client = lark.Client.builder() \
                .app_id(self.app_id) \
                .app_secret(self.app_secret) \
                .log_level(lark.LogLevel.INFO) \
                .build()
        else:
            self.client = None

    def is_configured(self) -> bool:
        """æ£€æŸ¥é…ç½®æ˜¯å¦å®Œæ•´"""
        return bool(self.app_id and self.app_secret and self.folder_token)

    def create_daily_doc(self, title: str, content_md: str) -> Optional[str]:
        """
        åˆ›å»ºæ—¥æŠ¥æ–‡æ¡£
        """
        if not self.client or not self.is_configured():
            logger.warning("é£ä¹¦ SDK æœªåˆå§‹åŒ–æˆ–é…ç½®ç¼ºå¤±ï¼Œè·³è¿‡åˆ›å»º")
            return None

        try:
            # 1. åˆ›å»ºæ–‡æ¡£
            # ä½¿ç”¨å®˜æ–¹ SDK çš„ Builder æ¨¡å¼æ„é€ è¯·æ±‚
            create_request = CreateDocumentRequest.builder() \
                .request_body(CreateDocumentRequestBody.builder()
                              .folder_token(self.folder_token)
                              .title(title)
                              .build()) \
                .build()

            response = self.client.docx.v1.document.create(create_request)

            if not response.success():
                logger.error(f"åˆ›å»ºæ–‡æ¡£å¤±è´¥: {response.code} - {response.msg} - {response.error}")
                return None

            doc_id = response.data.document.document_id
            # è¿™é‡Œçš„ domain åªæ˜¯ä¸ºäº†ç”Ÿæˆé“¾æ¥ï¼Œå®é™…è®¿é—®ä¼šé‡å®šå‘
            doc_url = f"https://feishu.cn/docx/{doc_id}"
            logger.info(f"é£ä¹¦æ–‡æ¡£åˆ›å»ºæˆåŠŸ: {title} (ID: {doc_id})")

            # 2. è§£æ Markdown å¹¶å†™å…¥å†…å®¹
            # å°† Markdown è½¬æ¢ä¸º SDK éœ€è¦çš„ Block å¯¹è±¡åˆ—è¡¨
            blocks = self._markdown_to_sdk_blocks(content_md)

            # é£ä¹¦ API é™åˆ¶æ¯æ¬¡å†™å…¥ Block æ•°é‡ï¼ˆå»ºè®® 50 ä¸ªå·¦å³ï¼‰ï¼Œåˆ†æ‰¹å†™å…¥
            batch_size = 50
            doc_block_id = doc_id  # æ–‡æ¡£æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ª block

            for i in range(0, len(blocks), batch_size):
                batch_blocks = blocks[i:i + batch_size]

                # æ„é€ æ‰¹é‡æ·»åŠ å—çš„è¯·æ±‚
                batch_add_request = CreateDocumentBlockChildrenRequest.builder() \
                    .document_id(doc_id) \
                    .block_id(doc_block_id) \
                    .request_body(CreateDocumentBlockChildrenRequestBody.builder()
                                  .children(batch_blocks)  # SDK éœ€è¦ Block å¯¹è±¡åˆ—è¡¨
                                  .index(-1)  # è¿½åŠ åˆ°æœ«å°¾
                                  .build()) \
                    .build()

                write_resp = self.client.docx.v1.document_block_children.create(batch_add_request)

                if not write_resp.success():
                    logger.error(f"å†™å…¥æ–‡æ¡£å†…å®¹å¤±è´¥(æ‰¹æ¬¡{i}): {write_resp.code} - {write_resp.msg}")

            logger.info(f"æ–‡æ¡£å†…å®¹å†™å…¥å®Œæˆ")
            return doc_url

        except Exception as e:
            logger.error(f"é£ä¹¦æ–‡æ¡£æ“ä½œå¼‚å¸¸: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    def _markdown_to_sdk_blocks(self, md_text: str) -> List[Block]:
        """
        å°†ç®€å•çš„ Markdown è½¬æ¢ä¸ºé£ä¹¦ SDK çš„ Block å¯¹è±¡
        """
        blocks = []
        lines = md_text.split('\n')

        for line in lines:
            line = line.strip()
            if not line:
                continue

            # é»˜è®¤æ™®é€šæ–‡æœ¬ (Text = 2)
            block_type = 2
            text_content = line

            # è¯†åˆ«æ ‡é¢˜
            if line.startswith('# '):
                block_type = 3  # H1
                text_content = line[2:]
            elif line.startswith('## '):
                block_type = 4  # H2
                text_content = line[3:]
            elif line.startswith('### '):
                block_type = 5  # H3
                text_content = line[4:]
            elif line.startswith('---'):
                # åˆ†å‰²çº¿
                blocks.append(Block.builder()
                              .block_type(22)
                              .divider(Divider.builder().build())
                              .build())
                continue

            # æ„é€  Text ç±»å‹çš„ Block
            # SDK çš„ç»“æ„åµŒå¥—æ¯”è¾ƒæ·±: Block -> Text -> elements -> TextElement -> TextRun -> content
            text_run = TextRun.builder() \
                .content(text_content) \
                .text_element_style(TextElementStyle.builder().build()) \
                .build()

            text_element = TextElement.builder() \
                .text_run(text_run) \
                .build()

            text_obj = Text.builder() \
                .elements([text_element]) \
                .style(TextStyle.builder().build()) \
                .build()

            # æ ¹æ® block_type æ”¾å…¥æ­£ç¡®çš„å±æ€§å®¹å™¨
            block_builder = Block.builder().block_type(block_type)

            if block_type == 2:
                block_builder.text(text_obj)
            elif block_type == 3:
                block_builder.heading1(text_obj)
            elif block_type == 4:
                block_builder.heading2(text_obj)
            elif block_type == 5:
                block_builder.heading3(text_obj)

            blocks.append(block_builder.build())

        return blocks
--------------------

#File: src/core/.DS_Store
--------------------
Error reading file: 'utf-8' codec can't decode byte 0x80 in position 3131: invalid start byte
--------------------

#File: src/core/market_review.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Aè‚¡è‡ªé€‰è‚¡æ™ºèƒ½åˆ†æç³»ç»Ÿ - å¤§ç›˜å¤ç›˜æ¨¡å—
===================================

èŒè´£ï¼š
1. è°ƒç”¨ MarketAnalyzer æ‰§è¡Œå¤§ç›˜å¤ç›˜
2. ç”Ÿæˆå¤ç›˜æŠ¥å‘Š
3. ä¿å­˜æœ¬åœ°æ–‡ä»¶ AND æ¨é€é€šçŸ¥
"""

import logging
from datetime import datetime
from typing import Optional

from src.notification import NotificationService
from src.market_analyzer import MarketAnalyzer
from src.search_service import SearchService
from src.analyzer import GeminiAnalyzer

logger = logging.getLogger(__name__)

def run_market_review(
    notifier: NotificationService, 
    analyzer: Optional[GeminiAnalyzer] = None, 
    search_service: Optional[SearchService] = None,
    send_notification: bool = True
) -> Optional[str]:
    """
    æ‰§è¡Œå¤§ç›˜å¤ç›˜åˆ†æ
    """
    logger.info("ğŸ“ˆ å¼€å§‹æ‰§è¡Œå¤§ç›˜å¤ç›˜åˆ†æ...")
    
    try:
        # 1. åˆå§‹åŒ–å¤§ç›˜åˆ†æå™¨
        market_analyzer = MarketAnalyzer(
            search_service=search_service,
            analyzer=analyzer
        )
        
        # 2. æ‰§è¡Œå¤ç›˜
        review_report = market_analyzer.run_daily_review()
        
        if review_report:
            # 3. ä¿å­˜æŠ¥å‘Šåˆ°æœ¬åœ°æ–‡ä»¶
            date_str = datetime.now().strftime('%Y%m%d')
            report_filename = f"market_review_{date_str}.md"
            
            file_content = f"# ğŸ¯ å¤§ç›˜ç­–ç•¥æ—¥æŠ¥ ({datetime.now().strftime('%Y-%m-%d')})\n\n{review_report}"
            filepath = notifier.save_report_to_file(file_content, report_filename)
            logger.info(f"âœ… å¤§ç›˜å¤ç›˜æŠ¥å‘Šå·²ä¿å­˜: {filepath}")
            
            # 4. æ¨é€é€šçŸ¥
            if send_notification and notifier.is_available():
                logger.info("ğŸ“¤ æ­£åœ¨æ¨é€å¤§ç›˜å¤ç›˜æŠ¥å‘Š...")
                
                push_content = f"ğŸ¯ **å¤§ç›˜ç­–ç•¥æ—¥æŠ¥**\n\n{review_report}"
                
                success = notifier.send(push_content)
                if success:
                    logger.info("âœ… å¤§ç›˜å¤ç›˜æ¨é€æˆåŠŸ")
                else:
                    logger.warning("âŒ å¤§ç›˜å¤ç›˜æ¨é€å¤±è´¥")
            elif not send_notification:
                logger.info("å·²è·³è¿‡æ¨é€é€šçŸ¥ (--no-notify)")
            
            return review_report
        else:
            logger.warning("âš ï¸ å¤§ç›˜å¤ç›˜æœªç”Ÿæˆæœ‰æ•ˆå†…å®¹")
            return None
        
    except Exception as e:
        logger.error(f"âŒ å¤§ç›˜å¤ç›˜åˆ†ææ‰§è¡Œå¤±è´¥: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return None
--------------------

#File: src/core/pipeline.py
--------------------
# -*- coding: utf-8 -*-
import logging
import time
import random
import os
from typing import List, Dict, Optional, Any
from concurrent.futures import ThreadPoolExecutor, as_completed

# === å¯¼å…¥æ•°æ®æ¨¡å— (ä¿æŒå¥å£®æ€§) ===
try:
    from data_provider import DataFetcherManager
except ImportError:
    try:
        from data_provider.base import DataFetcherManager
    except ImportError:
        # å°è¯•ä» src å¯¼å…¥
        from src.data_provider.base import DataFetcherManager

# å°è¯•å¯¼å…¥ F10 æ•°æ®è·å–å™¨
try:
    from data_provider.fundamental_fetcher import get_fundamental_data
except ImportError:
    def get_fundamental_data(code): return {}

# å°è¯•å¯¼å…¥ å¤§ç›˜ç›‘æ§ (Market Monitor)
try:
    from data_provider.market_monitor import market_monitor
except ImportError:
    market_monitor = None

# === å†…éƒ¨æ¨¡å—å¯¼å…¥ ===
from src.stock_analyzer import StockTrendAnalyzer
from src.analyzer import GeminiAnalyzer, AnalysisResult
from src.notification import NotificationService
from src.storage import DatabaseManager  
from src.search_service import SearchService
from src.enums import ReportType

logger = logging.getLogger(__name__)

class StockAnalysisPipeline:
    """
    è‚¡ç¥¨åˆ†ææµæ°´çº¿ (æœ€ç»ˆå®Œæ•´ä¿®å¤ç‰ˆ)
    é€‚é… main.py çš„ config ä¼ å‚è°ƒç”¨æ–¹å¼ï¼ŒåŒ…å«ä¸¤é˜¶æ®µæ‰§è¡Œå’Œé˜²å°å·é€»è¾‘
    """
    def __init__(self, config, max_workers=3, query_id=None, query_source="cli", save_context_snapshot=True, source_message=None, **kwargs):
        """
        åˆå§‹åŒ– - ä¸¥æ ¼é€‚é… main.py çš„è°ƒç”¨æ–¹å¼
        """
        self.config = config
        self.query_id = query_id
        self.query_source = query_source
        self.save_context_snapshot = save_context_snapshot
        self.source_message = source_message
        
        # === 1. ä¿®å¤ max_workers ä¸º None çš„é—®é¢˜ ===
        if max_workers is None:
            max_workers = 3
            
        # === 2. åˆå§‹åŒ–å„ä¸ªæœåŠ¡ç»„ä»¶ ===
        self.fetcher_manager = DataFetcherManager()
        self.trend_analyzer = StockTrendAnalyzer()
        
        # åˆå§‹åŒ– LLM (ç›´æ¥ä» config è¯»å– key)
        self.analyzer = GeminiAnalyzer(api_key=config.gemini_api_key)
        
        # åˆå§‹åŒ– é€šçŸ¥æœåŠ¡
        self.notifier = NotificationService(source_message=source_message)
        
        # åˆå§‹åŒ– æ•°æ®åº“
        self.storage = DatabaseManager() 
        
        # === 3. åˆå§‹åŒ–æœç´¢æœåŠ¡ & æ™ºèƒ½æµæ§ ===
        self.search_service = None
        has_search_key = False
        
        # æ£€æŸ¥æ˜¯å¦é…ç½®äº†ä»»ä½•ä¸€ç§æœç´¢ Key
        if (config.bocha_api_keys or config.tavily_api_keys or 
            config.serpapi_keys or os.getenv("PERPLEXITY_API_KEY")):
            
            self.search_service = SearchService(
                bocha_keys=config.bocha_api_keys,
                tavily_keys=config.tavily_api_keys,
                serpapi_keys=config.serpapi_keys
            )
            has_search_key = True

        # å¦‚æœå¯ç”¨äº†æœç´¢ï¼Œå¼ºåˆ¶é™åˆ¶å¹¶å‘æ•°ï¼Œé˜²æ­¢ 429 é”™è¯¯
        if has_search_key:
            self.max_workers = min(max_workers, 2)
            logger.info(f"ğŸ•µï¸  [æ·±åº¦æ¨¡å¼] æœç´¢æœåŠ¡å·²å¯ç”¨ï¼Œå¹¶å‘é™åˆ¶ä¸º: {self.max_workers}")
        else:
            self.max_workers = max_workers
            logger.info(f"ğŸš€ [æé€Ÿæ¨¡å¼] çº¯æœ¬åœ°åˆ†æï¼Œå¹¶å‘æ•°: {self.max_workers}")

    def fetch_and_save_stock_data(self, code: str) -> (bool, str):
        """è·å–æ•°æ®è¾…åŠ©å‡½æ•°"""
        try:
            # 120å¤©æ•°æ®ç”¨äºè®¡ç®—è¶‹åŠ¿
            df = self.fetcher_manager.get_merged_data(code, days=120)
            if df is None or df.empty:
                return False, "è·å–æ•°æ®ä¸ºç©º"
            quote = self.fetcher_manager.get_realtime_quote(code)
            if not quote:
                return False, "å®æ—¶è¡Œæƒ…è·å–å¤±è´¥"
            return True, "Success"
        except Exception as e:
            return False, str(e)

    def _prepare_stock_context(self, code: str) -> Optional[Dict[str, Any]]:
        """å‡†å¤‡ AI åˆ†ææ‰€éœ€çš„ä¸Šä¸‹æ–‡æ•°æ®"""
        quote = self.fetcher_manager.get_realtime_quote(code)
        if not quote:
            logger.warning(f"[{code}] æ— æ³•è·å–å®æ—¶è¡Œæƒ…ï¼Œè·³è¿‡")
            return None
        stock_name = quote.name
        
        try:
            daily_df = self.fetcher_manager.get_merged_data(code, days=120)
        except Exception as e:
            logger.warning(f"[{code}] è·å–åˆå¹¶æ•°æ®å¤±è´¥: {e}")
            daily_df = None

        tech_report = "æ•°æ®ä¸è¶³ï¼Œæ— æ³•è¿›è¡ŒæŠ€æœ¯åˆ†æ"
        if daily_df is not None and not daily_df.empty:
            try:
                trend_result = self.trend_analyzer.analyze(daily_df, code)
                if quote.price:
                    trend_result.current_price = quote.price
                tech_report = self.trend_analyzer.format_analysis(trend_result)
            except Exception as e:
                logger.error(f"[{code}] æŠ€æœ¯åˆ†æç”Ÿæˆå¤±è´¥: {e}")

        # ç­¹ç æ•°æ®
        chip_data = {}
        if getattr(self.config, 'enable_chip_distribution', False):
            if hasattr(self.fetcher_manager, '_chip_cache') and code in self.fetcher_manager._chip_cache:
                chip_data = self.fetcher_manager._chip_cache[code].to_dict()
        
        # F10 åŸºæœ¬é¢æ•°æ®
        fundamental_data = {}
        try:
            fundamental_data = get_fundamental_data(code)
        except Exception as e:
            pass

        # å†å²è®°å¿†
        history_summary = None
        try:
            history_summary = self.storage.get_last_analysis_summary(code)
        except Exception as e:
            pass

        context = {
            'code': code,
            'stock_name': stock_name,
            'price': quote.price,
            'realtime': quote.to_dict(),
            'chip': chip_data,
            'technical_analysis_report': tech_report,
            'fundamental': fundamental_data,
            'history_summary': history_summary
        }
        return context

    def process_single_stock(self, code: str, skip_analysis: bool = False, single_stock_notify: bool = False, report_type: ReportType = ReportType.SIMPLE, skip_data_fetch: bool = False) -> Optional[AnalysisResult]:
        """å¤„ç†å•åªè‚¡ç¥¨çš„æ ¸å¿ƒé€»è¾‘"""
        try:
            context = self._prepare_stock_context(code)
            if not context: return None
            stock_name = context['stock_name']
            
            if skip_analysis:
                logger.info(f"[{code}] Dry-run æ¨¡å¼ï¼Œè·³è¿‡ AI åˆ†æ")
                return AnalysisResult(code=code, name=stock_name, reasoning="Dry Run æµ‹è¯•", operation_advice="è§‚æœ›", sentiment_score=50, trend_prediction="æµ‹è¯•", success=True)

            # === 1. æœç´¢èˆ†æƒ… (å¢åŠ éšæœºå»¶è¿Ÿé˜²å°å·) ===
            search_content = ""
            if self.search_service:
                # éšæœºä¼‘çœ  2.0 - 5.0 ç§’
                sleep_time = random.uniform(2.0, 5.0)
                time.sleep(sleep_time)
                
                logger.info(f"ğŸ” [{stock_name}] æ­£åœ¨ä¾¦æŸ¥èˆ†æƒ… (å»¶è¿Ÿ {sleep_time:.1f}s)...")
                try:
                    # å…¼å®¹ä¸åŒæ¥å£è°ƒç”¨æ–¹å¼
                    if hasattr(self.search_service, 'search_stock_news'):
                        resp = self.search_service.search_stock_news(code, stock_name)
                    else:
                        query = f"{stock_name} ({code}) è¿‘æœŸé‡å¤§åˆ©å¥½åˆ©ç©ºæ¶ˆæ¯ æœºæ„è§‚ç‚¹ ç ”æŠ¥"
                        resp = self.search_service.search(query)
                        
                    if resp and getattr(resp, 'success', False): 
                        search_content = resp.to_context()
                except Exception as e:
                    logger.warning(f"[{stock_name}] æœç´¢æœåŠ¡å¼‚å¸¸: {e}")

            # === 2. è·å–å¤§ç›˜ç¯å¢ƒ ===
            market_overview = None
            if market_monitor:
                try:
                    snapshot = market_monitor.get_market_snapshot()
                    if snapshot.get('success'):
                        vol = snapshot.get('total_volume', 'N/A')
                        indices = snapshot.get('indices', [])
                        # æ ¼å¼åŒ–: "ä¸Šè¯æŒ‡æ•° +1.2% / æ·±è¯æˆæŒ‡ -0.5%"
                        idx_str = " / ".join([f"{i['name']} {i['change_pct']}%" for i in indices])
                        market_overview = f"ä»Šæ—¥ä¸¤å¸‚æˆäº¤é¢: {vol}äº¿ã€‚æŒ‡æ•°è¡¨ç°: {idx_str}ã€‚"
                except Exception as e:
                    logger.warning(f"[{stock_name}] è·å–å¤§ç›˜æ•°æ®å¾®ç‘•: {e}")

            logger.info(f"ğŸ¤– [{stock_name}] è°ƒç”¨ LLM è¿›è¡Œåˆ†æ...")
            
            # === 3. æ‰§è¡Œåˆ†æ ===
            result = self.analyzer.analyze(
                context=context, 
                news_context=search_content, 
                role="trader",
                market_overview=market_overview 
            )
            
            if not result: return None
            logger.info(f"\n[åˆ†æå®Œæˆ] {stock_name}: å»ºè®®-{result.operation_advice}, è¯„åˆ†-{result.sentiment_score}")
            
            try:
                self.storage.save_analysis_history(result=result, query_id=self.query_id, report_type=report_type.value if hasattr(report_type, 'value') else str(report_type), news_content=search_content, context_snapshot=context if self.save_context_snapshot else None)
            except Exception as e:
                logger.error(f"ä¿å­˜åˆ†æå†å²å¤±è´¥: {e}")
            
            if single_stock_notify and self.notifier.is_available():
                try:
                    report = self.notifier.generate_single_stock_report(result)
                    self.notifier.send(report)
                except Exception as e:
                    logger.warning(f"[{code}] æ¨é€å¤±è´¥: {e}")
            return result
        except Exception as e:
            logger.exception(f"[{code}] å¤„ç†è¿‡ç¨‹ä¸­å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
            return None

    def _send_notifications(self, results: List[AnalysisResult]):
        logger.info("æ­£åœ¨ç”Ÿæˆæ±‡æ€»æ—¥æŠ¥...")
        try:
            daily_report = self.notifier.generate_dashboard_report(results)
            self.notifier.send(daily_report)
            self.notifier.save_report_to_file(daily_report)
        except Exception as e:
            logger.error(f"æ±‡æ€»æ¨é€å¤±è´¥: {e}")

    def run(self, stock_codes: Optional[List[str]] = None, dry_run: bool = False, send_notification: bool = True) -> List[AnalysisResult]:
        """
        ä¸»æ‰§è¡Œå…¥å£ (ç”± main.py è°ƒç”¨)
        """
        start_time = time.time()
        if stock_codes is None:
            self.config.refresh_stock_list()
            stock_codes = self.config.stock_list
        if not stock_codes:
            logger.error("æœªé…ç½®è‡ªé€‰è‚¡åˆ—è¡¨")
            return []
        
        total_stocks = len(stock_codes)
        logger.info(f"===== å¯åŠ¨åˆ†æä»»åŠ¡: å…± {total_stocks} åªè‚¡ç¥¨ =====")

        # === é˜¶æ®µä¸€ï¼šä¸²è¡Œè·å–æ•°æ® ===
        logger.info("ğŸ¢ é˜¶æ®µä¸€ï¼šä¸²è¡Œè·å–æ•°æ® (é˜²å°æ§ & é¢„åŠ è½½)...")
        valid_stocks = [] 
        
        for i, code in enumerate(stock_codes):
            try:
                success, msg = self.fetch_and_save_stock_data(code)
                
                # å°è¯•é¢„å–ç­¹ç æ•°æ®ï¼ˆé¿å¼€äº¤æ˜“é«˜å³°ï¼‰
                try:
                    import datetime
                    now = datetime.datetime.now()
                    # ç®€å•åˆ¤æ–­éäº¤æ˜“æ—¶é—´æ‰å¤§é‡é¢„å–
                    is_trading = ((now.hour == 9 and now.minute >= 15) or (9 < now.hour < 15))
                    if not is_trading:
                        if hasattr(self.fetcher_manager, 'get_chip_distribution'):
                            self.fetcher_manager.get_chip_distribution(code)
                except Exception:
                    pass 

                if success:
                    valid_stocks.append(code)
                    logger.info(f"[{i+1}/{total_stocks}] âœ… {code} æ•°æ®å°±ç»ª")
                    # ä¸²è¡Œé˜¶æ®µä¹Ÿç¨å¾®ä¼‘æ¯ä¸€ä¸‹ï¼Œé˜²æ­¢æ•°æ®æºå°IP
                    if not dry_run:
                        time.sleep(0.5)
                else:
                    logger.warning(f"[{i+1}/{total_stocks}] âŒ {code} æ•°æ®å¤±è´¥: {msg}")
                
            except Exception as e:
                logger.error(f"[{code}] æ•°æ®é¢„å–å¼‚å¸¸: {e}")

        # === é˜¶æ®µäºŒï¼šå¹¶å‘åˆ†æ ===
        logger.info(f"ğŸ° é˜¶æ®µäºŒï¼šå¼€å¯ {self.max_workers} çº¿ç¨‹è¿›è¡Œ AI å¹¶å‘åˆ†æ...")
        single_stock_notify = getattr(self.config, 'single_stock_notify', False)
        report_type = ReportType.FULL if getattr(self.config, 'report_type', 'simple') == 'full' else ReportType.SIMPLE
        results: List[AnalysisResult] = []
        
        if not valid_stocks:
            logger.error("æ²¡æœ‰è·å–åˆ°ä»»ä½•æœ‰æ•ˆæ•°æ®ï¼Œç»ˆæ­¢åˆ†æ")
            return []

        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            future_to_code = {
                executor.submit(
                    self.process_single_stock, 
                    code, 
                    skip_analysis=dry_run, 
                    single_stock_notify=single_stock_notify and send_notification, 
                    report_type=report_type, 
                    skip_data_fetch=True
                ): code for code in valid_stocks
            }
            
            for future in as_completed(future_to_code):
                code = future_to_code[future]
                try:
                    res = future.result()
                    if res: results.append(res)
                except Exception as e:
                    logger.error(f"[{code}] AI åˆ†æä»»åŠ¡å¤±è´¥: {e}")
        
        logger.info(f"===== åˆ†æå®Œæˆï¼Œæ€»è€—æ—¶ {time.time() - start_time:.2f}s =====")
        
        # æ±‡æ€»æ¨é€ (å¦‚æœæ²¡å¼€å•è‚¡æ¨é€)
        if results and send_notification and not dry_run and not single_stock_notify:
            self._send_notifications(results)
            
        return results
--------------------

#File: src/core/pipeline_å‰¯æœ¬.py
--------------------
# -*- coding: utf-8 -*-
import logging
import time
import random
from typing import List, Dict, Optional, Any
from concurrent.futures import ThreadPoolExecutor, as_completed

# === æ ¸å¿ƒä¿®æ”¹ï¼šæ ¹æ®æ‚¨çš„ç›®å½•ç»“æ„ä¿®æ­£å¯¼å…¥è·¯å¾„ ===
try:
    # data_provider åœ¨æ ¹ç›®å½•ï¼Œç›´æ¥å¯¼å…¥
    from data_provider import DataFetcherManager
except ImportError:
    # å¤‡ç”¨ï¼šå°è¯•ä» base æ–‡ä»¶å¯¼å…¥
    try:
        from data_provider.base import DataFetcherManager
    except ImportError:
        # å¦‚æœè¿˜åœ¨æŠ¥é”™ï¼Œè¯´æ˜ç¯å¢ƒè·¯å¾„å¯èƒ½æ²¡è®¾ç½®å¯¹ï¼Œå°è¯•ç›¸å¯¹å¯¼å…¥
        from ...data_provider.base import DataFetcherManager

# å°è¯•å¯¼å…¥ F10 æ•°æ®è·å–å™¨
try:
    from data_provider.fundamental_fetcher import get_fundamental_data
except ImportError:
    logging.getLogger(__name__).warning("âš ï¸ æœªæ‰¾åˆ° fundamental_fetcherï¼Œå°†è·³è¿‡F10æ•°æ® (ä¸å½±å“ä¸»æµç¨‹)")
    def get_fundamental_data(code): return {}

# === æ–°å¢ï¼šå¯¼å…¥å¤§ç›˜ç›‘æ§æ¨¡å— ===
try:
    from data_provider.market_monitor import market_monitor
except ImportError:
    market_monitor = None
    logging.getLogger(__name__).warning("âš ï¸ æœªæ‰¾åˆ° market_monitorï¼Œå°†è·³è¿‡å¤§ç›˜ç¯å¢ƒæ„ŸçŸ¥")

from src.stock_analyzer import StockTrendAnalyzer
from src.analyzer import GeminiAnalyzer, AnalysisResult
from src.notification import NotificationService
from src.storage import DatabaseManager  
from src.search_service import SearchService
from src.enums import ReportType

logger = logging.getLogger(__name__)

class StockAnalysisPipeline:
    """
    è‚¡ç¥¨åˆ†ææµæ°´çº¿ (è·¯å¾„ä¿®å¤ç‰ˆ)
    """
    def __init__(self, config, max_workers=3, query_id=None, query_source="cli", save_context_snapshot=True, source_message=None):
        self.config = config
        self.max_workers = max_workers
        self.query_id = query_id
        self.query_source = query_source
        self.save_context_snapshot = save_context_snapshot
        self.source_message = source_message
        
        self.fetcher_manager = DataFetcherManager()
        self.trend_analyzer = StockTrendAnalyzer()
        self.analyzer = GeminiAnalyzer(api_key=config.gemini_api_key)
        self.notifier = NotificationService(source_message=source_message)
        self.storage = DatabaseManager() 
        
        self.search_service = None
        if config.bocha_api_keys or config.tavily_api_keys or config.serpapi_keys or config.gemini_api_key:
            self.search_service = SearchService(
                bocha_keys=config.bocha_api_keys,
                tavily_keys=config.tavily_api_keys,
                serpapi_keys=config.serpapi_keys
            )

    def fetch_and_save_stock_data(self, code: str) -> (bool, str):
        try:
            df = self.fetcher_manager.get_merged_data(code, days=120)
            if df is None or df.empty:
                return False, "è·å–æ•°æ®ä¸ºç©º"
            quote = self.fetcher_manager.get_realtime_quote(code)
            if not quote:
                return False, "å®æ—¶è¡Œæƒ…è·å–å¤±è´¥"
            return True, "Success"
        except Exception as e:
            return False, str(e)

    def _prepare_stock_context(self, code: str) -> Optional[Dict[str, Any]]:
        quote = self.fetcher_manager.get_realtime_quote(code)
        if not quote:
            logger.warning(f"[{code}] æ— æ³•è·å–å®æ—¶è¡Œæƒ…ï¼Œè·³è¿‡")
            return None
        stock_name = quote.name
        
        try:
            daily_df = self.fetcher_manager.get_merged_data(code, days=120)
        except Exception as e:
            logger.warning(f"[{code}] è·å–åˆå¹¶æ•°æ®å¤±è´¥: {e}")
            daily_df = None

        tech_report = "æ•°æ®ä¸è¶³ï¼Œæ— æ³•è¿›è¡ŒæŠ€æœ¯åˆ†æ"
        if daily_df is not None and not daily_df.empty:
            try:
                trend_result = self.trend_analyzer.analyze(daily_df, code)
                if quote.price:
                    trend_result.current_price = quote.price
                tech_report = self.trend_analyzer.format_analysis(trend_result)
            except Exception as e:
                logger.error(f"[{code}] æŠ€æœ¯åˆ†æç”Ÿæˆå¤±è´¥: {e}")

        chip_data = {}
        if self.config.enable_chip_distribution:
            if code in self.fetcher_manager._chip_cache:
                chip_data = self.fetcher_manager._chip_cache[code].to_dict()
        
        # === F10 åŸºæœ¬é¢æ•°æ® ===
        fundamental_data = {}
        try:
            fundamental_data = get_fundamental_data(code)
        except Exception as e:
            logger.debug(f"[{code}] F10 æ•°æ®è·å–å¼‚å¸¸ (å·²å¿½ç•¥): {e}")

        # === å†å²è®°å¿† ===
        history_summary = None
        try:
            history_summary = self.storage.get_last_analysis_summary(code)
        except Exception as e:
            logger.debug(f"[{code}] å†å²è®°å¿†è·å–å¼‚å¸¸: {e}")

        context = {
            'code': code,
            'stock_name': stock_name,
            'price': quote.price,
            'realtime': quote.to_dict(),
            'chip': chip_data,
            'technical_analysis_report': tech_report,
            'fundamental': fundamental_data,
            'history_summary': history_summary
        }
        return context

    def process_single_stock(self, code: str, skip_analysis: bool = False, single_stock_notify: bool = False, report_type: ReportType = ReportType.SIMPLE, skip_data_fetch: bool = False) -> Optional[AnalysisResult]:
        try:
            logger.info(f"========== å¼€å§‹åˆ†æ {code} (Thread) ==========")
            context = self._prepare_stock_context(code)
            if not context: return None
            stock_name = context['stock_name']
            
            if skip_analysis:
                logger.info(f"[{code}] Dry-run æ¨¡å¼ï¼Œè·³è¿‡ AI åˆ†æ")
                return AnalysisResult(code=code, name=stock_name, reasoning="Dry Run æµ‹è¯•", operation_advice="è§‚æœ›", sentiment_score=50, trend_prediction="æµ‹è¯•", success=True)

            # 1. æœç´¢èˆ†æƒ…
            search_content = ""
            if self.search_service and self.search_service.is_available:
                logger.info(f"ğŸ” [{stock_name}] æ­£åœ¨è¿›è¡Œå…¨ç½‘èˆ†æƒ…æœç´¢...")
                try:
                    resp = self.search_service.search_stock_news(code, stock_name)
                    if resp.success: search_content = resp.to_context()
                except Exception as e:
                    logger.warning(f"[{stock_name}] æœç´¢æœåŠ¡å¼‚å¸¸: {e}")

            # 2. è·å–å¤§ç›˜ç¯å¢ƒ (æ–°å¢)
            market_overview = None
            if market_monitor:
                try:
                    # å°è¯•è·å–å¤§ç›˜å¿«ç…§
                    snapshot = market_monitor.get_market_snapshot()
                    if snapshot.get('success'):
                        vol = snapshot.get('total_volume', 'N/A')
                        indices = snapshot.get('indices', [])
                        # æ ¼å¼åŒ–: "ä¸Šè¯æŒ‡æ•° +1.2%, æ·±è¯æˆæŒ‡ -0.5%"
                        idx_str = " / ".join([f"{i['name']} {i['change_pct']}%" for i in indices])
                        market_overview = f"ä»Šæ—¥ä¸¤å¸‚æˆäº¤é¢: {vol}äº¿ã€‚æŒ‡æ•°è¡¨ç°: {idx_str}ã€‚"
                except Exception as e:
                    logger.warning(f"[{stock_name}] è·å–å¤§ç›˜æ•°æ®å¾®ç‘•: {e}")

            logger.info(f"ğŸ¤– [{stock_name}] è°ƒç”¨ LLM è¿›è¡Œåˆ†æ...")
            
            # 3. æ‰§è¡Œåˆ†æ (ä¼ å…¥ market_overview)
            # ä½¿ç”¨é»˜è®¤è§’è‰² 'trader'
            result = self.analyzer.analyze(
                context=context, 
                news_context=search_content, 
                role="trader",
                market_overview=market_overview  # <--- æ³¨å…¥å¤§ç›˜ä¿¡æ¯
            )
            
            if not result: return None
            logger.info(f"\n[åˆ†æå®Œæˆ] {stock_name}: å»ºè®®-{result.operation_advice}, è¯„åˆ†-{result.sentiment_score}")
            
            try:
                self.storage.save_analysis_history(result=result, query_id=self.query_id, report_type=report_type.value if hasattr(report_type, 'value') else str(report_type), news_content=search_content, context_snapshot=context if self.save_context_snapshot else None)
            except Exception as e:
                logger.error(f"ä¿å­˜åˆ†æå†å²å¤±è´¥: {e}")
            
            if single_stock_notify and self.notifier.is_available():
                try:
                    report = self.notifier.generate_single_stock_report(result)
                    self.notifier.send(report)
                except Exception as e:
                    logger.warning(f"[{code}] æ¨é€å¤±è´¥: {e}")
            return result
        except Exception as e:
            logger.exception(f"[{code}] å¤„ç†è¿‡ç¨‹ä¸­å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
            return None

    def _send_notifications(self, results: List[AnalysisResult]):
        logger.info("æ­£åœ¨ç”Ÿæˆæ±‡æ€»æ—¥æŠ¥...")
        try:
            daily_report = self.notifier.generate_dashboard_report(results)
            self.notifier.send(daily_report)
            self.notifier.save_report_to_file(daily_report)
        except Exception as e:
            logger.error(f"æ±‡æ€»æ¨é€å¤±è´¥: {e}")

    def run(self, stock_codes: Optional[List[str]] = None, dry_run: bool = False, send_notification: bool = True) -> List[AnalysisResult]:
        start_time = time.time()
        if stock_codes is None:
            self.config.refresh_stock_list()
            stock_codes = self.config.stock_list
        if not stock_codes:
            logger.error("æœªé…ç½®è‡ªé€‰è‚¡åˆ—è¡¨")
            return []
        
        total_stocks = len(stock_codes)
        logger.info(f"===== å¯åŠ¨åˆ†æä»»åŠ¡: å…± {total_stocks} åªè‚¡ç¥¨ =====")

        # === é˜¶æ®µä¸€ï¼šä¸²è¡Œè·å–æ•°æ® ===
        logger.info("ğŸ¢ é˜¶æ®µä¸€ï¼šä¸²è¡Œè·å–æ•°æ® (é˜²å°æ§ & é¢„åŠ è½½JSå¼•æ“)...")
        valid_stocks = [] 
        
        for i, code in enumerate(stock_codes):
            try:
                success, msg = self.fetch_and_save_stock_data(code)
                
                try:
                    import datetime
                    now = datetime.datetime.now()
                    is_trading_time = ((now.hour == 9 and now.minute >= 15) or (9 < now.hour < 15) or (now.hour == 15 and now.minute <= 30))
                    
                    if not is_trading_time:
                        logger.info(f"[{i+1}/{total_stocks}] æ­£åœ¨é¢„å– {code} ç­¹ç æ•°æ®...")
                        if hasattr(self, 'fetcher_manager'):
                            self.fetcher_manager.get_chip_distribution(code)
                except Exception:
                    pass 

                if success:
                    valid_stocks.append(code)
                    logger.info(f"[{i+1}/{total_stocks}] âœ… {code} æ•°æ®å®Œå…¨å°±ç»ª")
                    if not dry_run:
                        time.sleep(random.uniform(1.5, 3.0)) 
                else:
                    logger.warning(f"[{i+1}/{total_stocks}] âŒ {code} æ•°æ®è·å–å¤±è´¥: {msg}")
                    time.sleep(2.0)
                
            except Exception as e:
                logger.error(f"[{code}] æ•°æ®é¢„å–å¼‚å¸¸: {e}")

        # === é˜¶æ®µäºŒï¼šå¹¶å‘åˆ†æ ===
        logger.info(f"ğŸ° é˜¶æ®µäºŒï¼šå¼€å¯ {self.max_workers} çº¿ç¨‹è¿›è¡Œ AI å¹¶å‘åˆ†æ...")
        single_stock_notify = getattr(self.config, 'single_stock_notify', False)
        report_type = ReportType.FULL if getattr(self.config, 'report_type', 'simple') == 'full' else ReportType.SIMPLE
        results: List[AnalysisResult] = []
        
        if not valid_stocks:
            logger.error("æ²¡æœ‰è·å–åˆ°ä»»ä½•æœ‰æ•ˆæ•°æ®ï¼Œç»ˆæ­¢åˆ†æ")
            return []

        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            future_to_code = {executor.submit(self.process_single_stock, code, skip_analysis=dry_run, single_stock_notify=single_stock_notify and send_notification, report_type=report_type, skip_data_fetch=True): code for code in valid_stocks}
            for future in as_completed(future_to_code):
                code = future_to_code[future]
                try:
                    res = future.result()
                    if res: results.append(res)
                except Exception as e:
                    logger.error(f"[{code}] AI åˆ†æä»»åŠ¡å¤±è´¥: {e}")
        
        logger.info(f"===== åˆ†æå®Œæˆï¼Œæ€»è€—æ—¶ {time.time() - start_time:.2f}s =====")
        if results and send_notification and not dry_run and not single_stock_notify:
            self._send_notifications(results)
        return results
--------------------

#File: bot/dispatcher.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
å‘½ä»¤åˆ†å‘å™¨
===================================

è´Ÿè´£è§£æå‘½ä»¤ã€åŒ¹é…å¤„ç†å™¨ã€åˆ†å‘æ‰§è¡Œã€‚
"""

import logging
import time
from collections import defaultdict
from typing import Dict, List, Optional, Type, Callable

from bot.models import BotMessage, BotResponse
from bot.commands.base import BotCommand

logger = logging.getLogger(__name__)


class RateLimiter:
    """
    ç®€å•çš„é¢‘ç‡é™åˆ¶å™¨
    
    åŸºäºæ»‘åŠ¨çª—å£ç®—æ³•ï¼Œé™åˆ¶æ¯ä¸ªç”¨æˆ·çš„è¯·æ±‚é¢‘ç‡ã€‚
    """
    
    def __init__(self, max_requests: int = 10, window_seconds: int = 60):
        """
        Args:
            max_requests: çª—å£å†…æœ€å¤§è¯·æ±‚æ•°
            window_seconds: çª—å£æ—¶é—´ï¼ˆç§’ï¼‰
        """
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self._requests: Dict[str, List[float]] = defaultdict(list)
    
    def is_allowed(self, user_id: str) -> bool:
        """
        æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…è®¸è¯·æ±‚
        
        Args:
            user_id: ç”¨æˆ·æ ‡è¯†
            
        Returns:
            æ˜¯å¦å…è®¸
        """
        now = time.time()
        window_start = now - self.window_seconds
        
        # æ¸…ç†è¿‡æœŸè®°å½•
        self._requests[user_id] = [
            t for t in self._requests[user_id] 
            if t > window_start
        ]
        
        # æ£€æŸ¥æ˜¯å¦è¶…é™
        if len(self._requests[user_id]) >= self.max_requests:
            return False
        
        # è®°å½•æœ¬æ¬¡è¯·æ±‚
        self._requests[user_id].append(now)
        return True
    
    def get_remaining(self, user_id: str) -> int:
        """è·å–å‰©ä½™å¯ç”¨è¯·æ±‚æ•°"""
        now = time.time()
        window_start = now - self.window_seconds
        
        # æ¸…ç†è¿‡æœŸè®°å½•
        self._requests[user_id] = [
            t for t in self._requests[user_id] 
            if t > window_start
        ]
        
        return max(0, self.max_requests - len(self._requests[user_id]))


class CommandDispatcher:
    """
    å‘½ä»¤åˆ†å‘å™¨
    
    èŒè´£ï¼š
    1. æ³¨å†Œå’Œç®¡ç†å‘½ä»¤å¤„ç†å™¨
    2. è§£ææ¶ˆæ¯ä¸­çš„å‘½ä»¤å’Œå‚æ•°
    3. åˆ†å‘å‘½ä»¤åˆ°å¯¹åº”å¤„ç†å™¨
    4. å¤„ç†æœªçŸ¥å‘½ä»¤å’Œé”™è¯¯
    
    ä½¿ç”¨ç¤ºä¾‹ï¼š
        dispatcher = CommandDispatcher()
        dispatcher.register(AnalyzeCommand())
        dispatcher.register(HelpCommand())
        
        response = dispatcher.dispatch(message)
    """
    
    def __init__(
        self, 
        command_prefix: str = "/",
        rate_limit_requests: int = 10,
        rate_limit_window: int = 60,
        admin_users: Optional[List[str]] = None
    ):
        """
        Args:
            command_prefix: å‘½ä»¤å‰ç¼€ï¼Œé»˜è®¤ "/"
            rate_limit_requests: é¢‘ç‡é™åˆ¶ï¼šçª—å£å†…æœ€å¤§è¯·æ±‚æ•°
            rate_limit_window: é¢‘ç‡é™åˆ¶ï¼šçª—å£æ—¶é—´ï¼ˆç§’ï¼‰
            admin_users: ç®¡ç†å‘˜ç”¨æˆ· ID åˆ—è¡¨
        """
        self.command_prefix = command_prefix
        self.admin_users = set(admin_users or [])
        
        self._commands: Dict[str, BotCommand] = {}
        self._aliases: Dict[str, str] = {}
        self._rate_limiter = RateLimiter(rate_limit_requests, rate_limit_window)
        
        # å›è°ƒå‡½æ•°ï¼šè·å–å¸®åŠ©å‘½ä»¤çš„å‘½ä»¤åˆ—è¡¨
        self._help_command_getter: Optional[Callable] = None
    
    def register(self, command: BotCommand) -> None:
        """
        æ³¨å†Œå‘½ä»¤
        
        Args:
            command: å‘½ä»¤å®ä¾‹
        """
        name = command.name.lower()
        
        if name in self._commands:
            logger.warning(f"[Dispatcher] å‘½ä»¤ '{name}' å·²å­˜åœ¨ï¼Œå°†è¢«è¦†ç›–")
        
        self._commands[name] = command
        logger.debug(f"[Dispatcher] æ³¨å†Œå‘½ä»¤: {name}")
        
        # æ³¨å†Œåˆ«å
        for alias in command.aliases:
            alias_lower = alias.lower()
            if alias_lower in self._aliases:
                logger.warning(f"[Dispatcher] åˆ«å '{alias_lower}' å·²å­˜åœ¨ï¼Œå°†è¢«è¦†ç›–")
            self._aliases[alias_lower] = name
            logger.debug(f"[Dispatcher] æ³¨å†Œåˆ«å: {alias_lower} -> {name}")
    
    def register_class(self, command_class: Type[BotCommand]) -> None:
        """
        æ³¨å†Œå‘½ä»¤ç±»ï¼ˆè‡ªåŠ¨å®ä¾‹åŒ–ï¼‰
        
        Args:
            command_class: å‘½ä»¤ç±»
        """
        self.register(command_class())
    
    def unregister(self, name: str) -> bool:
        """
        æ³¨é”€å‘½ä»¤
        
        Args:
            name: å‘½ä»¤åç§°
            
        Returns:
            æ˜¯å¦æˆåŠŸæ³¨é”€
        """
        name = name.lower()
        
        if name not in self._commands:
            return False
        
        command = self._commands.pop(name)
        
        # ç§»é™¤åˆ«å
        for alias in command.aliases:
            self._aliases.pop(alias.lower(), None)
        
        logger.debug(f"[Dispatcher] æ³¨é”€å‘½ä»¤: {name}")
        return True
    
    def get_command(self, name: str) -> Optional[BotCommand]:
        """
        è·å–å‘½ä»¤
        
        æ”¯æŒå‘½ä»¤åå’Œåˆ«åæŸ¥è¯¢ã€‚
        
        Args:
            name: å‘½ä»¤åæˆ–åˆ«å
            
        Returns:
            å‘½ä»¤å®ä¾‹ï¼Œæˆ– None
        """
        name = name.lower()
        
        # å…ˆæŸ¥å‘½ä»¤å
        if name in self._commands:
            return self._commands[name]
        
        # å†æŸ¥åˆ«å
        if name in self._aliases:
            return self._commands.get(self._aliases[name])
        
        return None
    
    def list_commands(self, include_hidden: bool = False) -> List[BotCommand]:
        """
        åˆ—å‡ºæ‰€æœ‰å‘½ä»¤
        
        Args:
            include_hidden: æ˜¯å¦åŒ…å«éšè—å‘½ä»¤
            
        Returns:
            å‘½ä»¤åˆ—è¡¨
        """
        commands = list(self._commands.values())
        
        if not include_hidden:
            commands = [c for c in commands if not c.hidden]
        
        return sorted(commands, key=lambda c: c.name)
    
    def is_admin(self, user_id: str) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ˜¯ç®¡ç†å‘˜"""
        return user_id in self.admin_users
    
    def add_admin(self, user_id: str) -> None:
        """æ·»åŠ ç®¡ç†å‘˜"""
        self.admin_users.add(user_id)
    
    def remove_admin(self, user_id: str) -> None:
        """ç§»é™¤ç®¡ç†å‘˜"""
        self.admin_users.discard(user_id)
    
    def dispatch(self, message: BotMessage) -> BotResponse:
        """
        åˆ†å‘æ¶ˆæ¯åˆ°å¯¹åº”å‘½ä»¤
        
        Args:
            message: æ¶ˆæ¯å¯¹è±¡
            
        Returns:
            å“åº”å¯¹è±¡
        """
        # 1. æ£€æŸ¥é¢‘ç‡é™åˆ¶
        if not self._rate_limiter.is_allowed(message.user_id):
            remaining_time = self._rate_limiter.window_seconds
            return BotResponse.error_response(
                f"è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯· {remaining_time} ç§’åå†è¯•"
            )
        
        # 2. è§£æå‘½ä»¤å’Œå‚æ•°
        cmd_name, args = message.get_command_and_args(self.command_prefix)
        
        if cmd_name is None:
            # ä¸æ˜¯å‘½ä»¤ï¼Œæ£€æŸ¥æ˜¯å¦ @äº†æœºå™¨äºº
            if message.mentioned:
                return BotResponse.text_response(
                    "ä½ å¥½ï¼æˆ‘æ˜¯è‚¡ç¥¨åˆ†æåŠ©æ‰‹ã€‚\n"
                    f"å‘é€ `{self.command_prefix}help` æŸ¥çœ‹å¯ç”¨å‘½ä»¤ã€‚"
                )
            # éå‘½ä»¤æ¶ˆæ¯ï¼Œä¸å¤„ç†
            return BotResponse.text_response("")
        
        logger.info(f"[Dispatcher] æ”¶åˆ°å‘½ä»¤: {cmd_name}, å‚æ•°: {args}, ç”¨æˆ·: {message.user_name}")
        
        # 3. æŸ¥æ‰¾å‘½ä»¤å¤„ç†å™¨
        command = self.get_command(cmd_name)
        
        if command is None:
            return BotResponse.error_response(
                f"æœªçŸ¥å‘½ä»¤: {cmd_name}\n"
                f"å‘é€ `{self.command_prefix}help` æŸ¥çœ‹å¯ç”¨å‘½ä»¤ã€‚"
            )
        
        # 4. æ£€æŸ¥æƒé™
        if command.admin_only and not self.is_admin(message.user_id):
            return BotResponse.error_response("æ­¤å‘½ä»¤éœ€è¦ç®¡ç†å‘˜æƒé™")
        
        # 5. éªŒè¯å‚æ•°
        error_msg = command.validate_args(args)
        if error_msg:
            return BotResponse.error_response(
                f"{error_msg}\nç”¨æ³•: `{command.usage}`"
            )
        
        # 6. æ‰§è¡Œå‘½ä»¤
        try:
            response = command.execute(message, args)
            logger.info(f"[Dispatcher] å‘½ä»¤ {cmd_name} æ‰§è¡ŒæˆåŠŸ")
            return response
        except Exception as e:
            logger.error(f"[Dispatcher] å‘½ä»¤ {cmd_name} æ‰§è¡Œå¤±è´¥: {e}")
            logger.exception(e)
            return BotResponse.error_response(f"å‘½ä»¤æ‰§è¡Œå¤±è´¥: {str(e)[:100]}")
    
    def set_help_command_getter(self, getter: Callable) -> None:
        """
        è®¾ç½®å¸®åŠ©å‘½ä»¤çš„å‘½ä»¤åˆ—è¡¨è·å–å™¨
        
        ç”¨äºè®© HelpCommand è·å–å‘½ä»¤åˆ—è¡¨ã€‚
        
        Args:
            getter: å›è°ƒå‡½æ•°ï¼Œè¿”å›å‘½ä»¤åˆ—è¡¨
        """
        self._help_command_getter = getter


# å…¨å±€åˆ†å‘å™¨å®ä¾‹
_dispatcher: Optional[CommandDispatcher] = None


def get_dispatcher() -> CommandDispatcher:
    """
    è·å–å…¨å±€åˆ†å‘å™¨å®ä¾‹
    
    ä½¿ç”¨å•ä¾‹æ¨¡å¼ï¼Œé¦–æ¬¡è°ƒç”¨æ—¶è‡ªåŠ¨åˆå§‹åŒ–å¹¶æ³¨å†Œæ‰€æœ‰å‘½ä»¤ã€‚
    """
    global _dispatcher
    
    if _dispatcher is None:
        from src.config import get_config
        
        config = get_config()
        
        # åˆ›å»ºåˆ†å‘å™¨
        _dispatcher = CommandDispatcher(
            command_prefix=getattr(config, 'bot_command_prefix', '/'),
            rate_limit_requests=getattr(config, 'bot_rate_limit_requests', 10),
            rate_limit_window=getattr(config, 'bot_rate_limit_window', 60),
            admin_users=getattr(config, 'bot_admin_users', []),
        )
        
        # è‡ªåŠ¨æ³¨å†Œæ‰€æœ‰å‘½ä»¤
        from bot.commands import ALL_COMMANDS
        for command_class in ALL_COMMANDS:
            _dispatcher.register_class(command_class)
        
        logger.info(f"[Dispatcher] åˆå§‹åŒ–å®Œæˆï¼Œå·²æ³¨å†Œ {len(_dispatcher._commands)} ä¸ªå‘½ä»¤")
    
    return _dispatcher


def reset_dispatcher() -> None:
    """é‡ç½®å…¨å±€åˆ†å‘å™¨ï¼ˆä¸»è¦ç”¨äºæµ‹è¯•ï¼‰"""
    global _dispatcher
    _dispatcher = None

--------------------

#File: bot/handler.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Bot Webhook å¤„ç†å™¨
===================================

å¤„ç†å„å¹³å°çš„ Webhook å›è°ƒï¼Œåˆ†å‘åˆ°å‘½ä»¤å¤„ç†å™¨ã€‚
"""

import json
import logging
from typing import Dict, Any, Optional, TYPE_CHECKING

from bot.models import WebhookResponse
from bot.dispatcher import get_dispatcher
from bot.platforms import ALL_PLATFORMS

if TYPE_CHECKING:
    from bot.platforms.base import BotPlatform

logger = logging.getLogger(__name__)

# å¹³å°å®ä¾‹ç¼“å­˜
_platform_instances: Dict[str, 'BotPlatform'] = {}


def get_platform(platform_name: str) -> Optional['BotPlatform']:
    """
    è·å–å¹³å°é€‚é…å™¨å®ä¾‹
    
    ä½¿ç”¨ç¼“å­˜é¿å…é‡å¤åˆ›å»ºã€‚
    
    Args:
        platform_name: å¹³å°åç§°
        
    Returns:
        å¹³å°é€‚é…å™¨å®ä¾‹ï¼Œæˆ– None
    """
    if platform_name not in _platform_instances:
        platform_class = ALL_PLATFORMS.get(platform_name)
        if platform_class:
            _platform_instances[platform_name] = platform_class()
        else:
            logger.warning(f"[BotHandler] æœªçŸ¥å¹³å°: {platform_name}")
            return None
    
    return _platform_instances[platform_name]


def handle_webhook(
    platform_name: str,
    headers: Dict[str, str],
    body: bytes,
    query_params: Optional[Dict[str, list]] = None
) -> WebhookResponse:
    """
    å¤„ç† Webhook è¯·æ±‚
    
    è¿™æ˜¯æ‰€æœ‰å¹³å° Webhook çš„ç»Ÿä¸€å…¥å£ã€‚
    
    Args:
        platform_name: å¹³å°åç§° (feishu, dingtalk, wecom, telegram)
        headers: HTTP è¯·æ±‚å¤´
        body: è¯·æ±‚ä½“åŸå§‹å­—èŠ‚
        query_params: URL æŸ¥è¯¢å‚æ•°ï¼ˆç”¨äºæŸäº›å¹³å°çš„éªŒè¯ï¼‰
        
    Returns:
        WebhookResponse å“åº”å¯¹è±¡
    """
    logger.info(f"[BotHandler] æ”¶åˆ° {platform_name} Webhook è¯·æ±‚")
    
    # æ£€æŸ¥æœºå™¨äººåŠŸèƒ½æ˜¯å¦å¯ç”¨
    from src.config import get_config
    config = get_config()
    
    if not getattr(config, 'bot_enabled', True):
        logger.info("[BotHandler] æœºå™¨äººåŠŸèƒ½æœªå¯ç”¨")
        return WebhookResponse.success()
    
    # è·å–å¹³å°é€‚é…å™¨
    platform = get_platform(platform_name)
    if not platform:
        return WebhookResponse.error(f"Unknown platform: {platform_name}", 400)
    
    # è§£æ JSON æ•°æ®
    try:
        data = json.loads(body.decode('utf-8')) if body else {}
    except json.JSONDecodeError as e:
        logger.error(f"[BotHandler] JSON è§£æå¤±è´¥: {e}")
        return WebhookResponse.error("Invalid JSON", 400)
    
    logger.debug(f"[BotHandler] è¯·æ±‚æ•°æ®: {json.dumps(data, ensure_ascii=False)[:500]}")
    
    # å¤„ç† Webhook
    message, challenge_response = platform.handle_webhook(headers, body, data)
    
    # å¦‚æœæ˜¯éªŒè¯è¯·æ±‚ï¼Œç›´æ¥è¿”å›éªŒè¯å“åº”
    if challenge_response:
        logger.info(f"[BotHandler] è¿”å›éªŒè¯å“åº”")
        return challenge_response
    
    # å¦‚æœæ²¡æœ‰æ¶ˆæ¯éœ€è¦å¤„ç†ï¼Œè¿”å›ç©ºå“åº”
    if not message:
        logger.debug("[BotHandler] æ— éœ€å¤„ç†çš„æ¶ˆæ¯")
        return WebhookResponse.success()
    
    logger.info(f"[BotHandler] è§£æåˆ°æ¶ˆæ¯: user={message.user_name}, content={message.content[:50]}")
    
    # åˆ†å‘åˆ°å‘½ä»¤å¤„ç†å™¨
    dispatcher = get_dispatcher()
    response = dispatcher.dispatch(message)
    
    # æ ¼å¼åŒ–å“åº”
    if response.text:
        webhook_response = platform.format_response(response, message)
        return webhook_response
    
    return WebhookResponse.success()


def handle_feishu_webhook(headers: Dict[str, str], body: bytes) -> WebhookResponse:
    """å¤„ç†é£ä¹¦ Webhook"""
    return handle_webhook('feishu', headers, body)


def handle_dingtalk_webhook(headers: Dict[str, str], body: bytes) -> WebhookResponse:
    """å¤„ç†é’‰é’‰ Webhook"""
    return handle_webhook('dingtalk', headers, body)


def handle_wecom_webhook(headers: Dict[str, str], body: bytes) -> WebhookResponse:
    """å¤„ç†ä¼ä¸šå¾®ä¿¡ Webhook"""
    return handle_webhook('wecom', headers, body)


def handle_telegram_webhook(headers: Dict[str, str], body: bytes) -> WebhookResponse:
    """å¤„ç† Telegram Webhook"""
    return handle_webhook('telegram', headers, body)

--------------------

#File: bot/models.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
æœºå™¨äººæ¶ˆæ¯æ¨¡å‹
===================================

å®šä¹‰ç»Ÿä¸€çš„æ¶ˆæ¯å’Œå“åº”æ¨¡å‹ï¼Œå±è”½å„å¹³å°å·®å¼‚ã€‚
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, Any, Optional, List


class ChatType(str, Enum):
    """ä¼šè¯ç±»å‹"""
    GROUP = "group"      # ç¾¤èŠ
    PRIVATE = "private"  # ç§èŠ
    UNKNOWN = "unknown"  # æœªçŸ¥


class Platform(str, Enum):
    """å¹³å°ç±»å‹"""
    FEISHU = "feishu"        # é£ä¹¦
    DINGTALK = "dingtalk"    # é’‰é’‰
    WECOM = "wecom"          # ä¼ä¸šå¾®ä¿¡
    TELEGRAM = "telegram"    # Telegram
    UNKNOWN = "unknown"      # æœªçŸ¥


@dataclass
class BotMessage:
    """
    ç»Ÿä¸€çš„æœºå™¨äººæ¶ˆæ¯æ¨¡å‹
    
    å°†å„å¹³å°çš„æ¶ˆæ¯æ ¼å¼ç»Ÿä¸€ä¸ºæ­¤æ¨¡å‹ï¼Œä¾¿äºå‘½ä»¤å¤„ç†å™¨å¤„ç†ã€‚
    
    Attributes:
        platform: å¹³å°æ ‡è¯†
        message_id: æ¶ˆæ¯ IDï¼ˆå¹³å°åŸå§‹ IDï¼‰
        user_id: å‘é€è€… ID
        user_name: å‘é€è€…åç§°
        chat_id: ä¼šè¯ IDï¼ˆç¾¤èŠ ID æˆ–ç§èŠ IDï¼‰
        chat_type: ä¼šè¯ç±»å‹
        content: æ¶ˆæ¯æ–‡æœ¬å†…å®¹ï¼ˆå·²å»é™¤ @æœºå™¨äºº éƒ¨åˆ†ï¼‰
        raw_content: åŸå§‹æ¶ˆæ¯å†…å®¹
        mentioned: æ˜¯å¦ @äº†æœºå™¨äºº
        mentions: @çš„ç”¨æˆ·åˆ—è¡¨
        timestamp: æ¶ˆæ¯æ—¶é—´æˆ³
        raw_data: åŸå§‹è¯·æ±‚æ•°æ®ï¼ˆå¹³å°ç‰¹å®šï¼Œç”¨äºè°ƒè¯•ï¼‰
    """
    platform: str
    message_id: str
    user_id: str
    user_name: str
    chat_id: str
    chat_type: ChatType
    content: str
    raw_content: str = ""
    mentioned: bool = False
    mentions: List[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)
    raw_data: Dict[str, Any] = field(default_factory=dict)
    
    def get_command_and_args(self, prefix: str = "/") -> tuple:
        """
        è§£æå‘½ä»¤å’Œå‚æ•°
        
        Args:
            prefix: å‘½ä»¤å‰ç¼€ï¼Œé»˜è®¤ "/"
            
        Returns:
            (command, args) å…ƒç»„ï¼Œå¦‚ ("analyze", ["600519"])
            å¦‚æœä¸æ˜¯å‘½ä»¤ï¼Œè¿”å› (None, [])
        """
        text = self.content.strip()
        
        # æ£€æŸ¥æ˜¯å¦ä»¥å‘½ä»¤å‰ç¼€å¼€å¤´
        if not text.startswith(prefix):
            # å°è¯•åŒ¹é…ä¸­æ–‡å‘½ä»¤ï¼ˆæ— å‰ç¼€ï¼‰
            chinese_commands = {
                'åˆ†æ': 'analyze',
                'å¤§ç›˜': 'market',
                'æ‰¹é‡': 'batch',
                'å¸®åŠ©': 'help',
                'çŠ¶æ€': 'status',
            }
            for cn_cmd, en_cmd in chinese_commands.items():
                if text.startswith(cn_cmd):
                    args = text[len(cn_cmd):].strip().split()
                    return en_cmd, args
            return None, []
        
        # å»é™¤å‰ç¼€
        text = text[len(prefix):]
        
        # åˆ†å‰²å‘½ä»¤å’Œå‚æ•°
        parts = text.split()
        if not parts:
            return None, []
        
        command = parts[0].lower()
        args = parts[1:] if len(parts) > 1 else []
        
        return command, args
    
    def is_command(self, prefix: str = "/") -> bool:
        """æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦æ˜¯å‘½ä»¤"""
        cmd, _ = self.get_command_and_args(prefix)
        return cmd is not None


@dataclass
class BotResponse:
    """
    ç»Ÿä¸€çš„æœºå™¨äººå“åº”æ¨¡å‹
    
    å‘½ä»¤å¤„ç†å™¨è¿”å›æ­¤æ¨¡å‹ï¼Œç”±å¹³å°é€‚é…å™¨è½¬æ¢ä¸ºå¹³å°ç‰¹å®šæ ¼å¼ã€‚
    
    Attributes:
        text: å›å¤æ–‡æœ¬
        markdown: æ˜¯å¦ä¸º Markdown æ ¼å¼
        at_user: æ˜¯å¦ @å‘é€è€…
        reply_to_message: æ˜¯å¦å›å¤åŸæ¶ˆæ¯
        extra: é¢å¤–æ•°æ®ï¼ˆå¹³å°ç‰¹å®šï¼‰
    """
    text: str
    markdown: bool = False
    at_user: bool = True
    reply_to_message: bool = True
    extra: Dict[str, Any] = field(default_factory=dict)
    
    @classmethod
    def text_response(cls, text: str, at_user: bool = True) -> 'BotResponse':
        """åˆ›å»ºçº¯æ–‡æœ¬å“åº”"""
        return cls(text=text, markdown=False, at_user=at_user)
    
    @classmethod
    def markdown_response(cls, text: str, at_user: bool = True) -> 'BotResponse':
        """åˆ›å»º Markdown å“åº”"""
        return cls(text=text, markdown=True, at_user=at_user)
    
    @classmethod
    def error_response(cls, message: str) -> 'BotResponse':
        """åˆ›å»ºé”™è¯¯å“åº”"""
        return cls(text=f"âŒ é”™è¯¯ï¼š{message}", markdown=False, at_user=True)


@dataclass
class WebhookResponse:
    """
    Webhook å“åº”æ¨¡å‹
    
    å¹³å°é€‚é…å™¨è¿”å›æ­¤æ¨¡å‹ï¼ŒåŒ…å« HTTP å“åº”å†…å®¹ã€‚
    
    Attributes:
        status_code: HTTP çŠ¶æ€ç 
        body: å“åº”ä½“ï¼ˆå­—å…¸ï¼Œå°†è¢« JSON åºåˆ—åŒ–ï¼‰
        headers: é¢å¤–çš„å“åº”å¤´
    """
    status_code: int = 200
    body: Dict[str, Any] = field(default_factory=dict)
    headers: Dict[str, str] = field(default_factory=dict)
    
    @classmethod
    def success(cls, body: Optional[Dict] = None) -> 'WebhookResponse':
        """åˆ›å»ºæˆåŠŸå“åº”"""
        return cls(status_code=200, body=body or {})
    
    @classmethod
    def challenge(cls, challenge: str) -> 'WebhookResponse':
        """åˆ›å»ºéªŒè¯å“åº”ï¼ˆç”¨äºå¹³å° URL éªŒè¯ï¼‰"""
        return cls(status_code=200, body={"challenge": challenge})
    
    @classmethod
    def error(cls, message: str, status_code: int = 400) -> 'WebhookResponse':
        """åˆ›å»ºé”™è¯¯å“åº”"""
        return cls(status_code=status_code, body={"error": message})

--------------------

#File: bot/__init__.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
æœºå™¨äººå‘½ä»¤è§¦å‘ç³»ç»Ÿ
===================================

é€šè¿‡ @æœºå™¨äºº æˆ–å‘é€å‘½ä»¤è§¦å‘è‚¡ç¥¨åˆ†æç­‰åŠŸèƒ½ã€‚
æ”¯æŒé£ä¹¦ã€é’‰é’‰ã€ä¼ä¸šå¾®ä¿¡ã€Telegram ç­‰å¤šå¹³å°ã€‚

æ¨¡å—ç»“æ„ï¼š
- models.py: ç»Ÿä¸€çš„æ¶ˆæ¯/å“åº”æ¨¡å‹
- dispatcher.py: å‘½ä»¤åˆ†å‘å™¨
- commands/: å‘½ä»¤å¤„ç†å™¨
- platforms/: å¹³å°é€‚é…å™¨
- handler.py: Webhook å¤„ç†å™¨

ä½¿ç”¨æ–¹å¼ï¼š
1. é…ç½®ç¯å¢ƒå˜é‡ï¼ˆå„å¹³å°çš„ Token ç­‰ï¼‰
2. å¯åŠ¨ WebUI æœåŠ¡
3. åœ¨å„å¹³å°é…ç½® Webhook URLï¼š
   - é£ä¹¦: http://your-server/bot/feishu
   - é’‰é’‰: http://your-server/bot/dingtalk
   - ä¼ä¸šå¾®ä¿¡: http://your-server/bot/wecom
   - Telegram: http://your-server/bot/telegram

æ”¯æŒçš„å‘½ä»¤ï¼š
- /analyze <è‚¡ç¥¨ä»£ç >  - åˆ†ææŒ‡å®šè‚¡ç¥¨
- /market             - å¤§ç›˜å¤ç›˜
- /batch              - æ‰¹é‡åˆ†æè‡ªé€‰è‚¡
- /help               - æ˜¾ç¤ºå¸®åŠ©
- /status             - ç³»ç»ŸçŠ¶æ€
"""

from bot.models import BotMessage, BotResponse, ChatType, WebhookResponse
from bot.dispatcher import CommandDispatcher, get_dispatcher

__all__ = [
    'BotMessage',
    'BotResponse',
    'ChatType',
    'WebhookResponse',
    'CommandDispatcher',
    'get_dispatcher',
]

--------------------

#File: bot/platforms/dingtalk.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
é’‰é’‰å¹³å°é€‚é…å™¨
===================================

å¤„ç†é’‰é’‰æœºå™¨äººçš„ Webhook å›è°ƒã€‚

é’‰é’‰æœºå™¨äººæ–‡æ¡£ï¼š
https://open.dingtalk.com/document/robots/robot-overview
"""

import hashlib
import hmac
import base64
import time
import logging
from datetime import datetime
from typing import Dict, Any, Optional
from urllib.parse import quote_plus

from bot.platforms.base import BotPlatform
from bot.models import BotMessage, BotResponse, WebhookResponse, ChatType

logger = logging.getLogger(__name__)


class DingtalkPlatform(BotPlatform):
    """
    é’‰é’‰å¹³å°é€‚é…å™¨
    
    æ”¯æŒï¼š
    - ä¼ä¸šå†…éƒ¨æœºå™¨äººå›è°ƒ
    - ç¾¤æœºå™¨äºº Outgoing å›è°ƒ
    - æ¶ˆæ¯ç­¾åéªŒè¯
    
    é…ç½®è¦æ±‚ï¼š
    - DINGTALK_APP_KEY: åº”ç”¨ AppKey
    - DINGTALK_APP_SECRET: åº”ç”¨ AppSecretï¼ˆç”¨äºç­¾åéªŒè¯ï¼‰
    """
    
    def __init__(self):
        from src.config import get_config
        config = get_config()
        
        self._app_key = getattr(config, 'dingtalk_app_key', None)
        self._app_secret = getattr(config, 'dingtalk_app_secret', None)
    
    @property
    def platform_name(self) -> str:
        return "dingtalk"
    
    def verify_request(self, headers: Dict[str, str], body: bytes) -> bool:
        """
        éªŒè¯é’‰é’‰è¯·æ±‚ç­¾å
        
        é’‰é’‰ç­¾åç®—æ³•ï¼š
        1. è·å– timestamp å’Œ sign
        2. è®¡ç®—ï¼šbase64(hmac_sha256(timestamp + "\n" + app_secret))
        3. æ¯”å¯¹ç­¾å
        """
        if not self._app_secret:
            logger.warning("[DingTalk] æœªé…ç½® app_secretï¼Œè·³è¿‡ç­¾åéªŒè¯")
            return True
        
        timestamp = headers.get('timestamp', '')
        sign = headers.get('sign', '')
        
        if not timestamp or not sign:
            logger.warning("[DingTalk] ç¼ºå°‘ç­¾åå‚æ•°")
            return True  # å¯èƒ½æ˜¯ä¸éœ€è¦ç­¾åçš„è¯·æ±‚
        
        # éªŒè¯æ—¶é—´æˆ³ï¼ˆ1å°æ—¶å†…æœ‰æ•ˆï¼‰
        try:
            request_time = int(timestamp)
            current_time = int(time.time() * 1000)
            if abs(current_time - request_time) > 3600 * 1000:
                logger.warning("[DingTalk] æ—¶é—´æˆ³è¿‡æœŸ")
                return False
        except ValueError:
            logger.warning("[DingTalk] æ— æ•ˆçš„æ—¶é—´æˆ³")
            return False
        
        # è®¡ç®—ç­¾å
        string_to_sign = f"{timestamp}\n{self._app_secret}"
        hmac_code = hmac.new(
            self._app_secret.encode('utf-8'),
            string_to_sign.encode('utf-8'),
            digestmod=hashlib.sha256
        ).digest()
        expected_sign = base64.b64encode(hmac_code).decode('utf-8')
        
        if sign != expected_sign:
            logger.warning(f"[DingTalk] ç­¾åéªŒè¯å¤±è´¥")
            return False
        
        return True
    
    def handle_challenge(self, data: Dict[str, Any]) -> Optional[WebhookResponse]:
        """é’‰é’‰ä¸éœ€è¦ URL éªŒè¯"""
        return None
    
    def parse_message(self, data: Dict[str, Any]) -> Optional[BotMessage]:
        """
        è§£æé’‰é’‰æ¶ˆæ¯
        
        é’‰é’‰ Outgoing æœºå™¨äººæ¶ˆæ¯æ ¼å¼ï¼š
        {
            "msgtype": "text",
            "text": {
                "content": "@æœºå™¨äºº /analyze 600519"
            },
            "msgId": "xxx",
            "createAt": "1234567890",
            "conversationType": "2",  # 1=å•èŠ, 2=ç¾¤èŠ
            "conversationId": "xxx",
            "conversationTitle": "ç¾¤å",
            "senderId": "xxx",
            "senderNick": "ç”¨æˆ·æ˜µç§°",
            "senderCorpId": "xxx",
            "senderStaffId": "xxx",
            "chatbotUserId": "xxx",
            "atUsers": [{"dingtalkId": "xxx", "staffId": "xxx"}],
            "isAdmin": false,
            "sessionWebhook": "https://oapi.dingtalk.com/robot/sendBySession?session=xxx",
            "sessionWebhookExpiredTime": 1234567890
        }
        """
        # æ£€æŸ¥æ¶ˆæ¯ç±»å‹
        msg_type = data.get('msgtype', '')
        if msg_type != 'text':
            logger.debug(f"[DingTalk] å¿½ç•¥éæ–‡æœ¬æ¶ˆæ¯: {msg_type}")
            return None
        
        # è·å–æ¶ˆæ¯å†…å®¹
        text_content = data.get('text', {})
        raw_content = text_content.get('content', '')
        
        # æå–å‘½ä»¤ï¼ˆå»é™¤ @æœºå™¨äººï¼‰
        content = self._extract_command(raw_content)
        
        # æ£€æŸ¥æ˜¯å¦ @äº†æœºå™¨äºº
        at_users = data.get('atUsers', [])
        mentioned = len(at_users) > 0
        
        # ä¼šè¯ç±»å‹
        conversation_type = data.get('conversationType', '')
        if conversation_type == '1':
            chat_type = ChatType.PRIVATE
        elif conversation_type == '2':
            chat_type = ChatType.GROUP
        else:
            chat_type = ChatType.UNKNOWN
        
        # åˆ›å»ºæ—¶é—´
        create_at = data.get('createAt', '')
        try:
            timestamp = datetime.fromtimestamp(int(create_at) / 1000)
        except (ValueError, TypeError):
            timestamp = datetime.now()
        
        # ä¿å­˜ session webhook ç”¨äºå›å¤
        session_webhook = data.get('sessionWebhook', '')
        
        return BotMessage(
            platform=self.platform_name,
            message_id=data.get('msgId', ''),
            user_id=data.get('senderId', ''),
            user_name=data.get('senderNick', ''),
            chat_id=data.get('conversationId', ''),
            chat_type=chat_type,
            content=content,
            raw_content=raw_content,
            mentioned=mentioned,
            mentions=[u.get('dingtalkId', '') for u in at_users],
            timestamp=timestamp,
            raw_data={
                **data,
                '_session_webhook': session_webhook,
            },
        )
    
    def _extract_command(self, text: str) -> str:
        """
        æå–å‘½ä»¤å†…å®¹ï¼ˆå»é™¤ @æœºå™¨äººï¼‰
        
        é’‰é’‰çš„ @ç”¨æˆ· æ ¼å¼é€šå¸¸æ˜¯ @æ˜µç§° åè·Ÿç©ºæ ¼
        """
        # ç®€å•å¤„ç†ï¼šç§»é™¤å¼€å¤´çš„ @xxx éƒ¨åˆ†
        import re
        # åŒ¹é…å¼€å¤´çš„ @xxxï¼ˆä¸­è‹±æ–‡éƒ½å¯èƒ½ï¼‰
        text = re.sub(r'^@[\S]+\s*', '', text.strip())
        return text.strip()
    
    def format_response(
        self, 
        response: BotResponse, 
        message: BotMessage
    ) -> WebhookResponse:
        """
        æ ¼å¼åŒ–é’‰é’‰å“åº”
        
        é’‰é’‰ Outgoing æœºå™¨äººå¯ä»¥ç›´æ¥åœ¨å“åº”ä¸­è¿”å›æ¶ˆæ¯ã€‚
        ä¹Ÿå¯ä»¥ä½¿ç”¨ sessionWebhook å¼‚æ­¥å‘é€ã€‚
        
        å“åº”æ ¼å¼ï¼š
        {
            "msgtype": "text" | "markdown",
            "text": {"content": "xxx"},
            "markdown": {"title": "xxx", "text": "xxx"},
            "at": {"atUserIds": ["xxx"], "isAtAll": false}
        }
        """
        if not response.text:
            return WebhookResponse.success()
        
        # æ„å»ºå“åº”
        if response.markdown:
            body = {
                "msgtype": "markdown",
                "markdown": {
                    "title": "è‚¡ç¥¨åˆ†æåŠ©æ‰‹",
                    "text": response.text,
                }
            }
        else:
            body = {
                "msgtype": "text",
                "text": {
                    "content": response.text,
                }
            }
        
        # @å‘é€è€…
        if response.at_user and message.user_id:
            body["at"] = {
                "atUserIds": [message.user_id],
                "isAtAll": False,
            }
        
        return WebhookResponse.success(body)
    
    def send_by_session_webhook(
        self, 
        session_webhook: str, 
        response: BotResponse,
        message: BotMessage
    ) -> bool:
        """
        é€šè¿‡ sessionWebhook å‘é€æ¶ˆæ¯
        
        é€‚ç”¨äºéœ€è¦å¼‚æ­¥å‘é€æˆ–å¤šæ¡æ¶ˆæ¯çš„åœºæ™¯ã€‚
        
        Args:
            session_webhook: é’‰é’‰æä¾›çš„ä¼šè¯ Webhook URL
            response: å“åº”å¯¹è±¡
            message: åŸå§‹æ¶ˆæ¯å¯¹è±¡
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        if not session_webhook:
            logger.warning("[DingTalk] æ²¡æœ‰å¯ç”¨çš„ sessionWebhook")
            return False
        
        import requests
        
        try:
            # æ„å»ºæ¶ˆæ¯
            if response.markdown:
                payload = {
                    "msgtype": "markdown",
                    "markdown": {
                        "title": "è‚¡ç¥¨åˆ†æåŠ©æ‰‹",
                        "text": response.text,
                    }
                }
            else:
                payload = {
                    "msgtype": "text",
                    "text": {
                        "content": response.text,
                    }
                }
            
            # @å‘é€è€…
            if response.at_user and message.user_id:
                payload["at"] = {
                    "atUserIds": [message.user_id],
                    "isAtAll": False,
                }
            
            # å‘é€è¯·æ±‚
            resp = requests.post(
                session_webhook,
                json=payload,
                timeout=10
            )
            
            if resp.status_code == 200:
                result = resp.json()
                if result.get('errcode') == 0:
                    logger.info("[DingTalk] sessionWebhook å‘é€æˆåŠŸ")
                    return True
                else:
                    logger.error(f"[DingTalk] sessionWebhook å‘é€å¤±è´¥: {result}")
                    return False
            else:
                logger.error(f"[DingTalk] sessionWebhook è¯·æ±‚å¤±è´¥: {resp.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"[DingTalk] sessionWebhook å‘é€å¼‚å¸¸: {e}")
            return False

--------------------

#File: bot/platforms/discord.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Discord å¹³å°é€‚é…å™¨
===================================

è´Ÿè´£ï¼š
1. éªŒè¯ Discord Webhook è¯·æ±‚
2. è§£æ Discord æ¶ˆæ¯ä¸ºç»Ÿä¸€æ ¼å¼
3. å°†å“åº”è½¬æ¢ä¸º Discord æ ¼å¼
"""

import logging
from typing import Dict, Any, Optional

from bot.platforms.base import BotPlatform
from bot.models import BotMessage, WebhookResponse


logger = logging.getLogger(__name__)


class DiscordPlatform(BotPlatform):
    """Discord å¹³å°é€‚é…å™¨"""
    
    @property
    def platform_name(self) -> str:
        """å¹³å°æ ‡è¯†åç§°"""
        return "discord"
    
    def verify_request(self, headers: Dict[str, str], body: bytes) -> bool:
        """éªŒè¯ Discord Webhook è¯·æ±‚ç­¾å
        
        Discord Webhook ç­¾åéªŒè¯ï¼š
        1. ä»è¯·æ±‚å¤´è·å– X-Signature-Ed25519 å’Œ X-Signature-Timestamp
        2. ä½¿ç”¨å…¬é’¥éªŒè¯ç­¾å
        
        Args:
            headers: HTTP è¯·æ±‚å¤´
            body: è¯·æ±‚ä½“åŸå§‹å­—èŠ‚
            
        Returns:
            ç­¾åæ˜¯å¦æœ‰æ•ˆ
        """
        # TODO: å®ç° Discord Webhook ç­¾åéªŒè¯
        # å½“å‰æš‚æ—¶è¿”å› Trueï¼Œåç»­éœ€è¦å®Œå–„
        return True
    
    def parse_message(self, data: Dict[str, Any]) -> Optional[BotMessage]:
        """è§£æ Discord æ¶ˆæ¯ä¸ºç»Ÿä¸€æ ¼å¼
        
        Args:
            data: è§£æåçš„ JSON æ•°æ®
            
        Returns:
            BotMessage å¯¹è±¡ï¼Œæˆ– Noneï¼ˆä¸éœ€è¦å¤„ç†ï¼‰
        """
        # æ£€æŸ¥æ˜¯å¦æ˜¯æ¶ˆæ¯äº‹ä»¶
        if data.get("type") != 1 and data.get("type") != 2:
            return None
        
        # æå–æ¶ˆæ¯å†…å®¹
        content = data.get("content", "").strip()
        if not content:
            return None
        
        # æå–ç”¨æˆ·ä¿¡æ¯
        author = data.get("author", {})
        user_id = author.get("id", "")
        user_name = author.get("username", "unknown")
        
        # æå–é¢‘é“ä¿¡æ¯
        channel_id = data.get("channel_id", "")
        guild_id = data.get("guild_id", "")
        
        # æå–æ¶ˆæ¯ ID
        message_id = data.get("id", "")
        
        # æå–é™„ä»¶ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
        attachments = data.get("attachments", [])
        attachment_urls = [att["url"] for att in attachments if "url" in att]
        
        # æ„å»º BotMessage å¯¹è±¡
        message = BotMessage(
            platform="discord",
            message_id=message_id,
            user_id=user_id,
            user_name=user_name,
            content=content,
            attachment_urls=attachment_urls,
            channel_id=channel_id,
            group_id=guild_id,
            # ä» data ä¸­æå–å…¶ä»–ç›¸å…³ä¿¡æ¯
            timestamp=data.get("timestamp"),
            mention_everyone=data.get("mention_everyone", False),
            mentions=data.get("mentions", []),
            
            # æ·»åŠ  Discord ç‰¹å®šçš„åŸå§‹æ•°æ®
            raw_data={
                "message_id": message_id,
                "channel_id": channel_id,
                "guild_id": guild_id,
                "author": author,
                "content": content,
                "timestamp": data.get("timestamp"),
                "attachments": attachments,
                "mentions": data.get("mentions", []),
                "mention_roles": data.get("mention_roles", []),
                "mention_everyone": data.get("mention_everyone", False),
                "type": data.get("type"),
            }
        )
        
        return message
    
    def format_response(self, response: Any, message: BotMessage) -> WebhookResponse:
        """å°†ç»Ÿä¸€å“åº”è½¬æ¢ä¸º Discord æ ¼å¼
        
        Args:
            response: ç»Ÿä¸€å“åº”å¯¹è±¡
            message: åŸå§‹æ¶ˆæ¯å¯¹è±¡
            
        Returns:
            WebhookResponse å¯¹è±¡
        """
        # æ„å»º Discord å“åº”æ ¼å¼
        discord_response = {
            "content": response.text if hasattr(response, "text") else str(response),
            "tts": False,
            "embeds": [],
            "allowed_mentions": {
                "parse": ["users", "roles", "everyone"]
            }
        }
        
        return WebhookResponse.success(discord_response)
    
    def handle_challenge(self, data: Dict[str, Any]) -> Optional[WebhookResponse]:
        """å¤„ç† Discord éªŒè¯è¯·æ±‚
        
        Discord åœ¨é…ç½® Webhook æ—¶ä¼šå‘é€éªŒè¯è¯·æ±‚
        
        Args:
            data: è¯·æ±‚æ•°æ®
            
        Returns:
            éªŒè¯å“åº”ï¼Œæˆ– Noneï¼ˆä¸æ˜¯éªŒè¯è¯·æ±‚ï¼‰
        """
        # Discord Webhook éªŒè¯è¯·æ±‚ç±»å‹æ˜¯ 1
        if data.get("type") == 1:
            return WebhookResponse.success({
                "type": 1
            })
        
        # Discord å‘½ä»¤äº¤äº’éªŒè¯
        if "challenge" in data:
            return WebhookResponse.success({
                "challenge": data["challenge"]
            })
        
        return None

--------------------

#File: bot/platforms/__init__.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
å¹³å°é€‚é…å™¨æ¨¡å—
===================================

åŒ…å«å„å¹³å°çš„ Webhook å¤„ç†å’Œæ¶ˆæ¯è§£æé€»è¾‘ã€‚

æ”¯æŒä¸¤ç§æ¥å…¥æ¨¡å¼ï¼š
1. Webhook æ¨¡å¼ï¼šéœ€è¦å…¬ç½‘ IPï¼Œé…ç½®å›è°ƒ URL
2. Stream æ¨¡å¼ï¼šæ— éœ€å…¬ç½‘ IPï¼Œé€šè¿‡ WebSocket é•¿è¿æ¥ï¼ˆé’‰é’‰ã€é£ä¹¦æ”¯æŒï¼‰
"""

from bot.platforms.base import BotPlatform
from bot.platforms.dingtalk import DingtalkPlatform

# æ‰€æœ‰å¯ç”¨å¹³å°ï¼ˆWebhook æ¨¡å¼ï¼‰
ALL_PLATFORMS = {
    'dingtalk': DingtalkPlatform,
}

# é’‰é’‰ Stream æ¨¡å¼ï¼ˆå¯é€‰ï¼‰
try:
    from bot.platforms.dingtalk_stream import (
        DingtalkStreamClient,
        DingtalkStreamHandler,
        get_dingtalk_stream_client,
        start_dingtalk_stream_background,
        DINGTALK_STREAM_AVAILABLE,
    )
except ImportError:
    DINGTALK_STREAM_AVAILABLE = False
    DingtalkStreamClient = None
    DingtalkStreamHandler = None
    get_dingtalk_stream_client = lambda: None
    start_dingtalk_stream_background = lambda: False

# é£ä¹¦ Stream æ¨¡å¼ï¼ˆå¯é€‰ï¼‰
try:
    from bot.platforms.feishu_stream import (
        FeishuStreamClient,
        FeishuStreamHandler,
        FeishuReplyClient,
        get_feishu_stream_client,
        start_feishu_stream_background,
        FEISHU_SDK_AVAILABLE,
    )
except ImportError:
    FEISHU_SDK_AVAILABLE = False
    FeishuStreamClient = None
    FeishuStreamHandler = None
    FeishuReplyClient = None
    get_feishu_stream_client = lambda: None
    start_feishu_stream_background = lambda: False

__all__ = [
    'BotPlatform',
    'DingtalkPlatform',
    'ALL_PLATFORMS',
    # é’‰é’‰ Stream æ¨¡å¼
    'DingtalkStreamClient',
    'DingtalkStreamHandler',
    'get_dingtalk_stream_client',
    'start_dingtalk_stream_background',
    'DINGTALK_STREAM_AVAILABLE',
    # é£ä¹¦ Stream æ¨¡å¼
    'FeishuStreamClient',
    'FeishuStreamHandler',
    'FeishuReplyClient',
    'get_feishu_stream_client',
    'start_feishu_stream_background',
    'FEISHU_SDK_AVAILABLE',
]

--------------------

#File: bot/platforms/feishu_stream.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
é£ä¹¦ Stream æ¨¡å¼é€‚é…å™¨
===================================

ä½¿ç”¨é£ä¹¦å®˜æ–¹ lark-oapi SDK çš„ WebSocket é•¿è¿æ¥æ¨¡å¼æ¥å…¥æœºå™¨äººï¼Œ
æ— éœ€å…¬ç½‘ IP å’Œ Webhook é…ç½®ã€‚

ä¼˜åŠ¿ï¼š
- ä¸éœ€è¦å…¬ç½‘ IP æˆ–åŸŸå
- ä¸éœ€è¦é…ç½® Webhook URL
- é€šè¿‡ WebSocket é•¿è¿æ¥æ¥æ”¶æ¶ˆæ¯
- æ›´ç®€å•çš„æ¥å…¥æ–¹å¼
- å†…ç½®è‡ªåŠ¨é‡è¿å’Œå¿ƒè·³ä¿æ´»

ä¾èµ–ï¼š
pip install lark-oapi

é£ä¹¦é•¿è¿æ¥æ–‡æ¡£ï¼š
https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/server-side-sdk/python--sdk/handle-events
"""

import json
import logging
import threading
from datetime import datetime
from typing import Optional, Callable

logger = logging.getLogger(__name__)

# å°è¯•å¯¼å…¥é£ä¹¦ SDK
try:
    import lark_oapi as lark
    from lark_oapi import ws
    from lark_oapi.api.im.v1 import (
        P2ImMessageReceiveV1,
        ReplyMessageRequest,
        ReplyMessageRequestBody,
        CreateMessageRequest,
        CreateMessageRequestBody,
    )

    FEISHU_SDK_AVAILABLE = True
except ImportError:
    FEISHU_SDK_AVAILABLE = False
    logger.warning("[Feishu Stream] lark-oapi SDK æœªå®‰è£…ï¼ŒStream æ¨¡å¼ä¸å¯ç”¨")
    logger.warning("[Feishu Stream] è¯·è¿è¡Œ: pip install lark-oapi")

from bot.models import BotMessage, BotResponse, ChatType
from src.formatters import format_feishu_markdown, chunk_feishu_content
from src.config import get_config


class FeishuReplyClient:
    """
    é£ä¹¦æ¶ˆæ¯å›å¤å®¢æˆ·ç«¯
    
    ä½¿ç”¨é£ä¹¦ API å‘é€å›å¤æ¶ˆæ¯ã€‚
    """

    def __init__(self, app_id: str, app_secret: str):
        """
        Args:
            app_id: é£ä¹¦åº”ç”¨ ID
            app_secret: é£ä¹¦åº”ç”¨å¯†é’¥
        """
        if not FEISHU_SDK_AVAILABLE:
            raise ImportError("lark-oapi SDK æœªå®‰è£…")

        self._client = lark.Client.builder() \
            .app_id(app_id) \
            .app_secret(app_secret) \
            .log_level(lark.LogLevel.WARNING) \
            .build()

        # è·å–é…ç½®çš„æœ€å¤§å­—èŠ‚æ•°
        config = get_config()
        self._max_bytes = getattr(config, 'feishu_max_bytes', 20000)

    def _send_interactive_card(self, content: str, message_id: Optional[str] = None,
                               chat_id: Optional[str] = None,
                               receive_id_type: str = "chat_id",
                               at_user: bool = False, user_id: Optional[str] = None) -> bool:
        """
        å‘é€äº¤äº’å¡ç‰‡æ¶ˆæ¯ï¼ˆæ”¯æŒ Markdown æ¸²æŸ“ï¼‰
        
        Args:
            content: Markdown æ ¼å¼çš„å†…å®¹
            message_id: åŸæ¶ˆæ¯ IDï¼ˆå›å¤æ—¶ä½¿ç”¨ï¼‰
            chat_id: ä¼šè¯ IDï¼ˆä¸»åŠ¨å‘é€æ—¶ä½¿ç”¨ï¼‰
            receive_id_type: æ¥æ”¶è€… ID ç±»å‹
            at_user: æ˜¯å¦ @ç”¨æˆ·
            user_id: ç”¨æˆ· open_idï¼ˆat_user=True æ—¶éœ€è¦ï¼‰
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        try:
            # å¦‚æœéœ€è¦ @ç”¨æˆ·ï¼Œåœ¨å†…å®¹å‰æ·»åŠ  @ æ ‡è®°
            final_content = content
            if at_user and user_id:
                final_content = f"<at user_id=\"{user_id}\"></at> {content}"
            
            # æ„å»ºäº¤äº’å¡ç‰‡ payload
            card_data = {
                "config": {"wide_screen_mode": True},
                "elements": [
                    {
                        "tag": "div",
                        "text": {
                            "tag": "lark_md",
                            "content": final_content
                        }
                    }
                ]
            }

            content_json = json.dumps(card_data)

            if message_id:
                # å›å¤æ¶ˆæ¯
                request = ReplyMessageRequest.builder() \
                    .message_id(message_id) \
                    .request_body(
                    ReplyMessageRequestBody.builder()
                    .content(content_json)
                    .msg_type("interactive")
                    .build()
                ) \
                    .build()
                response = self._client.im.v1.message.reply(request)
            else:
                # ä¸»åŠ¨å‘é€æ¶ˆæ¯
                request = CreateMessageRequest.builder() \
                    .receive_id_type(receive_id_type) \
                    .request_body(
                    CreateMessageRequestBody.builder()
                    .receive_id(chat_id)
                    .content(content_json)
                    .msg_type("interactive")
                    .build()
                ) \
                    .build()
                response = self._client.im.v1.message.create(request)

            if not response.success():
                logger.error(
                    f"[Feishu Stream] å‘é€äº¤äº’å¡ç‰‡å¤±è´¥: code={response.code}, "
                    f"msg={response.msg}, log_id={response.get_log_id()}"
                )
                return False

            logger.debug(f"[Feishu Stream] å‘é€äº¤äº’å¡ç‰‡æˆåŠŸ")
            return True

        except Exception as e:
            logger.error(f"[Feishu Stream] å‘é€äº¤äº’å¡ç‰‡å¼‚å¸¸: {e}")
            return False

    def reply_text(self, message_id: str, text: str, at_user: bool = False,
                   user_id: Optional[str] = None) -> bool:
        """
        å›å¤æ–‡æœ¬æ¶ˆæ¯ï¼ˆæ”¯æŒäº¤äº’å¡ç‰‡å’Œåˆ†æ®µå‘é€ï¼‰
        
        Args:
            message_id: åŸæ¶ˆæ¯ ID
            text: å›å¤æ–‡æœ¬
            at_user: æ˜¯å¦ @ç”¨æˆ·
            user_id: ç”¨æˆ· open_idï¼ˆat_user=True æ—¶éœ€è¦ï¼‰
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        # å°†æ–‡æœ¬è½¬æ¢ä¸ºé£ä¹¦ Markdown æ ¼å¼
        formatted_text = format_feishu_markdown(text)

        # æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ†æ®µå‘é€
        content_bytes = len(formatted_text.encode('utf-8'))
        if content_bytes > self._max_bytes:
            logger.info(
                f"[Feishu Stream] å›å¤æ¶ˆæ¯å†…å®¹è¶…é•¿({content_bytes}å­—èŠ‚)ï¼Œå°†åˆ†æ‰¹å‘é€"
            )
            return chunk_feishu_content(
                formatted_text,
                self._max_bytes,
                lambda chunk: self._send_interactive_card(
                    chunk, message_id=message_id, at_user=at_user, user_id=user_id
                )
            )

        # å•æ¡æ¶ˆæ¯ï¼Œä½¿ç”¨äº¤äº’å¡ç‰‡
        return self._send_interactive_card(
            formatted_text, message_id=message_id, at_user=at_user, user_id=user_id
        )

    def send_to_chat(self, chat_id: str, text: str,
                     receive_id_type: str = "chat_id") -> bool:
        """
        å‘é€æ¶ˆæ¯åˆ°æŒ‡å®šä¼šè¯ï¼ˆæ”¯æŒäº¤äº’å¡ç‰‡å’Œåˆ†æ®µå‘é€ï¼‰
        
        Args:
            chat_id: ä¼šè¯ ID
            text: æ¶ˆæ¯æ–‡æœ¬
            receive_id_type: æ¥æ”¶è€… ID ç±»å‹ï¼Œé»˜è®¤ chat_id
            
        Returns:
            æ˜¯å¦å‘é€æˆåŠŸ
        """
        # å°†æ–‡æœ¬è½¬æ¢ä¸ºé£ä¹¦ Markdown æ ¼å¼
        formatted_text = format_feishu_markdown(text)

        # æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ†æ®µå‘é€
        content_bytes = len(formatted_text.encode('utf-8'))
        if content_bytes > self._max_bytes:
            logger.info(
                f"[Feishu Stream] å‘é€æ¶ˆæ¯å†…å®¹è¶…é•¿({content_bytes}å­—èŠ‚)ï¼Œå°†åˆ†æ‰¹å‘é€"
            )
            return chunk_feishu_content(
                formatted_text,
                self._max_bytes,
                lambda chunk: self._send_interactive_card(
                    chunk, chat_id=chat_id, receive_id_type=receive_id_type
                )
            )

        # å•æ¡æ¶ˆæ¯ï¼Œä½¿ç”¨äº¤äº’å¡ç‰‡
        return self._send_interactive_card(
            formatted_text, chat_id=chat_id, receive_id_type=receive_id_type
        )


class FeishuStreamHandler:
    """
    é£ä¹¦ Stream æ¨¡å¼æ¶ˆæ¯å¤„ç†å™¨
    
    å°† SDK çš„äº‹ä»¶è½¬æ¢ä¸ºç»Ÿä¸€çš„ BotMessage æ ¼å¼ï¼Œ
    å¹¶è°ƒç”¨å‘½ä»¤åˆ†å‘å™¨å¤„ç†ã€‚
    """

    def __init__(
            self,
            on_message: Callable[[BotMessage], BotResponse],
            reply_client: FeishuReplyClient
    ):
        """
        Args:
            on_message: æ¶ˆæ¯å¤„ç†å›è°ƒå‡½æ•°ï¼Œæ¥æ”¶ BotMessage è¿”å› BotResponse
            reply_client: é£ä¹¦å›å¤å®¢æˆ·ç«¯
        """
        self._on_message = on_message
        self._reply_client = reply_client
        self._logger = logger

    @staticmethod
    def _truncate_log_content(text: str, max_len: int = 200) -> str:
        """æˆªæ–­æ—¥å¿—å†…å®¹"""
        cleaned = text.replace("\n", " ").strip()
        if len(cleaned) > max_len:
            return f"{cleaned[:max_len]}..."
        return cleaned

    def _log_incoming_message(self, message: BotMessage) -> None:
        """è®°å½•æ”¶åˆ°çš„æ¶ˆæ¯æ—¥å¿—"""
        content = message.raw_content or message.content or ""
        summary = self._truncate_log_content(content)
        self._logger.info(
            "[Feishu Stream] Incoming message: msg_id=%s user_id=%s "
            "chat_id=%s chat_type=%s content=%s",
            message.message_id,
            message.user_id,
            message.chat_id,
            getattr(message.chat_type, "value", message.chat_type),
            summary,
        )

    def handle_message(self, event: 'P2ImMessageReceiveV1') -> None:
        """
        å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯äº‹ä»¶
        
        Args:
            event: é£ä¹¦æ¶ˆæ¯æ¥æ”¶äº‹ä»¶
        """
        try:
            # è§£ææ¶ˆæ¯
            bot_message = self._parse_event_message(event)

            if bot_message is None:
                return

            self._log_incoming_message(bot_message)

            # è°ƒç”¨æ¶ˆæ¯å¤„ç†å›è°ƒ
            response = self._on_message(bot_message)

            # å‘é€å›å¤
            if response and response.text:
                self._reply_client.reply_text(
                    message_id=bot_message.message_id,
                    text=response.text,
                    at_user=response.at_user,
                    user_id=bot_message.user_id if response.at_user else None
                )

        except Exception as e:
            self._logger.error(f"[Feishu Stream] å¤„ç†æ¶ˆæ¯å¤±è´¥: {e}")
            self._logger.exception(e)

    def _parse_event_message(self, event: 'P2ImMessageReceiveV1') -> Optional[BotMessage]:
        """
        è§£æé£ä¹¦äº‹ä»¶æ¶ˆæ¯ä¸ºç»Ÿä¸€æ ¼å¼
        
        Args:
            event: P2ImMessageReceiveV1 äº‹ä»¶å¯¹è±¡
        """
        try:
            event_data = event.event
            if event_data is None:
                return None

            message_data = event_data.message
            sender_data = event_data.sender

            if message_data is None:
                return None

            # åªå¤„ç†æ–‡æœ¬æ¶ˆæ¯
            message_type = message_data.message_type or ""
            if message_type != "text":
                self._logger.debug(f"[Feishu Stream] å¿½ç•¥éæ–‡æœ¬æ¶ˆæ¯: {message_type}")
                return None

            # è§£ææ¶ˆæ¯å†…å®¹
            content_str = message_data.content or "{}"
            try:
                content_json = json.loads(content_str)
                raw_content = content_json.get("text", "")
            except json.JSONDecodeError:
                raw_content = content_str

            # æå–å‘½ä»¤ï¼ˆå»é™¤ @æœºå™¨äººï¼‰
            content = self._extract_command(raw_content, message_data.mentions)
            mentioned = "@" in raw_content or bool(message_data.mentions)

            # è·å–å‘é€è€…ä¿¡æ¯
            user_id = ""
            if sender_data and sender_data.sender_id:
                user_id = sender_data.sender_id.open_id or sender_data.sender_id.user_id or ""

            # è·å–ä¼šè¯ç±»å‹
            chat_type_str = message_data.chat_type or ""
            if chat_type_str == "group":
                chat_type = ChatType.GROUP
            elif chat_type_str == "p2p":
                chat_type = ChatType.PRIVATE
            else:
                chat_type = ChatType.UNKNOWN

            # åˆ›å»ºæ—¶é—´
            create_time = message_data.create_time
            try:
                if create_time:
                    timestamp = datetime.fromtimestamp(int(create_time) / 1000)
                else:
                    timestamp = datetime.now()
            except (ValueError, TypeError):
                timestamp = datetime.now()

            # æ„å»ºåŸå§‹æ•°æ®
            raw_data = {
                "header": {
                    "event_id": event.header.event_id if event.header else "",
                    "event_type": event.header.event_type if event.header else "",
                    "create_time": event.header.create_time if event.header else "",
                    "token": event.header.token if event.header else "",
                    "app_id": event.header.app_id if event.header else "",
                },
                "event": {
                    "message_id": message_data.message_id,
                    "chat_id": message_data.chat_id,
                    "chat_type": message_data.chat_type,
                    "content": message_data.content,
                }
            }

            return BotMessage(
                platform="feishu",
                message_id=message_data.message_id or "",
                user_id=user_id,
                user_name=user_id,  # é£ä¹¦ä¸ç›´æ¥è¿”å›ç”¨æˆ·å
                chat_id=message_data.chat_id or "",
                chat_type=chat_type,
                content=content,
                raw_content=raw_content,
                mentioned=mentioned,
                mentions=[m.key or "" for m in (message_data.mentions or [])],
                timestamp=timestamp,
                raw_data=raw_data,
            )

        except Exception as e:
            self._logger.error(f"[Feishu Stream] è§£ææ¶ˆæ¯å¤±è´¥: {e}")
            return None

    def _extract_command(self, text: str, mentions: list) -> str:
        """
        æå–å‘½ä»¤å†…å®¹ï¼ˆå»é™¤ @æœºå™¨äººï¼‰
        
        é£ä¹¦çš„ @ç”¨æˆ· æ ¼å¼æ˜¯ï¼š@_user_1, @_user_2 ç­‰
        
        Args:
            text: åŸå§‹æ¶ˆæ¯æ–‡æœ¬
            mentions: @æåŠåˆ—è¡¨
        """
        import re

        # æ–¹å¼1: é€šè¿‡ mentions åˆ—è¡¨ç§»é™¤ï¼ˆç²¾ç¡®åŒ¹é…ï¼‰
        for mention in (mentions or []):
            key = getattr(mention, 'key', '') or ''
            if key:
                text = text.replace(key, '')

        # æ–¹å¼2: æ­£åˆ™å…œåº•ï¼Œç§»é™¤é£ä¹¦ @ç”¨æˆ· æ ¼å¼ï¼ˆ@_user_Nï¼‰
        # å½“ mentions ä¸ºç©ºæˆ–æœªæ­£ç¡®ä¼ é€’æ—¶ç”Ÿæ•ˆ
        text = re.sub(r'@_user_\d+\s*', '', text)

        # æ¸…ç†å¤šä½™ç©ºæ ¼
        return ' '.join(text.split())


class FeishuStreamClient:
    """
    é£ä¹¦ Stream æ¨¡å¼å®¢æˆ·ç«¯
    
    å°è£… lark-oapi SDK çš„ WebSocket å®¢æˆ·ç«¯ï¼Œæä¾›ç®€å•çš„å¯åŠ¨æ¥å£ã€‚
    
    ä½¿ç”¨æ–¹å¼ï¼š
        client = FeishuStreamClient()
        client.start()  # é˜»å¡è¿è¡Œ
        
        # æˆ–è€…åœ¨åå°è¿è¡Œ
        client.start_background()
    """

    def __init__(
            self,
            app_id: Optional[str] = None,
            app_secret: Optional[str] = None
    ):
        """
        Args:
            app_id: åº”ç”¨ IDï¼ˆä¸ä¼ åˆ™ä»é…ç½®è¯»å–ï¼‰
            app_secret: åº”ç”¨å¯†é’¥ï¼ˆä¸ä¼ åˆ™ä»é…ç½®è¯»å–ï¼‰
        """
        if not FEISHU_SDK_AVAILABLE:
            raise ImportError(
                "lark-oapi SDK æœªå®‰è£…ã€‚\n"
                "è¯·è¿è¡Œ: pip install lark-oapi"
            )

        from src.config import get_config
        config = get_config()

        self._app_id = app_id or getattr(config, 'feishu_app_id', None)
        self._app_secret = app_secret or getattr(config, 'feishu_app_secret', None)

        if not self._app_id or not self._app_secret:
            raise ValueError(
                "é£ä¹¦ Stream æ¨¡å¼éœ€è¦é…ç½® FEISHU_APP_ID å’Œ FEISHU_APP_SECRET"
            )

        self._ws_client: Optional[ws.Client] = None
        self._reply_client: Optional[FeishuReplyClient] = None
        self._background_thread: Optional[threading.Thread] = None
        self._running = False

    def _create_message_handler(self) -> Callable[[BotMessage], BotResponse]:
        """åˆ›å»ºæ¶ˆæ¯å¤„ç†å‡½æ•°"""

        def handle_message(message: BotMessage) -> BotResponse:
            from bot.dispatcher import get_dispatcher
            dispatcher = get_dispatcher()
            return dispatcher.dispatch(message)

        return handle_message

    def _create_event_handler(self) -> 'lark.EventDispatcherHandler':
        """åˆ›å»ºäº‹ä»¶åˆ†å‘å¤„ç†å™¨"""
        # åˆ›å»ºå›å¤å®¢æˆ·ç«¯
        self._reply_client = FeishuReplyClient(self._app_id, self._app_secret)

        # åˆ›å»ºæ¶ˆæ¯å¤„ç†å™¨
        handler = FeishuStreamHandler(
            self._create_message_handler(),
            self._reply_client
        )

        # åˆ›å»ºå¹¶æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
        # æ³¨æ„ï¼šencrypt_key å’Œ verification_token åœ¨é•¿è¿æ¥æ¨¡å¼ä¸‹ä¸æ˜¯å¿…éœ€çš„
        # ä½† SDK è¦æ±‚ä¼ å…¥ï¼ˆå¯ä»¥ä¸ºç©ºå­—ç¬¦ä¸²ï¼‰
        from src.config import get_config
        config = get_config()

        encrypt_key = getattr(config, 'feishu_encrypt_key', '') or ''
        verification_token = getattr(config, 'feishu_verification_token', '') or ''

        event_handler = lark.EventDispatcherHandler.builder(
            encrypt_key=encrypt_key,
            verification_token=verification_token,
            level=lark.LogLevel.WARNING
        ).register_p2_im_message_receive_v1(
            handler.handle_message
        ).build()

        return event_handler

    def start(self) -> None:
        """
        å¯åŠ¨ Stream å®¢æˆ·ç«¯ï¼ˆé˜»å¡ï¼‰
        
        æ­¤æ–¹æ³•ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°å®¢æˆ·ç«¯åœæ­¢ã€‚
        """
        logger.info("[Feishu Stream] æ­£åœ¨å¯åŠ¨...")

        # åˆ›å»ºäº‹ä»¶å¤„ç†å™¨
        event_handler = self._create_event_handler()

        # åˆ›å»º WebSocket å®¢æˆ·ç«¯
        self._ws_client = ws.Client(
            app_id=self._app_id,
            app_secret=self._app_secret,
            event_handler=event_handler,
            log_level=lark.LogLevel.WARNING,
            auto_reconnect=True
        )

        self._running = True
        logger.info("[Feishu Stream] å®¢æˆ·ç«¯å·²å¯åŠ¨ï¼Œç­‰å¾…æ¶ˆæ¯...")

        # å¯åŠ¨ï¼ˆé˜»å¡ï¼‰
        self._ws_client.start()

    def start_background(self) -> None:
        """
        åœ¨åå°çº¿ç¨‹å¯åŠ¨ Stream å®¢æˆ·ç«¯ï¼ˆéé˜»å¡ï¼‰
        
        é€‚ç”¨äºä¸å…¶ä»–æœåŠ¡ï¼ˆå¦‚ WebUIï¼‰åŒæ—¶è¿è¡Œçš„åœºæ™¯ã€‚
        """
        if self._background_thread and self._background_thread.is_alive():
            logger.warning("[Feishu Stream] å®¢æˆ·ç«¯å·²åœ¨è¿è¡Œ")
            return

        self._running = True
        self._background_thread = threading.Thread(
            target=self._run_in_background,
            daemon=True,
            name="FeishuStreamClient"
        )
        self._background_thread.start()
        logger.info("[Feishu Stream] åå°å®¢æˆ·ç«¯å·²å¯åŠ¨")

    def _run_in_background(self) -> None:
        """åå°è¿è¡Œï¼ˆå¤„ç†å¼‚å¸¸å’Œé‡è¿ï¼‰"""
        import time

        while self._running:
            try:
                self.start()
            except Exception as e:
                logger.error(f"[Feishu Stream] è¿è¡Œå¼‚å¸¸: {e}")
                if self._running:
                    logger.info("[Feishu Stream] 5 ç§’åé‡è¿...")
                    time.sleep(5)

    def stop(self) -> None:
        """åœæ­¢å®¢æˆ·ç«¯"""
        self._running = False
        logger.info("[Feishu Stream] å®¢æˆ·ç«¯å·²åœæ­¢")

    @property
    def is_running(self) -> bool:
        """æ˜¯å¦æ­£åœ¨è¿è¡Œ"""
        return self._running


# å…¨å±€å®¢æˆ·ç«¯å®ä¾‹
_stream_client: Optional[FeishuStreamClient] = None


def get_feishu_stream_client() -> Optional[FeishuStreamClient]:
    """è·å–å…¨å±€ Stream å®¢æˆ·ç«¯å®ä¾‹"""
    global _stream_client

    if _stream_client is None and FEISHU_SDK_AVAILABLE:
        try:
            _stream_client = FeishuStreamClient()
        except (ImportError, ValueError) as e:
            logger.warning(f"[Feishu Stream] æ— æ³•åˆ›å»ºå®¢æˆ·ç«¯: {e}")
            return None

    return _stream_client


def start_feishu_stream_background() -> bool:
    """
    åœ¨åå°å¯åŠ¨é£ä¹¦ Stream å®¢æˆ·ç«¯
    
    Returns:
        æ˜¯å¦æˆåŠŸå¯åŠ¨
    """
    client = get_feishu_stream_client()
    if client:
        client.start_background()
        return True
    return False

--------------------

#File: bot/platforms/dingtalk_stream.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
é’‰é’‰ Stream æ¨¡å¼é€‚é…å™¨
===================================

ä½¿ç”¨é’‰é’‰å®˜æ–¹ Stream SDK æ¥å…¥æœºå™¨äººï¼Œæ— éœ€å…¬ç½‘ IP å’Œ Webhook é…ç½®ã€‚

ä¼˜åŠ¿ï¼š
- ä¸éœ€è¦å…¬ç½‘ IP æˆ–åŸŸå
- ä¸éœ€è¦é…ç½® Webhook URL
- é€šè¿‡ WebSocket é•¿è¿æ¥æ¥æ”¶æ¶ˆæ¯
- æ›´ç®€å•çš„æ¥å…¥æ–¹å¼

ä¾èµ–ï¼š
pip install dingtalk-stream

é’‰é’‰ Stream SDKï¼š
https://github.com/open-dingtalk/dingtalk-stream-sdk-python
"""

import logging
import asyncio
import threading
from datetime import datetime
from typing import Optional, Callable, Any

logger = logging.getLogger(__name__)

# å°è¯•å¯¼å…¥é’‰é’‰ Stream SDK
try:
    import dingtalk_stream
    from dingtalk_stream import AckMessage

    DINGTALK_STREAM_AVAILABLE = True
except ImportError:
    DINGTALK_STREAM_AVAILABLE = False
    logger.warning("[DingTalk Stream] dingtalk-stream SDK æœªå®‰è£…ï¼ŒStream æ¨¡å¼ä¸å¯ç”¨")
    logger.warning("[DingTalk Stream] è¯·è¿è¡Œ: pip install dingtalk-stream")

from bot.models import BotMessage, BotResponse, ChatType


class DingtalkStreamHandler:
    """
    é’‰é’‰ Stream æ¨¡å¼æ¶ˆæ¯å¤„ç†å™¨
    
    å°† Stream SDK çš„å›è°ƒè½¬æ¢ä¸ºç»Ÿä¸€çš„ BotMessage æ ¼å¼ï¼Œ
    å¹¶è°ƒç”¨å‘½ä»¤åˆ†å‘å™¨å¤„ç†ã€‚
    """

    def __init__(self, on_message: Callable[[BotMessage], BotResponse]):
        """
        Args:
            on_message: æ¶ˆæ¯å¤„ç†å›è°ƒå‡½æ•°ï¼Œæ¥æ”¶ BotMessage è¿”å› BotResponse
        """
        self._on_message = on_message
        self._logger = logger

    @staticmethod
    def _truncate_log_content(text: str, max_len: int = 200) -> str:
        cleaned = text.replace("\n", " ").strip()
        if len(cleaned) > max_len:
            return f"{cleaned[:max_len]}..."
        return cleaned

    def _log_incoming_message(self, message: BotMessage) -> None:
        content = message.raw_content or message.content or ""
        summary = self._truncate_log_content(content)
        self._logger.info(
            "[DingTalk Stream] Incoming message: msg_id=%s user_id=%s chat_id=%s chat_type=%s content=%s",
            message.message_id,
            message.user_id,
            message.chat_id,
            getattr(message.chat_type, "value", message.chat_type),
            summary,
        )

    if DINGTALK_STREAM_AVAILABLE:
        class _ChatbotHandler(dingtalk_stream.ChatbotHandler):
            """å†…éƒ¨æ¶ˆæ¯å¤„ç†å™¨"""

            def __init__(self, parent: 'DingtalkStreamHandler'):
                super().__init__()
                self._parent = parent
                self.logger = logger

            async def process(self, callback: dingtalk_stream.CallbackMessage):
                """å¤„ç†æ”¶åˆ°çš„æ¶ˆæ¯"""
                try:
                    # è§£ææ¶ˆæ¯
                    incoming = dingtalk_stream.ChatbotMessage.from_dict(callback.data)

                    # è½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼
                    bot_message = self._parent._parse_stream_message(incoming, callback.data)

                    if bot_message:
                        self._parent._log_incoming_message(bot_message)
                        # è°ƒç”¨æ¶ˆæ¯å¤„ç†å›è°ƒ
                        response = self._parent._on_message(bot_message)

                        # å‘é€å›å¤
                        if response and response.text:
                            # æ„å»º @ç”¨æˆ· å‰ç¼€ï¼ˆç¾¤èŠåœºæ™¯ä¸‹éœ€è¦åœ¨æ–‡æœ¬ä¸­åŒ…å« @ç”¨æˆ·åï¼‰
                            if response.at_user and incoming.sender_nick:
                                if response.markdown:
                                    self.reply_markdown(
                                        title="è‚¡ç¥¨åˆ†æåŠ©æ‰‹",
                                        text=f"@{incoming.sender_nick} " + response.text,
                                        incoming_message=incoming
                                    )
                                else:
                                    self.reply_text(response.text, incoming)

                    return AckMessage.STATUS_OK, 'OK'

                except Exception as e:
                    self.logger.error(f"[DingTalk Stream] å¤„ç†æ¶ˆæ¯å¤±è´¥: {e}")
                    self.logger.exception(e)
                    return AckMessage.STATUS_SYSTEM_EXCEPTION, str(e)

        def create_handler(self) -> '_ChatbotHandler':
            """åˆ›å»º SDK éœ€è¦çš„å¤„ç†å™¨å®ä¾‹"""
            return self._ChatbotHandler(self)

    def _parse_stream_message(self, incoming: Any, raw_data: dict) -> Optional[BotMessage]:
        """
        è§£æ Stream æ¶ˆæ¯ä¸ºç»Ÿä¸€æ ¼å¼
        
        Args:
            incoming: ChatbotMessage å¯¹è±¡
            raw_data: åŸå§‹å›è°ƒæ•°æ®
        """
        try:
            raw_data = dict(raw_data or {})

            # è·å–æ¶ˆæ¯å†…å®¹
            raw_content = incoming.text.content if incoming.text else ''

            # æå–å‘½ä»¤ï¼ˆå»é™¤ @æœºå™¨äººï¼‰
            content = self._extract_command(raw_content)

            # ä¼šè¯ç±»å‹
            conversation_type = getattr(incoming, 'conversation_type', None)
            if conversation_type == '1':
                chat_type = ChatType.PRIVATE
            elif conversation_type == '2':
                chat_type = ChatType.GROUP
            else:
                chat_type = ChatType.UNKNOWN

            # æ˜¯å¦ @äº†æœºå™¨äººï¼ˆStream æ¨¡å¼ä¸‹æ”¶åˆ°çš„æ¶ˆæ¯ä¸€èˆ¬éƒ½æ˜¯ @æœºå™¨äººçš„ï¼‰
            mentioned = True

            # æå– sessionWebhookï¼Œä¾¿äºå¼‚æ­¥æ¨é€
            session_webhook = (
                    getattr(incoming, 'session_webhook', None)
                    or raw_data.get('sessionWebhook')
                    or raw_data.get('session_webhook')
            )
            if session_webhook:
                raw_data['_session_webhook'] = session_webhook

            return BotMessage(
                platform='dingtalk',
                message_id=getattr(incoming, 'msg_id', '') or '',
                user_id=getattr(incoming, 'sender_id', '') or '',
                user_name=getattr(incoming, 'sender_nick', '') or '',
                chat_id=getattr(incoming, 'conversation_id', '') or '',
                chat_type=chat_type,
                content=content,
                raw_content=raw_content,
                mentioned=mentioned,
                mentions=[],
                timestamp=datetime.now(),
                raw_data=raw_data,
            )

        except Exception as e:
            logger.error(f"[DingTalk Stream] è§£ææ¶ˆæ¯å¤±è´¥: {e}")
            return None

    def _extract_command(self, text: str) -> str:
        """æå–å‘½ä»¤å†…å®¹ï¼ˆå»é™¤ @æœºå™¨äººï¼‰"""
        import re
        text = re.sub(r'^@[\S]+\s*', '', text.strip())
        return text.strip()


class DingtalkStreamClient:
    """
    é’‰é’‰ Stream æ¨¡å¼å®¢æˆ·ç«¯
    
    å°è£… dingtalk-stream SDKï¼Œæä¾›ç®€å•çš„å¯åŠ¨æ¥å£ã€‚
    
    ä½¿ç”¨æ–¹å¼ï¼š
        client = DingtalkStreamClient()
        client.start()  # é˜»å¡è¿è¡Œ
        
        # æˆ–è€…åœ¨åå°è¿è¡Œ
        client.start_background()
    """

    def __init__(
            self,
            client_id: Optional[str] = None,
            client_secret: Optional[str] = None
    ):
        """
        Args:
            client_id: åº”ç”¨ AppKeyï¼ˆä¸ä¼ åˆ™ä»é…ç½®è¯»å–ï¼‰
            client_secret: åº”ç”¨ AppSecretï¼ˆä¸ä¼ åˆ™ä»é…ç½®è¯»å–ï¼‰
        """
        if not DINGTALK_STREAM_AVAILABLE:
            raise ImportError(
                "dingtalk-stream SDK æœªå®‰è£…ã€‚\n"
                "è¯·è¿è¡Œ: pip install dingtalk-stream"
            )

        from src.config import get_config
        config = get_config()

        self._client_id = client_id or getattr(config, 'dingtalk_app_key', None)
        self._client_secret = client_secret or getattr(config, 'dingtalk_app_secret', None)

        if not self._client_id or not self._client_secret:
            raise ValueError(
                "é’‰é’‰ Stream æ¨¡å¼éœ€è¦é…ç½® DINGTALK_APP_KEY å’Œ DINGTALK_APP_SECRET"
            )

        self._client: Optional[dingtalk_stream.DingTalkStreamClient] = None
        self._background_thread: Optional[threading.Thread] = None
        self._running = False

    def _create_message_handler(self) -> Callable[[BotMessage], BotResponse]:
        """åˆ›å»ºæ¶ˆæ¯å¤„ç†å‡½æ•°"""

        def handle_message(message: BotMessage) -> BotResponse:
            from bot.dispatcher import get_dispatcher
            dispatcher = get_dispatcher()
            return dispatcher.dispatch(message)

        return handle_message

    def start(self) -> None:
        """
        å¯åŠ¨ Stream å®¢æˆ·ç«¯ï¼ˆé˜»å¡ï¼‰
        
        æ­¤æ–¹æ³•ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°å®¢æˆ·ç«¯åœæ­¢ã€‚
        """
        logger.info("[DingTalk Stream] æ­£åœ¨å¯åŠ¨...")

        # åˆ›å»ºå‡­è¯
        credential = dingtalk_stream.Credential(
            self._client_id,
            self._client_secret
        )

        # åˆ›å»ºå®¢æˆ·ç«¯
        self._client = dingtalk_stream.DingTalkStreamClient(credential)

        # æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
        handler = DingtalkStreamHandler(self._create_message_handler())
        self._client.register_callback_handler(
            dingtalk_stream.chatbot.ChatbotMessage.TOPIC,
            handler.create_handler()
        )

        self._running = True
        logger.info("[DingTalk Stream] å®¢æˆ·ç«¯å·²å¯åŠ¨ï¼Œç­‰å¾…æ¶ˆæ¯...")

        # å¯åŠ¨ï¼ˆé˜»å¡ï¼‰
        self._client.start_forever()

    def start_background(self) -> None:
        """
        åœ¨åå°çº¿ç¨‹å¯åŠ¨ Stream å®¢æˆ·ç«¯ï¼ˆéé˜»å¡ï¼‰
        
        é€‚ç”¨äºä¸å…¶ä»–æœåŠ¡ï¼ˆå¦‚ WebUIï¼‰åŒæ—¶è¿è¡Œçš„åœºæ™¯ã€‚
        """
        if self._background_thread and self._background_thread.is_alive():
            logger.warning("[DingTalk Stream] å®¢æˆ·ç«¯å·²åœ¨è¿è¡Œ")
            return

        self._running = True
        self._background_thread = threading.Thread(
            target=self._run_in_background,
            daemon=True,
            name="DingtalkStreamClient"
        )
        self._background_thread.start()
        logger.info("[DingTalk Stream] åå°å®¢æˆ·ç«¯å·²å¯åŠ¨")

    def _run_in_background(self) -> None:
        """åå°è¿è¡Œï¼ˆå¤„ç†å¼‚å¸¸å’Œé‡è¿ï¼‰"""
        while self._running:
            try:
                self.start()
            except Exception as e:
                logger.error(f"[DingTalk Stream] è¿è¡Œå¼‚å¸¸: {e}")
                if self._running:
                    logger.info("[DingTalk Stream] 5 ç§’åé‡è¿...")
                    import time
                    time.sleep(5)

    def stop(self) -> None:
        """åœæ­¢å®¢æˆ·ç«¯"""
        self._running = False
        logger.info("[DingTalk Stream] å®¢æˆ·ç«¯å·²åœæ­¢")

    @property
    def is_running(self) -> bool:
        """æ˜¯å¦æ­£åœ¨è¿è¡Œ"""
        return self._running


# å…¨å±€å®¢æˆ·ç«¯å®ä¾‹
_stream_client: Optional[DingtalkStreamClient] = None


def get_dingtalk_stream_client() -> Optional[DingtalkStreamClient]:
    """è·å–å…¨å±€ Stream å®¢æˆ·ç«¯å®ä¾‹"""
    global _stream_client

    if _stream_client is None and DINGTALK_STREAM_AVAILABLE:
        try:
            _stream_client = DingtalkStreamClient()
        except (ImportError, ValueError) as e:
            logger.warning(f"[DingTalk Stream] æ— æ³•åˆ›å»ºå®¢æˆ·ç«¯: {e}")
            return None

    return _stream_client


def start_dingtalk_stream_background() -> bool:
    """
    åœ¨åå°å¯åŠ¨é’‰é’‰ Stream å®¢æˆ·ç«¯
    
    Returns:
        æ˜¯å¦æˆåŠŸå¯åŠ¨
    """
    client = get_dingtalk_stream_client()
    if client:
        client.start_background()
        return True
    return False

--------------------

#File: bot/platforms/base.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
å¹³å°é€‚é…å™¨åŸºç±»
===================================

å®šä¹‰å¹³å°é€‚é…å™¨çš„æŠ½è±¡åŸºç±»ï¼Œå„å¹³å°å¿…é¡»ç»§æ‰¿æ­¤ç±»ã€‚
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, Tuple

from bot.models import BotMessage, BotResponse, WebhookResponse


class BotPlatform(ABC):
    """
    å¹³å°é€‚é…å™¨æŠ½è±¡åŸºç±»
    
    è´Ÿè´£ï¼š
    1. éªŒè¯ Webhook è¯·æ±‚ç­¾å
    2. è§£æå¹³å°æ¶ˆæ¯ä¸ºç»Ÿä¸€æ ¼å¼
    3. å°†å“åº”è½¬æ¢ä¸ºå¹³å°æ ¼å¼
    
    ä½¿ç”¨ç¤ºä¾‹ï¼š
        class MyPlatform(BotPlatform):
            @property
            def platform_name(self) -> str:
                return "myplatform"
            
            def verify_request(self, headers, body) -> bool:
                # éªŒè¯ç­¾åé€»è¾‘
                return True
            
            def parse_message(self, data) -> Optional[BotMessage]:
                # è§£ææ¶ˆæ¯é€»è¾‘
                return BotMessage(...)
            
            def format_response(self, response, message) -> WebhookResponse:
                # æ ¼å¼åŒ–å“åº”é€»è¾‘
                return WebhookResponse.success({"text": response.text})
    """
    
    @property
    @abstractmethod
    def platform_name(self) -> str:
        """
        å¹³å°æ ‡è¯†åç§°
        
        ç”¨äºè·¯ç”±åŒ¹é…å’Œæ—¥å¿—æ ‡è¯†ï¼Œå¦‚ "feishu", "dingtalk"
        """
        pass
    
    @abstractmethod
    def verify_request(self, headers: Dict[str, str], body: bytes) -> bool:
        """
        éªŒè¯è¯·æ±‚ç­¾å
        
        å„å¹³å°æœ‰ä¸åŒçš„ç­¾åéªŒè¯æœºåˆ¶ï¼Œéœ€è¦å•ç‹¬å®ç°ã€‚
        
        Args:
            headers: HTTP è¯·æ±‚å¤´
            body: è¯·æ±‚ä½“åŸå§‹å­—èŠ‚
            
        Returns:
            ç­¾åæ˜¯å¦æœ‰æ•ˆ
        """
        pass
    
    @abstractmethod
    def parse_message(self, data: Dict[str, Any]) -> Optional[BotMessage]:
        """
        è§£æå¹³å°æ¶ˆæ¯ä¸ºç»Ÿä¸€æ ¼å¼
        
        å°†å¹³å°ç‰¹å®šçš„æ¶ˆæ¯æ ¼å¼è½¬æ¢ä¸º BotMessageã€‚
        å¦‚æœä¸æ˜¯éœ€è¦å¤„ç†çš„æ¶ˆæ¯ç±»å‹ï¼ˆå¦‚äº‹ä»¶å›è°ƒï¼‰ï¼Œè¿”å› Noneã€‚
        
        Args:
            data: è§£æåçš„ JSON æ•°æ®
            
        Returns:
            BotMessage å¯¹è±¡ï¼Œæˆ– Noneï¼ˆä¸éœ€è¦å¤„ç†ï¼‰
        """
        pass
    
    @abstractmethod
    def format_response(
        self, 
        response: BotResponse, 
        message: BotMessage
    ) -> WebhookResponse:
        """
        å°†ç»Ÿä¸€å“åº”è½¬æ¢ä¸ºå¹³å°æ ¼å¼
        
        Args:
            response: ç»Ÿä¸€å“åº”å¯¹è±¡
            message: åŸå§‹æ¶ˆæ¯å¯¹è±¡ï¼ˆç”¨äºè·å–å›å¤ç›®æ ‡ç­‰ä¿¡æ¯ï¼‰
            
        Returns:
            WebhookResponse å¯¹è±¡
        """
        pass
    
    def handle_challenge(self, data: Dict[str, Any]) -> Optional[WebhookResponse]:
        """
        å¤„ç†å¹³å°éªŒè¯è¯·æ±‚
        
        éƒ¨åˆ†å¹³å°åœ¨é…ç½® Webhook æ—¶ä¼šå‘é€éªŒè¯è¯·æ±‚ï¼Œéœ€è¦è¿”å›ç‰¹å®šå“åº”ã€‚
        å­ç±»å¯é‡å†™æ­¤æ–¹æ³•ã€‚
        
        Args:
            data: è¯·æ±‚æ•°æ®
            
        Returns:
            éªŒè¯å“åº”ï¼Œæˆ– Noneï¼ˆä¸æ˜¯éªŒè¯è¯·æ±‚ï¼‰
        """
        return None
    
    def handle_webhook(
        self, 
        headers: Dict[str, str], 
        body: bytes,
        data: Dict[str, Any]
    ) -> Tuple[Optional[BotMessage], Optional[WebhookResponse]]:
        """
        å¤„ç† Webhook è¯·æ±‚
        
        è¿™æ˜¯ä¸»å…¥å£æ–¹æ³•ï¼Œåè°ƒéªŒè¯ã€è§£æç­‰æµç¨‹ã€‚
        
        Args:
            headers: HTTP è¯·æ±‚å¤´
            body: è¯·æ±‚ä½“åŸå§‹å­—èŠ‚
            data: è§£æåçš„ JSON æ•°æ®
            
        Returns:
            (BotMessage, WebhookResponse) å…ƒç»„
            - å¦‚æœæ˜¯éªŒè¯è¯·æ±‚ï¼š(None, challenge_response)
            - å¦‚æœæ˜¯æ™®é€šæ¶ˆæ¯ï¼š(message, None) - å“åº”å°†åœ¨å‘½ä»¤å¤„ç†åç”Ÿæˆ
            - å¦‚æœéªŒè¯å¤±è´¥æˆ–æ— éœ€å¤„ç†ï¼š(None, error_response æˆ– None)
        """
        # 1. æ£€æŸ¥æ˜¯å¦æ˜¯éªŒè¯è¯·æ±‚
        challenge_response = self.handle_challenge(data)
        if challenge_response:
            return None, challenge_response
        
        # 2. éªŒè¯è¯·æ±‚ç­¾å
        if not self.verify_request(headers, body):
            return None, WebhookResponse.error("Invalid signature", 403)
        
        # 3. è§£ææ¶ˆæ¯
        message = self.parse_message(data)
        
        return message, None

--------------------

#File: bot/commands/market.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
å¤§ç›˜å¤ç›˜å‘½ä»¤
===================================

æ‰§è¡Œå¤§ç›˜å¤ç›˜åˆ†æï¼Œç”Ÿæˆå¸‚åœºæ¦‚è§ˆæŠ¥å‘Šã€‚
"""

import logging
import threading
from typing import List

from bot.commands.base import BotCommand
from bot.models import BotMessage, BotResponse

logger = logging.getLogger(__name__)


class MarketCommand(BotCommand):
    """
    å¤§ç›˜å¤ç›˜å‘½ä»¤
    
    æ‰§è¡Œå¤§ç›˜å¤ç›˜åˆ†æï¼ŒåŒ…æ‹¬ï¼š
    - ä¸»è¦æŒ‡æ•°è¡¨ç°
    - æ¿å—çƒ­ç‚¹
    - å¸‚åœºæƒ…ç»ª
    - åå¸‚å±•æœ›
    
    ç”¨æ³•ï¼š
        /market - æ‰§è¡Œå¤§ç›˜å¤ç›˜
    """

    @property
    def name(self) -> str:
        return "market"

    @property
    def aliases(self) -> List[str]:
        return ["m", "å¤§ç›˜", "å¤ç›˜", "è¡Œæƒ…"]

    @property
    def description(self) -> str:
        return "å¤§ç›˜å¤ç›˜åˆ†æ"

    @property
    def usage(self) -> str:
        return "/market"

    def execute(self, message: BotMessage, args: List[str]) -> BotResponse:
        """æ‰§è¡Œå¤§ç›˜å¤ç›˜å‘½ä»¤"""
        logger.info(f"[MarketCommand] å¼€å§‹å¤§ç›˜å¤ç›˜åˆ†æ")

        # åœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œå¤ç›˜ï¼ˆé¿å…é˜»å¡ï¼‰
        thread = threading.Thread(
            target=self._run_market_review,
            args=(message,),
            daemon=True
        )
        thread.start()

        return BotResponse.markdown_response(
            "âœ… **å¤§ç›˜å¤ç›˜ä»»åŠ¡å·²å¯åŠ¨**\n\n"
            "æ­£åœ¨åˆ†æï¼š\n"
            "â€¢ ä¸»è¦æŒ‡æ•°è¡¨ç°\n"
            "â€¢ æ¿å—çƒ­ç‚¹åˆ†æ\n"
            "â€¢ å¸‚åœºæƒ…ç»ªåˆ¤æ–­\n"
            "â€¢ åå¸‚å±•æœ›\n\n"
            "åˆ†æå®Œæˆåå°†è‡ªåŠ¨æ¨é€ç»“æœã€‚"
        )

    def _run_market_review(self, message: BotMessage) -> None:
        """åå°æ‰§è¡Œå¤§ç›˜å¤ç›˜"""
        try:
            from src.config import get_config
            from src.notification import NotificationService
            from src.market_analyzer import MarketAnalyzer
            from src.search_service import SearchService
            from src.analyzer import GeminiAnalyzer

            config = get_config()
            notifier = NotificationService(source_message=message)

            # åˆå§‹åŒ–æœç´¢æœåŠ¡
            search_service = None
            if config.bocha_api_keys or config.tavily_api_keys or config.serpapi_keys:
                search_service = SearchService(
                    bocha_keys=config.bocha_api_keys,
                    tavily_keys=config.tavily_api_keys,
                    serpapi_keys=config.serpapi_keys
                )

            # åˆå§‹åŒ– AI åˆ†æå™¨
            analyzer = None
            if config.gemini_api_key or config.openai_api_key:
                analyzer = GeminiAnalyzer()

            # æ‰§è¡Œå¤ç›˜
            market_analyzer = MarketAnalyzer(
                search_service=search_service,
                analyzer=analyzer
            )

            review_report = market_analyzer.run_daily_review()

            if review_report:
                # æ¨é€ç»“æœ
                report_content = f"ğŸ¯ **å¤§ç›˜å¤ç›˜**\n\n{review_report}"
                notifier.send(report_content)
                logger.info("[MarketCommand] å¤§ç›˜å¤ç›˜å®Œæˆå¹¶å·²æ¨é€")
            else:
                logger.warning("[MarketCommand] å¤§ç›˜å¤ç›˜è¿”å›ç©ºç»“æœ")

        except Exception as e:
            logger.error(f"[MarketCommand] å¤§ç›˜å¤ç›˜å¤±è´¥: {e}")
            logger.exception(e)

--------------------

#File: bot/commands/batch.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
æ‰¹é‡åˆ†æå‘½ä»¤
===================================

æ‰¹é‡åˆ†æè‡ªé€‰è‚¡åˆ—è¡¨ä¸­çš„æ‰€æœ‰è‚¡ç¥¨ã€‚
"""

import logging
import threading
import uuid
from typing import List

from bot.commands.base import BotCommand
from bot.models import BotMessage, BotResponse

logger = logging.getLogger(__name__)


class BatchCommand(BotCommand):
    """
    æ‰¹é‡åˆ†æå‘½ä»¤
    
    æ‰¹é‡åˆ†æé…ç½®ä¸­çš„è‡ªé€‰è‚¡åˆ—è¡¨ï¼Œç”Ÿæˆæ±‡æ€»æŠ¥å‘Šã€‚
    
    ç”¨æ³•ï¼š
        /batch      - åˆ†ææ‰€æœ‰è‡ªé€‰è‚¡
        /batch 3    - åªåˆ†æå‰3åª
    """
    
    @property
    def name(self) -> str:
        return "batch"
    
    @property
    def aliases(self) -> List[str]:
        return ["b", "æ‰¹é‡", "å…¨éƒ¨"]
    
    @property
    def description(self) -> str:
        return "æ‰¹é‡åˆ†æè‡ªé€‰è‚¡"
    
    @property
    def usage(self) -> str:
        return "/batch [æ•°é‡]"
    
    @property
    def admin_only(self) -> bool:
        """æ‰¹é‡åˆ†æéœ€è¦ç®¡ç†å‘˜æƒé™ï¼ˆé˜²æ­¢æ»¥ç”¨ï¼‰"""
        return False  # å¯ä»¥æ ¹æ®éœ€è¦è®¾ä¸º True
    
    def execute(self, message: BotMessage, args: List[str]) -> BotResponse:
        """æ‰§è¡Œæ‰¹é‡åˆ†æå‘½ä»¤"""
        from src.config import get_config
        
        config = get_config()
        config.refresh_stock_list()
        
        stock_list = config.stock_list
        
        if not stock_list:
            return BotResponse.error_response(
                "è‡ªé€‰è‚¡åˆ—è¡¨ä¸ºç©ºï¼Œè¯·å…ˆé…ç½® STOCK_LIST"
            )
        
        # è§£ææ•°é‡å‚æ•°
        limit = None
        if args:
            try:
                limit = int(args[0])
                if limit <= 0:
                    return BotResponse.error_response("æ•°é‡å¿…é¡»å¤§äº0")
            except ValueError:
                return BotResponse.error_response(f"æ— æ•ˆçš„æ•°é‡: {args[0]}")
        
        # é™åˆ¶åˆ†ææ•°é‡
        if limit:
            stock_list = stock_list[:limit]
        
        logger.info(f"[BatchCommand] å¼€å§‹æ‰¹é‡åˆ†æ {len(stock_list)} åªè‚¡ç¥¨")
        
        # åœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œåˆ†æ
        thread = threading.Thread(
            target=self._run_batch_analysis,
            args=(stock_list, message),
            daemon=True
        )
        thread.start()
        
        return BotResponse.markdown_response(
            f"âœ… **æ‰¹é‡åˆ†æä»»åŠ¡å·²å¯åŠ¨**\n\n"
            f"â€¢ åˆ†ææ•°é‡: {len(stock_list)} åª\n"
            f"â€¢ è‚¡ç¥¨åˆ—è¡¨: {', '.join(stock_list[:5])}"
            f"{'...' if len(stock_list) > 5 else ''}\n\n"
            f"åˆ†æå®Œæˆåå°†è‡ªåŠ¨æ¨é€æ±‡æ€»æŠ¥å‘Šã€‚"
        )
    
    def _run_batch_analysis(self, stock_list: List[str], message: BotMessage) -> None:
        """åå°æ‰§è¡Œæ‰¹é‡åˆ†æ"""
        try:
            from src.config import get_config
            from main import StockAnalysisPipeline
            
            config = get_config()
            
            # åˆ›å»ºåˆ†æç®¡é“
            pipeline = StockAnalysisPipeline(
                config=config,
                source_message=message,
                query_id=uuid.uuid4().hex,
                query_source="bot"
            )
            
            # æ‰§è¡Œåˆ†æï¼ˆä¼šè‡ªåŠ¨æ¨é€æ±‡æ€»æŠ¥å‘Šï¼‰
            results = pipeline.run(
                stock_codes=stock_list,
                dry_run=False,
                send_notification=True
            )
            
            logger.info(f"[BatchCommand] æ‰¹é‡åˆ†æå®Œæˆï¼ŒæˆåŠŸ {len(results)} åª")
            
        except Exception as e:
            logger.error(f"[BatchCommand] æ‰¹é‡åˆ†æå¤±è´¥: {e}")
            logger.exception(e)

--------------------

#File: bot/commands/__init__.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
å‘½ä»¤å¤„ç†å™¨æ¨¡å—
===================================

åŒ…å«æ‰€æœ‰æœºå™¨äººå‘½ä»¤çš„å®ç°ã€‚
"""

from bot.commands.base import BotCommand
from bot.commands.help import HelpCommand
from bot.commands.status import StatusCommand
from bot.commands.analyze import AnalyzeCommand
from bot.commands.market import MarketCommand
from bot.commands.batch import BatchCommand

# æ‰€æœ‰å¯ç”¨å‘½ä»¤ï¼ˆç”¨äºè‡ªåŠ¨æ³¨å†Œï¼‰
ALL_COMMANDS = [
    HelpCommand,
    StatusCommand,
    AnalyzeCommand,
    MarketCommand,
    BatchCommand,
]

__all__ = [
    'BotCommand',
    'HelpCommand',
    'StatusCommand',
    'AnalyzeCommand',
    'MarketCommand',
    'BatchCommand',
    'ALL_COMMANDS',
]

--------------------

#File: bot/commands/help.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
å¸®åŠ©å‘½ä»¤
===================================

æ˜¾ç¤ºå¯ç”¨å‘½ä»¤åˆ—è¡¨å’Œä½¿ç”¨è¯´æ˜ã€‚
"""

from typing import List

from bot.commands.base import BotCommand
from bot.models import BotMessage, BotResponse


class HelpCommand(BotCommand):
    """
    å¸®åŠ©å‘½ä»¤
    
    æ˜¾ç¤ºæ‰€æœ‰å¯ç”¨å‘½ä»¤çš„åˆ—è¡¨å’Œä½¿ç”¨è¯´æ˜ã€‚
    ä¹Ÿå¯ä»¥æŸ¥çœ‹ç‰¹å®šå‘½ä»¤çš„è¯¦ç»†å¸®åŠ©ã€‚
    
    ç”¨æ³•ï¼š
        /help         - æ˜¾ç¤ºæ‰€æœ‰å‘½ä»¤
        /help analyze - æ˜¾ç¤º analyze å‘½ä»¤çš„è¯¦ç»†å¸®åŠ©
    """
    
    @property
    def name(self) -> str:
        return "help"
    
    @property
    def aliases(self) -> List[str]:
        return ["h", "å¸®åŠ©", "?"]
    
    @property
    def description(self) -> str:
        return "æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"
    
    @property
    def usage(self) -> str:
        return "/help [å‘½ä»¤å]"
    
    def execute(self, message: BotMessage, args: List[str]) -> BotResponse:
        """æ‰§è¡Œå¸®åŠ©å‘½ä»¤"""
        # å»¶è¿Ÿå¯¼å…¥é¿å…å¾ªç¯ä¾èµ–
        from bot.dispatcher import get_dispatcher
        
        dispatcher = get_dispatcher()
        
        # å¦‚æœæŒ‡å®šäº†å‘½ä»¤åï¼Œæ˜¾ç¤ºè¯¥å‘½ä»¤çš„è¯¦ç»†å¸®åŠ©
        if args:
            cmd_name = args[0]
            command = dispatcher.get_command(cmd_name)
            
            if command is None:
                return BotResponse.error_response(f"æœªçŸ¥å‘½ä»¤: {cmd_name}")
            
            # æ„å»ºè¯¦ç»†å¸®åŠ©
            help_text = self._format_command_help(command, dispatcher.command_prefix)
            return BotResponse.markdown_response(help_text)
        
        # æ˜¾ç¤ºæ‰€æœ‰å‘½ä»¤åˆ—è¡¨
        commands = dispatcher.list_commands(include_hidden=False)
        prefix = dispatcher.command_prefix
        
        help_text = self._format_help_list(commands, prefix)
        return BotResponse.markdown_response(help_text)
    
    def _format_help_list(self, commands: List[BotCommand], prefix: str) -> str:
        """æ ¼å¼åŒ–å‘½ä»¤åˆ—è¡¨"""
        lines = [
            "ğŸ“š **è‚¡ç¥¨åˆ†æåŠ©æ‰‹ - å‘½ä»¤å¸®åŠ©**",
            "",
            "å¯ç”¨å‘½ä»¤ï¼š",
            "",
        ]
        
        for cmd in commands:
            # å‘½ä»¤åå’Œåˆ«å
            aliases_str = ""
            if cmd.aliases:
                # è¿‡æ»¤æ‰ä¸­æ–‡åˆ«åï¼Œåªæ˜¾ç¤ºè‹±æ–‡åˆ«å
                en_aliases = [a for a in cmd.aliases if a.isascii()]
                if en_aliases:
                    aliases_str = f" ({', '.join(prefix + a for a in en_aliases[:2])})"
            
            lines.append(f"â€¢ {prefix}{cmd.name}{aliases_str} - {cmd.description}")
            lines.append("")

        lines.extend([
            "",
            "---",
            f"ğŸ’¡ è¾“å…¥ {prefix}help <å‘½ä»¤å> æŸ¥çœ‹è¯¦ç»†ç”¨æ³•",
            "",
            "**ç¤ºä¾‹ï¼š**",
            "",
            f"â€¢ {prefix}analyze 301023 - å¥•å¸†ä¼ åŠ¨",
            "",
            f"â€¢ {prefix}market - æŸ¥çœ‹å¤§ç›˜å¤ç›˜",
            "",
            f"â€¢ {prefix}batch - æ‰¹é‡åˆ†æè‡ªé€‰è‚¡",
        ])
        
        return "\n".join(lines)
    
    def _format_command_help(self, command: BotCommand, prefix: str) -> str:
        """æ ¼å¼åŒ–å•ä¸ªå‘½ä»¤çš„è¯¦ç»†å¸®åŠ©"""
        lines = [
            f"ğŸ“– **{prefix}{command.name}** - {command.description}",
            "",
            f"**ç”¨æ³•ï¼š** `{command.usage}`",
            "",
        ]
        
        # åˆ«å
        if command.aliases:
            aliases = [f"`{prefix}{a}`" if a.isascii() else f"`{a}`" for a in command.aliases]
            lines.append(f"**åˆ«åï¼š** {', '.join(aliases)}")
            lines.append("")
        
        # æƒé™
        if command.admin_only:
            lines.append("âš ï¸ **éœ€è¦ç®¡ç†å‘˜æƒé™**")
            lines.append("")
        
        return "\n".join(lines)

--------------------

#File: bot/commands/base.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
å‘½ä»¤åŸºç±»
===================================

å®šä¹‰å‘½ä»¤å¤„ç†å™¨çš„æŠ½è±¡åŸºç±»ï¼Œæ‰€æœ‰å‘½ä»¤éƒ½å¿…é¡»ç»§æ‰¿æ­¤ç±»ã€‚
"""

from abc import ABC, abstractmethod
from typing import List, Optional

from bot.models import BotMessage, BotResponse


class BotCommand(ABC):
    """
    å‘½ä»¤å¤„ç†å™¨æŠ½è±¡åŸºç±»
    
    æ‰€æœ‰å‘½ä»¤éƒ½å¿…é¡»ç»§æ‰¿æ­¤ç±»å¹¶å®ç°æŠ½è±¡æ–¹æ³•ã€‚
    
    ä½¿ç”¨ç¤ºä¾‹ï¼š
        class MyCommand(BotCommand):
            @property
            def name(self) -> str:
                return "mycommand"
            
            @property
            def aliases(self) -> List[str]:
                return ["mc", "æˆ‘çš„å‘½ä»¤"]
            
            @property
            def description(self) -> str:
                return "è¿™æ˜¯æˆ‘çš„å‘½ä»¤"
            
            @property
            def usage(self) -> str:
                return "/mycommand [å‚æ•°]"
            
            def execute(self, message: BotMessage, args: List[str]) -> BotResponse:
                return BotResponse.text_response("å‘½ä»¤æ‰§è¡ŒæˆåŠŸ")
    """
    
    @property
    @abstractmethod
    def name(self) -> str:
        """
        å‘½ä»¤åç§°ï¼ˆä¸å«å‰ç¼€ï¼‰
        
        ä¾‹å¦‚ "analyze"ï¼Œç”¨æˆ·è¾“å…¥ "/analyze" è§¦å‘
        """
        pass
    
    @property
    @abstractmethod
    def aliases(self) -> List[str]:
        """
        å‘½ä»¤åˆ«ååˆ—è¡¨
        
        ä¾‹å¦‚ ["a", "åˆ†æ"]ï¼Œç”¨æˆ·è¾“å…¥ "/a" æˆ– "åˆ†æ" ä¹Ÿèƒ½è§¦å‘
        """
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        """å‘½ä»¤æè¿°ï¼ˆç”¨äºå¸®åŠ©ä¿¡æ¯ï¼‰"""
        pass
    
    @property
    @abstractmethod
    def usage(self) -> str:
        """
        ä½¿ç”¨è¯´æ˜ï¼ˆç”¨äºå¸®åŠ©ä¿¡æ¯ï¼‰
        
        ä¾‹å¦‚ "/analyze <è‚¡ç¥¨ä»£ç >"
        """
        pass
    
    @property
    def hidden(self) -> bool:
        """
        æ˜¯å¦åœ¨å¸®åŠ©åˆ—è¡¨ä¸­éšè—
        
        é»˜è®¤ Falseï¼Œè®¾ä¸º True åˆ™ä¸æ˜¾ç¤ºåœ¨ /help åˆ—è¡¨ä¸­
        """
        return False
    
    @property
    def admin_only(self) -> bool:
        """
        æ˜¯å¦ä»…ç®¡ç†å‘˜å¯ç”¨
        
        é»˜è®¤ Falseï¼Œè®¾ä¸º True åˆ™éœ€è¦ç®¡ç†å‘˜æƒé™
        """
        return False
    
    @abstractmethod
    def execute(self, message: BotMessage, args: List[str]) -> BotResponse:
        """
        æ‰§è¡Œå‘½ä»¤
        
        Args:
            message: åŸå§‹æ¶ˆæ¯å¯¹è±¡
            args: å‘½ä»¤å‚æ•°åˆ—è¡¨ï¼ˆå·²åˆ†å‰²ï¼‰
            
        Returns:
            BotResponse å“åº”å¯¹è±¡
        """
        pass
    
    def validate_args(self, args: List[str]) -> Optional[str]:
        """
        éªŒè¯å‚æ•°
        
        å­ç±»å¯é‡å†™æ­¤æ–¹æ³•è¿›è¡Œå‚æ•°æ ¡éªŒã€‚
        
        Args:
            args: å‘½ä»¤å‚æ•°åˆ—è¡¨
            
        Returns:
            å¦‚æœå‚æ•°æœ‰æ•ˆè¿”å› Noneï¼Œå¦åˆ™è¿”å›é”™è¯¯ä¿¡æ¯
        """
        return None
    
    def get_help_text(self) -> str:
        """è·å–å¸®åŠ©æ–‡æœ¬"""
        return f"**{self.name}** - {self.description}\nç”¨æ³•: `{self.usage}`"

--------------------

#File: bot/commands/analyze.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
è‚¡ç¥¨åˆ†æå‘½ä»¤
===================================

åˆ†ææŒ‡å®šè‚¡ç¥¨ï¼Œè°ƒç”¨ AI ç”Ÿæˆåˆ†ææŠ¥å‘Šã€‚
"""

import re
import logging
from typing import List, Optional

from bot.commands.base import BotCommand
from bot.models import BotMessage, BotResponse

logger = logging.getLogger(__name__)


class AnalyzeCommand(BotCommand):
    """
    è‚¡ç¥¨åˆ†æå‘½ä»¤
    
    åˆ†ææŒ‡å®šè‚¡ç¥¨ä»£ç ï¼Œç”Ÿæˆ AI åˆ†ææŠ¥å‘Šå¹¶æ¨é€ã€‚
    
    ç”¨æ³•ï¼š
        /analyze 600519       - åˆ†æè´µå·èŒ…å°
        /analyze 600519 full  - åˆ†æå¹¶ç”Ÿæˆå®Œæ•´æŠ¥å‘Š
    """
    
    @property
    def name(self) -> str:
        return "analyze"
    
    @property
    def aliases(self) -> List[str]:
        return ["a", "åˆ†æ", "æŸ¥"]
    
    @property
    def description(self) -> str:
        return "åˆ†ææŒ‡å®šè‚¡ç¥¨"
    
    @property
    def usage(self) -> str:
        return "/analyze <è‚¡ç¥¨ä»£ç > [full]"
    
    def validate_args(self, args: List[str]) -> Optional[str]:
        """éªŒè¯å‚æ•°"""
        if not args:
            return "è¯·è¾“å…¥è‚¡ç¥¨ä»£ç "
        
        code = args[0].upper()

        # éªŒè¯è‚¡ç¥¨ä»£ç æ ¼å¼
        # Aè‚¡ï¼š6ä½æ•°å­—
        # æ¸¯è‚¡ï¼šHK+5ä½æ•°å­—
        # ç¾è‚¡ï¼š1-5ä¸ªå¤§å†™å­—æ¯+.+2ä¸ªåç¼€å­—æ¯
        is_a_stock = re.match(r'^\d{6}$', code)
        is_hk_stock = re.match(r'^HK\d{5}$', code)
        is_us_stock = re.match(r'^[A-Z]{1,5}(\.[A-Z]{1,2})?$', code)

        if not (is_a_stock or is_hk_stock or is_us_stock):
            return f"æ— æ•ˆçš„è‚¡ç¥¨ä»£ç : {code}ï¼ˆAè‚¡6ä½æ•°å­— / æ¸¯è‚¡HK+5ä½æ•°å­— / ç¾è‚¡1-5ä¸ªå­—æ¯ï¼‰"
        
        return None
    
    def execute(self, message: BotMessage, args: List[str]) -> BotResponse:
        """æ‰§è¡Œåˆ†æå‘½ä»¤"""
        code = args[0].lower()
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦å®Œæ•´æŠ¥å‘Š
        report_type = "full"
        # if len(args) > 1 and args[1].lower() in ["full", "å®Œæ•´", "è¯¦ç»†"]:
        #     report_type = "full"
        logger.info(f"[AnalyzeCommand] åˆ†æè‚¡ç¥¨: {code}, æŠ¥å‘Šç±»å‹: {report_type}")
        
        try:
            # è°ƒç”¨åˆ†ææœåŠ¡
            from web.services import get_analysis_service
            from src.enums import ReportType
            
            service = get_analysis_service()
            
            # æäº¤å¼‚æ­¥åˆ†æä»»åŠ¡
            result = service.submit_analysis(
                code=code,
                report_type=ReportType.from_str(report_type),
                source_message=message
            )
            
            if result.get("success"):
                task_id = result.get("task_id", "")
                return BotResponse.markdown_response(
                    f"âœ… **åˆ†æä»»åŠ¡å·²æäº¤**\n\n"
                    f"â€¢ è‚¡ç¥¨ä»£ç : `{code}`\n"
                    f"â€¢ æŠ¥å‘Šç±»å‹: {ReportType.from_str(report_type).display_name}\n"
                    f"â€¢ ä»»åŠ¡ ID: `{task_id[:20]}...`\n\n"
                    f"åˆ†æå®Œæˆåå°†è‡ªåŠ¨æ¨é€ç»“æœã€‚"
                )
            else:
                error = result.get("error", "æœªçŸ¥é”™è¯¯")
                return BotResponse.error_response(f"æäº¤åˆ†æä»»åŠ¡å¤±è´¥: {error}")
                
        except Exception as e:
            logger.error(f"[AnalyzeCommand] æ‰§è¡Œå¤±è´¥: {e}")
            return BotResponse.error_response(f"åˆ†æå¤±è´¥: {str(e)[:100]}")

--------------------

#File: bot/commands/status.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
çŠ¶æ€å‘½ä»¤
===================================

æ˜¾ç¤ºç³»ç»Ÿè¿è¡ŒçŠ¶æ€å’Œé…ç½®ä¿¡æ¯ã€‚
"""

import platform
import sys
from datetime import datetime
from typing import List

from bot.commands.base import BotCommand
from bot.models import BotMessage, BotResponse


class StatusCommand(BotCommand):
    """
    çŠ¶æ€å‘½ä»¤
    
    æ˜¾ç¤ºç³»ç»Ÿè¿è¡ŒçŠ¶æ€ï¼ŒåŒ…æ‹¬ï¼š
    - æœåŠ¡çŠ¶æ€
    - é…ç½®ä¿¡æ¯
    - å¯ç”¨åŠŸèƒ½
    """
    
    @property
    def name(self) -> str:
        return "status"
    
    @property
    def aliases(self) -> List[str]:
        return ["s", "çŠ¶æ€", "info"]
    
    @property
    def description(self) -> str:
        return "æ˜¾ç¤ºç³»ç»ŸçŠ¶æ€"
    
    @property
    def usage(self) -> str:
        return "/status"
    
    def execute(self, message: BotMessage, args: List[str]) -> BotResponse:
        """æ‰§è¡ŒçŠ¶æ€å‘½ä»¤"""
        from src.config import get_config
        
        config = get_config()
        
        # æ”¶é›†çŠ¶æ€ä¿¡æ¯
        status_info = self._collect_status(config)
        
        # æ ¼å¼åŒ–è¾“å‡º
        text = self._format_status(status_info, message.platform)
        
        return BotResponse.markdown_response(text)
    
    def _collect_status(self, config) -> dict:
        """æ”¶é›†ç³»ç»ŸçŠ¶æ€ä¿¡æ¯"""
        status = {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "python_version": f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
            "platform": platform.system(),
            "stock_count": len(config.stock_list),
            "stock_list": config.stock_list[:5],  # åªæ˜¾ç¤ºå‰5ä¸ª
        }
        
        # AI é…ç½®çŠ¶æ€
        status["ai_gemini"] = bool(config.gemini_api_key)
        status["ai_openai"] = bool(config.openai_api_key)
        
        # æœç´¢æœåŠ¡çŠ¶æ€
        status["search_bocha"] = len(config.bocha_api_keys) > 0
        status["search_tavily"] = len(config.tavily_api_keys) > 0
        status["search_serpapi"] = len(config.serpapi_keys) > 0
        
        # é€šçŸ¥æ¸ é“çŠ¶æ€
        status["notify_wechat"] = bool(config.wechat_webhook_url)
        status["notify_feishu"] = bool(config.feishu_webhook_url)
        status["notify_telegram"] = bool(config.telegram_bot_token and config.telegram_chat_id)
        status["notify_email"] = bool(config.email_sender and config.email_password)
        
        return status
    
    def _format_status(self, status: dict, platform: str) -> str:
        """æ ¼å¼åŒ–çŠ¶æ€ä¿¡æ¯"""
        # çŠ¶æ€å›¾æ ‡
        def icon(enabled: bool) -> str:
            return "âœ…" if enabled else "âŒ"
        
        lines = [
            "ğŸ“Š **è‚¡ç¥¨åˆ†æåŠ©æ‰‹ - ç³»ç»ŸçŠ¶æ€**",
            "",
            f"ğŸ• æ—¶é—´: {status['timestamp']}",
            f"ğŸ Python: {status['python_version']}",
            f"ğŸ’» å¹³å°: {status['platform']}",
            "",
            "---",
            "",
            "**ğŸ“ˆ è‡ªé€‰è‚¡é…ç½®**",
            f"â€¢ è‚¡ç¥¨æ•°é‡: {status['stock_count']} åª",
        ]
        
        if status['stock_list']:
            stocks_preview = ", ".join(status['stock_list'])
            if status['stock_count'] > 5:
                stocks_preview += f" ... ç­‰ {status['stock_count']} åª"
            lines.append(f"â€¢ è‚¡ç¥¨åˆ—è¡¨: {stocks_preview}")
        
        lines.extend([
            "",
            "**ğŸ¤– AI åˆ†ææœåŠ¡**",
            f"â€¢ Gemini API: {icon(status['ai_gemini'])}",
            f"â€¢ OpenAI API: {icon(status['ai_openai'])}",
            "",
            "**ğŸ” æœç´¢æœåŠ¡**",
            f"â€¢ Bocha: {icon(status['search_bocha'])}",
            f"â€¢ Tavily: {icon(status['search_tavily'])}",
            f"â€¢ SerpAPI: {icon(status['search_serpapi'])}",
            "",
            "**ğŸ“¢ é€šçŸ¥æ¸ é“**",
            f"â€¢ ä¼ä¸šå¾®ä¿¡: {icon(status['notify_wechat'])}",
            f"â€¢ é£ä¹¦: {icon(status['notify_feishu'])}",
            f"â€¢ Telegram: {icon(status['notify_telegram'])}",
            f"â€¢ é‚®ä»¶: {icon(status['notify_email'])}",
        ])
        
        # AI æœåŠ¡æ€»ä½“çŠ¶æ€
        ai_available = status['ai_gemini'] or status['ai_openai']
        if ai_available:
            lines.extend([
                "",
                "---",
                "âœ… **ç³»ç»Ÿå°±ç»ªï¼Œå¯ä»¥å¼€å§‹åˆ†æï¼**",
            ])
        else:
            lines.extend([
                "",
                "---",
                "âš ï¸ **AI æœåŠ¡æœªé…ç½®ï¼Œåˆ†æåŠŸèƒ½ä¸å¯ç”¨**",
                "è¯·é…ç½® Gemini æˆ– OpenAI API Key",
            ])
        
        return "\n".join(lines)

--------------------

#File: data_provider/realtime_types.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
å®æ—¶è¡Œæƒ…ç»Ÿä¸€ç±»å‹å®šä¹‰ & ç†”æ–­æœºåˆ¶
===================================

è®¾è®¡ç›®æ ‡ï¼š
1. ç»Ÿä¸€å„æ•°æ®æºçš„å®æ—¶è¡Œæƒ…è¿”å›ç»“æ„
2. å®ç°ç†”æ–­/å†·å´æœºåˆ¶ï¼Œé¿å…è¿ç»­å¤±è´¥æ—¶åå¤è¯·æ±‚
3. æ”¯æŒå¤šæ•°æ®æºæ•…éšœåˆ‡æ¢

ä½¿ç”¨æ–¹å¼ï¼š
- æ‰€æœ‰ Fetcher çš„ get_realtime_quote() ç»Ÿä¸€è¿”å› UnifiedRealtimeQuote
- CircuitBreaker ç®¡ç†å„æ•°æ®æºçš„ç†”æ–­çŠ¶æ€
"""

import logging
import time
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, Union
from enum import Enum

logger = logging.getLogger(__name__)


# ============================================
# é€šç”¨ç±»å‹è½¬æ¢å·¥å…·å‡½æ•°
# ============================================
# è®¾è®¡è¯´æ˜ï¼š
# å„æ•°æ®æºè¿”å›çš„åŸå§‹æ•°æ®ç±»å‹ä¸ä¸€è‡´ï¼ˆstr/float/int/NaNï¼‰ï¼Œ
# ä½¿ç”¨è¿™äº›å‡½æ•°ç»Ÿä¸€è½¬æ¢ï¼Œé¿å…åœ¨å„ Fetcher ä¸­é‡å¤å®šä¹‰ã€‚

def safe_float(val: Any, default: Optional[float] = None) -> Optional[float]:
    """
    å®‰å…¨è½¬æ¢ä¸ºæµ®ç‚¹æ•°
    
    å¤„ç†åœºæ™¯ï¼š
    - None / ç©ºå­—ç¬¦ä¸² â†’ default
    - pandas NaN / numpy NaN â†’ default
    - æ•°å€¼å­—ç¬¦ä¸² â†’ float
    - å·²æ˜¯æ•°å€¼ â†’ float
    
    Args:
        val: å¾…è½¬æ¢çš„å€¼
        default: è½¬æ¢å¤±è´¥æ—¶çš„é»˜è®¤å€¼
        
    Returns:
        è½¬æ¢åçš„æµ®ç‚¹æ•°ï¼Œæˆ–é»˜è®¤å€¼
    """
    try:
        if val is None:
            return default
        
        # å¤„ç†å­—ç¬¦ä¸²
        if isinstance(val, str):
            val = val.strip()
            if val == "" or val == "-" or val == "--":
                return default
        
        # å¤„ç† pandas/numpy NaN
        # ä½¿ç”¨ math.isnan è€Œä¸æ˜¯ pd.isnaï¼Œé¿å…å¼ºåˆ¶ä¾èµ– pandas
        import math
        try:
            if math.isnan(float(val)):
                return default
        except (ValueError, TypeError):
            pass
        
        return float(val)
    except (ValueError, TypeError):
        return default


def safe_int(val: Any, default: Optional[int] = None) -> Optional[int]:
    """
    å®‰å…¨è½¬æ¢ä¸ºæ•´æ•°
    
    å…ˆè½¬æ¢ä¸º floatï¼Œå†å–æ•´ï¼Œå¤„ç† "123.0" è¿™ç±»æƒ…å†µ
    
    Args:
        val: å¾…è½¬æ¢çš„å€¼
        default: è½¬æ¢å¤±è´¥æ—¶çš„é»˜è®¤å€¼
        
    Returns:
        è½¬æ¢åçš„æ•´æ•°ï¼Œæˆ–é»˜è®¤å€¼
    """
    f_val = safe_float(val, default=None)
    if f_val is not None:
        return int(f_val)
    return default


class RealtimeSource(Enum):
    """å®æ—¶è¡Œæƒ…æ•°æ®æº"""
    EFINANCE = "efinance"           # ä¸œæ–¹è´¢å¯Œï¼ˆefinanceåº“ï¼‰
    AKSHARE_EM = "akshare_em"       # ä¸œæ–¹è´¢å¯Œï¼ˆakshareåº“ï¼‰
    AKSHARE_SINA = "akshare_sina"   # æ–°æµªè´¢ç»
    AKSHARE_QQ = "akshare_qq"       # è…¾è®¯è´¢ç»
    TUSHARE = "tushare"             # Tushare Pro
    TENCENT = "tencent"             # è…¾è®¯ç›´è¿
    SINA = "sina"                   # æ–°æµªç›´è¿
    FALLBACK = "fallback"           # é™çº§å…œåº•


@dataclass
class UnifiedRealtimeQuote:
    """
    ç»Ÿä¸€å®æ—¶è¡Œæƒ…æ•°æ®ç»“æ„
    
    è®¾è®¡åŸåˆ™ï¼š
    - å„æ•°æ®æºè¿”å›çš„å­—æ®µå¯èƒ½ä¸åŒï¼Œç¼ºå¤±å­—æ®µç”¨ None è¡¨ç¤º
    - ä¸»æµç¨‹ä½¿ç”¨ getattr(quote, field, None) è·å–ï¼Œä¿è¯å…¼å®¹æ€§
    - source å­—æ®µæ ‡è®°æ•°æ®æ¥æºï¼Œä¾¿äºè°ƒè¯•
    """
    code: str
    name: str = ""
    source: RealtimeSource = RealtimeSource.FALLBACK
    
    # === æ ¸å¿ƒä»·æ ¼æ•°æ®ï¼ˆå‡ ä¹æ‰€æœ‰æºéƒ½æœ‰ï¼‰===
    price: Optional[float] = None           # æœ€æ–°ä»·
    change_pct: Optional[float] = None      # æ¶¨è·Œå¹…(%)
    change_amount: Optional[float] = None   # æ¶¨è·Œé¢
    
    # === é‡ä»·æŒ‡æ ‡ï¼ˆéƒ¨åˆ†æºå¯èƒ½ç¼ºå¤±ï¼‰===
    volume: Optional[int] = None            # æˆäº¤é‡ï¼ˆæ‰‹ï¼‰
    amount: Optional[float] = None          # æˆäº¤é¢ï¼ˆå…ƒï¼‰
    volume_ratio: Optional[float] = None    # é‡æ¯”
    turnover_rate: Optional[float] = None   # æ¢æ‰‹ç‡(%)
    amplitude: Optional[float] = None       # æŒ¯å¹…(%)
    
    # === ä»·æ ¼åŒºé—´ ===
    open_price: Optional[float] = None      # å¼€ç›˜ä»·
    high: Optional[float] = None            # æœ€é«˜ä»·
    low: Optional[float] = None             # æœ€ä½ä»·
    pre_close: Optional[float] = None       # æ˜¨æ”¶ä»·
    
    # === ä¼°å€¼æŒ‡æ ‡ï¼ˆä»…ä¸œè´¢ç­‰å…¨é‡æ¥å£æœ‰ï¼‰===
    pe_ratio: Optional[float] = None        # å¸‚ç›ˆç‡(åŠ¨æ€)
    pb_ratio: Optional[float] = None        # å¸‚å‡€ç‡
    total_mv: Optional[float] = None        # æ€»å¸‚å€¼(å…ƒ)
    circ_mv: Optional[float] = None         # æµé€šå¸‚å€¼(å…ƒ)
    
    # === å…¶ä»–æŒ‡æ ‡ ===
    change_60d: Optional[float] = None      # 60æ—¥æ¶¨è·Œå¹…(%)
    high_52w: Optional[float] = None        # 52å‘¨æœ€é«˜
    low_52w: Optional[float] = None         # 52å‘¨æœ€ä½
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸ï¼ˆè¿‡æ»¤ None å€¼ï¼‰"""
        result = {
            'code': self.code,
            'name': self.name,
            'source': self.source.value,
        }
        # åªæ·»åŠ é None çš„å­—æ®µ
        optional_fields = [
            'price', 'change_pct', 'change_amount', 'volume', 'amount',
            'volume_ratio', 'turnover_rate', 'amplitude',
            'open_price', 'high', 'low', 'pre_close',
            'pe_ratio', 'pb_ratio', 'total_mv', 'circ_mv',
            'change_60d', 'high_52w', 'low_52w'
        ]
        for f in optional_fields:
            val = getattr(self, f, None)
            if val is not None:
                result[f] = val
        return result
    
    def has_basic_data(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦æœ‰åŸºæœ¬çš„ä»·æ ¼æ•°æ®"""
        return self.price is not None and self.price > 0
    
    def has_volume_data(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦æœ‰é‡ä»·æ•°æ®"""
        return self.volume_ratio is not None or self.turnover_rate is not None


@dataclass
class ChipDistribution:
    """
    ç­¹ç åˆ†å¸ƒæ•°æ®
    
    åæ˜ æŒä»“æˆæœ¬åˆ†å¸ƒå’Œè·åˆ©æƒ…å†µ
    """
    code: str
    date: str = ""
    source: str = "akshare"
    
    # è·åˆ©æƒ…å†µ
    profit_ratio: float = 0.0     # è·åˆ©æ¯”ä¾‹(0-1)
    avg_cost: float = 0.0         # å¹³å‡æˆæœ¬
    
    # ç­¹ç é›†ä¸­åº¦
    cost_90_low: float = 0.0      # 90%ç­¹ç æˆæœ¬ä¸‹é™
    cost_90_high: float = 0.0     # 90%ç­¹ç æˆæœ¬ä¸Šé™
    concentration_90: float = 0.0  # 90%ç­¹ç é›†ä¸­åº¦ï¼ˆè¶Šå°è¶Šé›†ä¸­ï¼‰
    
    cost_70_low: float = 0.0      # 70%ç­¹ç æˆæœ¬ä¸‹é™
    cost_70_high: float = 0.0     # 70%ç­¹ç æˆæœ¬ä¸Šé™
    concentration_70: float = 0.0  # 70%ç­¹ç é›†ä¸­åº¦
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            'code': self.code,
            'date': self.date,
            'source': self.source,
            'profit_ratio': self.profit_ratio,
            'avg_cost': self.avg_cost,
            'cost_90_low': self.cost_90_low,
            'cost_90_high': self.cost_90_high,
            'concentration_90': self.concentration_90,
            'concentration_70': self.concentration_70,
        }
    
    def get_chip_status(self, current_price: float) -> str:
        """
        è·å–ç­¹ç çŠ¶æ€æè¿°
        
        Args:
            current_price: å½“å‰è‚¡ä»·
            
        Returns:
            ç­¹ç çŠ¶æ€æè¿°
        """
        status_parts = []
        
        # è·åˆ©æ¯”ä¾‹åˆ†æ
        if self.profit_ratio >= 0.9:
            status_parts.append("è·åˆ©ç›˜æé«˜(>90%)")
        elif self.profit_ratio >= 0.7:
            status_parts.append("è·åˆ©ç›˜è¾ƒé«˜(70-90%)")
        elif self.profit_ratio >= 0.5:
            status_parts.append("è·åˆ©ç›˜ä¸­ç­‰(50-70%)")
        elif self.profit_ratio >= 0.3:
            status_parts.append("å¥—ç‰¢ç›˜è¾ƒå¤š(>30%)")
        else:
            status_parts.append("å¥—ç‰¢ç›˜æé‡(>70%)")
        
        # ç­¹ç é›†ä¸­åº¦åˆ†æ (90%é›†ä¸­åº¦ < 10% è¡¨ç¤ºé›†ä¸­)
        if self.concentration_90 < 0.08:
            status_parts.append("ç­¹ç é«˜åº¦é›†ä¸­")
        elif self.concentration_90 < 0.15:
            status_parts.append("ç­¹ç è¾ƒé›†ä¸­")
        elif self.concentration_90 < 0.25:
            status_parts.append("ç­¹ç åˆ†æ•£åº¦ä¸­ç­‰")
        else:
            status_parts.append("ç­¹ç è¾ƒåˆ†æ•£")
        
        # æˆæœ¬ä¸ç°ä»·å…³ç³»
        if current_price > 0 and self.avg_cost > 0:
            cost_diff = (current_price - self.avg_cost) / self.avg_cost * 100
            if cost_diff > 20:
                status_parts.append(f"ç°ä»·é«˜äºå¹³å‡æˆæœ¬{cost_diff:.1f}%")
            elif cost_diff > 5:
                status_parts.append(f"ç°ä»·ç•¥é«˜äºæˆæœ¬{cost_diff:.1f}%")
            elif cost_diff > -5:
                status_parts.append("ç°ä»·æ¥è¿‘å¹³å‡æˆæœ¬")
            else:
                status_parts.append(f"ç°ä»·ä½äºå¹³å‡æˆæœ¬{abs(cost_diff):.1f}%")
        
        return "ï¼Œ".join(status_parts)


class CircuitBreaker:
    """
    ç†”æ–­å™¨ - ç®¡ç†æ•°æ®æºçš„ç†”æ–­/å†·å´çŠ¶æ€
    
    ç­–ç•¥ï¼š
    - è¿ç»­å¤±è´¥ N æ¬¡åè¿›å…¥ç†”æ–­çŠ¶æ€
    - ç†”æ–­æœŸé—´è·³è¿‡è¯¥æ•°æ®æº
    - å†·å´æ—¶é—´åè‡ªåŠ¨æ¢å¤åŠå¼€çŠ¶æ€
    - åŠå¼€çŠ¶æ€ä¸‹å•æ¬¡æˆåŠŸåˆ™å®Œå…¨æ¢å¤ï¼Œå¤±è´¥åˆ™ç»§ç»­ç†”æ–­
    
    çŠ¶æ€æœºï¼š
    CLOSEDï¼ˆæ­£å¸¸ï¼‰ --å¤±è´¥Næ¬¡--> OPENï¼ˆç†”æ–­ï¼‰--å†·å´æ—¶é—´åˆ°--> HALF_OPENï¼ˆåŠå¼€ï¼‰
    HALF_OPEN --æˆåŠŸ--> CLOSED
    HALF_OPEN --å¤±è´¥--> OPEN
    """
    
    # çŠ¶æ€å¸¸é‡
    CLOSED = "closed"      # æ­£å¸¸çŠ¶æ€
    OPEN = "open"          # ç†”æ–­çŠ¶æ€ï¼ˆä¸å¯ç”¨ï¼‰
    HALF_OPEN = "half_open"  # åŠå¼€çŠ¶æ€ï¼ˆè¯•æ¢æ€§è¯·æ±‚ï¼‰
    
    def __init__(
        self,
        failure_threshold: int = 3,       # è¿ç»­å¤±è´¥æ¬¡æ•°é˜ˆå€¼
        cooldown_seconds: float = 300.0,  # å†·å´æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤5åˆ†é’Ÿ
        half_open_max_calls: int = 1      # åŠå¼€çŠ¶æ€æœ€å¤§å°è¯•æ¬¡æ•°
    ):
        self.failure_threshold = failure_threshold
        self.cooldown_seconds = cooldown_seconds
        self.half_open_max_calls = half_open_max_calls
        
        # å„æ•°æ®æºçŠ¶æ€ {source_name: {state, failures, last_failure_time, half_open_calls}}
        self._states: Dict[str, Dict[str, Any]] = {}
    
    def _get_state(self, source: str) -> Dict[str, Any]:
        """è·å–æˆ–åˆå§‹åŒ–æ•°æ®æºçŠ¶æ€"""
        if source not in self._states:
            self._states[source] = {
                'state': self.CLOSED,
                'failures': 0,
                'last_failure_time': 0.0,
                'half_open_calls': 0
            }
        return self._states[source]
    
    def is_available(self, source: str) -> bool:
        """
        æ£€æŸ¥æ•°æ®æºæ˜¯å¦å¯ç”¨
        
        è¿”å› True è¡¨ç¤ºå¯ä»¥å°è¯•è¯·æ±‚
        è¿”å› False è¡¨ç¤ºåº”è·³è¿‡è¯¥æ•°æ®æº
        """
        state = self._get_state(source)
        current_time = time.time()
        
        if state['state'] == self.CLOSED:
            return True
        
        if state['state'] == self.OPEN:
            # æ£€æŸ¥å†·å´æ—¶é—´
            time_since_failure = current_time - state['last_failure_time']
            if time_since_failure >= self.cooldown_seconds:
                # å†·å´å®Œæˆï¼Œè¿›å…¥åŠå¼€çŠ¶æ€
                state['state'] = self.HALF_OPEN
                state['half_open_calls'] = 0
                logger.info(f"[ç†”æ–­å™¨] {source} å†·å´å®Œæˆï¼Œè¿›å…¥åŠå¼€çŠ¶æ€")
                return True
            else:
                remaining = self.cooldown_seconds - time_since_failure
                logger.debug(f"[ç†”æ–­å™¨] {source} å¤„äºç†”æ–­çŠ¶æ€ï¼Œå‰©ä½™å†·å´æ—¶é—´: {remaining:.0f}s")
                return False
        
        if state['state'] == self.HALF_OPEN:
            # åŠå¼€çŠ¶æ€ä¸‹é™åˆ¶è¯·æ±‚æ¬¡æ•°
            if state['half_open_calls'] < self.half_open_max_calls:
                return True
            return False
        
        return True
    
    def record_success(self, source: str) -> None:
        """è®°å½•æˆåŠŸè¯·æ±‚"""
        state = self._get_state(source)
        
        if state['state'] == self.HALF_OPEN:
            # åŠå¼€çŠ¶æ€ä¸‹æˆåŠŸï¼Œå®Œå…¨æ¢å¤
            logger.info(f"[ç†”æ–­å™¨] {source} åŠå¼€çŠ¶æ€è¯·æ±‚æˆåŠŸï¼Œæ¢å¤æ­£å¸¸")
        
        # é‡ç½®çŠ¶æ€
        state['state'] = self.CLOSED
        state['failures'] = 0
        state['half_open_calls'] = 0
    
    def record_failure(self, source: str, error: Optional[str] = None) -> None:
        """è®°å½•å¤±è´¥è¯·æ±‚"""
        state = self._get_state(source)
        current_time = time.time()
        
        state['failures'] += 1
        state['last_failure_time'] = current_time
        
        if state['state'] == self.HALF_OPEN:
            # åŠå¼€çŠ¶æ€ä¸‹å¤±è´¥ï¼Œç»§ç»­ç†”æ–­
            state['state'] = self.OPEN
            state['half_open_calls'] = 0
            logger.warning(f"[ç†”æ–­å™¨] {source} åŠå¼€çŠ¶æ€è¯·æ±‚å¤±è´¥ï¼Œç»§ç»­ç†”æ–­ {self.cooldown_seconds}s")
        elif state['failures'] >= self.failure_threshold:
            # è¾¾åˆ°é˜ˆå€¼ï¼Œè¿›å…¥ç†”æ–­
            state['state'] = self.OPEN
            logger.warning(f"[ç†”æ–­å™¨] {source} è¿ç»­å¤±è´¥ {state['failures']} æ¬¡ï¼Œè¿›å…¥ç†”æ–­çŠ¶æ€ "
                          f"(å†·å´ {self.cooldown_seconds}s)")
            if error:
                logger.warning(f"[ç†”æ–­å™¨] æœ€åé”™è¯¯: {error}")
    
    def get_status(self) -> Dict[str, str]:
        """è·å–æ‰€æœ‰æ•°æ®æºçŠ¶æ€"""
        return {source: info['state'] for source, info in self._states.items()}
    
    def reset(self, source: Optional[str] = None) -> None:
        """é‡ç½®ç†”æ–­å™¨çŠ¶æ€"""
        if source:
            if source in self._states:
                del self._states[source]
        else:
            self._states.clear()


# å…¨å±€ç†”æ–­å™¨å®ä¾‹ï¼ˆå®æ—¶è¡Œæƒ…ä¸“ç”¨ï¼‰
_realtime_circuit_breaker = CircuitBreaker(
    failure_threshold=3,      # è¿ç»­å¤±è´¥3æ¬¡ç†”æ–­
    cooldown_seconds=300.0,   # å†·å´5åˆ†é’Ÿ
    half_open_max_calls=1
)

# ç­¹ç æ¥å£ç†”æ–­å™¨ï¼ˆæ›´ä¿å®ˆçš„ç­–ç•¥ï¼Œå› ä¸ºè¯¥æ¥å£æ›´ä¸ç¨³å®šï¼‰
_chip_circuit_breaker = CircuitBreaker(
    failure_threshold=2,      # è¿ç»­å¤±è´¥2æ¬¡ç†”æ–­
    cooldown_seconds=600.0,   # å†·å´10åˆ†é’Ÿ
    half_open_max_calls=1
)


def get_realtime_circuit_breaker() -> CircuitBreaker:
    """è·å–å®æ—¶è¡Œæƒ…ç†”æ–­å™¨"""
    return _realtime_circuit_breaker


def get_chip_circuit_breaker() -> CircuitBreaker:
    """è·å–ç­¹ç æ¥å£ç†”æ–­å™¨"""
    return _chip_circuit_breaker

--------------------

#File: data_provider/yfinance_fetcher.py
--------------------
# -*- coding: utf-8 -*-
import logging
import re
import time
import random
from datetime import datetime
from typing import Optional

import pandas as pd
from tenacity import retry, stop_after_attempt, wait_fixed

from .base import BaseFetcher, DataFetchError, STANDARD_COLUMNS
import os

logger = logging.getLogger(__name__)

class YfinanceFetcher(BaseFetcher):
    name = "YfinanceFetcher"
    priority = 4
    
    def _convert_stock_code(self, stock_code: str) -> str:
        """
        è½¬æ¢ä¸º Yahoo Finance æ ¼å¼:
        600519 -> 600519.SS
        000001 -> 000001.SZ
        AAPL -> AAPL
        """
        code = stock_code.strip().upper()
        # ç¾è‚¡ç›´æ¥è¿”å›
        if re.match(r'^[A-Z]{1,5}(\.[A-Z])?$', code): return code
        
        # æ¸¯è‚¡
        if code.startswith('HK'): return f"{code[2:].lstrip('0').zfill(4)}.HK"
        
        # Aè‚¡
        if '.' in code: # å·²ç»æœ‰åç¼€
             if code.endswith('.SH'): return code.replace('.SH', '.SS') # Yahooç”¨SS
             return code
        
        if code.startswith(('6', '5', '9')): return f"{code}.SS"
        return f"{code}.SZ"

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
    def _fetch_raw_data(self, stock_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        import yfinance as yf
        
        # é™é€Ÿ
        self.random_sleep(1.0, 2.0)
        
        yf_code = self._convert_stock_code(stock_code)
        
        try:
            # auto_adjust=True è‡ªåŠ¨å¤æƒ
            df = yf.download(
                tickers=yf_code,
                start=start_date,
                end=end_date,
                progress=False,
                auto_adjust=True,
                timeout=10
            )
            
            if df.empty:
                raise DataFetchError("Yfinanceæ•°æ®ä¸ºç©º")
                
            return df
        except Exception as e:
            raise DataFetchError(f"Yfinanceå¼‚å¸¸: {e}")

    def _normalize_data(self, df: pd.DataFrame, stock_code: str) -> pd.DataFrame:
        if df.empty: return df
        df = df.copy()
        
        # 1. å¤„ç† yfinance æ–°ç‰ˆè¿”å›çš„ MultiIndex åˆ—å (Price, Ticker)
        if isinstance(df.columns, pd.MultiIndex):
            df.columns = df.columns.get_level_values(0)
        
        # 2. ç´¢å¼•å˜åˆ—
        df = df.reset_index()
        
        # 3. æ˜ å°„
        mapping = {
            'Date': 'date', 'Open': 'open', 'High': 'high', 
            'Low': 'low', 'Close': 'close', 'Volume': 'volume'
        }
        df = df.rename(columns=mapping)
        
        # 4. å…³é”®ï¼šå»é™¤æ—¶åŒºï¼Œå¦åˆ™å’Œ A è‚¡æ•°æ®åˆå¹¶æ—¶ä¼šæŠ¥é”™
        if 'date' in df.columns and df['date'].dt.tz is not None:
             df['date'] = df['date'].dt.tz_localize(None)

        # 5. è®¡ç®—ç¼ºå¤±åˆ—
        if 'pct_chg' not in df.columns:
            df['pct_chg'] = df['close'].pct_change() * 100
            df['pct_chg'] = df['pct_chg'].fillna(0).round(2)
            
        if 'amount' not in df.columns:
            df['amount'] = df['close'] * df['volume']

        df['code'] = stock_code
        
        # è¿‡æ»¤éœ€è¦çš„åˆ—
        cols = [c for c in STANDARD_COLUMNS if c in df.columns]
        return df[cols + ['code']]

--------------------

#File: data_provider/akshare_fetcher.py
--------------------
# -*- coding: utf-8 -*-
import logging
import time
import random
import re
from typing import Optional, Dict, Any

import pandas as pd
from tenacity import retry, stop_after_attempt, wait_exponential

from .base import BaseFetcher, DataFetchError, STANDARD_COLUMNS
from .realtime_types import (
    UnifiedRealtimeQuote, ChipDistribution, RealtimeSource,
    get_realtime_circuit_breaker, safe_float, safe_int
)
from src.config import get_config  # å¼•å…¥é…ç½®

logger = logging.getLogger(__name__)

# User-Agent æ± 
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
]

# ç¼“å­˜
_realtime_cache: Dict[str, Any] = {'data': None, 'timestamp': 0, 'ttl': 1200}
_etf_realtime_cache: Dict[str, Any] = {'data': None, 'timestamp': 0, 'ttl': 1200}

def _is_etf_code(code): return code.startswith(('51', '52', '56', '58', '15', '16', '18')) and len(code) == 6
def _is_hk_code(code): return code.lower().startswith('hk') or (code.isdigit() and len(code)==5)
def _is_us_code(code): return bool(re.match(r'^[A-Z]{1,5}(\.[A-Z])?$', code.strip().upper()))

class AkshareFetcher(BaseFetcher):
    name = "AkshareFetcher"
    priority = 1
    
    def __init__(self):
        # ğŸ”¥ ä»é…ç½®ä¸­è¯»å–ä¼‘çœ å‚æ•°ï¼Œè€Œä¸æ˜¯ç¡¬ç¼–ç 
        config = get_config()
        self.sleep_min = config.akshare_sleep_min
        self.sleep_max = config.akshare_sleep_max
        self._last_request_time = None
    
    def _set_random_user_agent(self): pass 
    
    def _enforce_rate_limit(self):
        if self._last_request_time:
            elapsed = time.time() - self._last_request_time
            if elapsed < self.sleep_min:
                time.sleep(self.sleep_min - elapsed)
        self.random_sleep(self.sleep_min, self.sleep_max)
        self._last_request_time = time.time()
    
    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))
    def _fetch_raw_data(self, stock_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        if _is_us_code(stock_code): return self._fetch_us_data(stock_code, start_date, end_date)
        if _is_hk_code(stock_code): return self._fetch_hk_data(stock_code, start_date, end_date)
        if _is_etf_code(stock_code): return self._fetch_etf_data(stock_code, start_date, end_date)
        
        # Aè‚¡å¤šæºå°è¯•ï¼šä¸œè´¢ -> æ–°æµª -> è…¾è®¯
        methods = [
            (self._fetch_stock_data_em, "ä¸œæ–¹è´¢å¯Œ"),
            (self._fetch_stock_data_sina, "æ–°æµªè´¢ç»"),
            (self._fetch_stock_data_tx, "è…¾è®¯è´¢ç»"),
        ]
        
        last_error = None
        for method, name in methods:
            try:
                df = method(stock_code, start_date, end_date)
                if df is not None and not df.empty: return df
            except Exception as e:
                last_error = e
                continue
        raise DataFetchError(f"Akshareæ‰€æœ‰æºå¤±è´¥: {last_error}")

    def _fetch_stock_data_em(self, code, start, end):
        import akshare as ak
        self._enforce_rate_limit()
        return ak.stock_zh_a_hist(symbol=code, period="daily", start_date=start.replace('-',''), end_date=end.replace('-',''), adjust="qfq")

    def _fetch_stock_data_sina(self, code, start, end):
        import akshare as ak
        self._enforce_rate_limit()
        symbol = f"sh{code}" if code.startswith(('6','5','9')) else f"sz{code}"
        df = ak.stock_zh_a_daily(symbol=symbol, start_date=start.replace('-',''), end_date=end.replace('-',''), adjust="qfq")
        if df is not None: 
            df = df.rename(columns={'date':'æ—¥æœŸ', 'open':'å¼€ç›˜', 'high':'æœ€é«˜', 'low':'æœ€ä½', 'close':'æ”¶ç›˜', 'volume':'æˆäº¤é‡', 'amount':'æˆäº¤é¢'})
        return df

    def _fetch_stock_data_tx(self, code, start, end):
        import akshare as ak
        self._enforce_rate_limit()
        symbol = f"sh{code}" if code.startswith(('6','5','9')) else f"sz{code}"
        df = ak.stock_zh_a_hist_tx(symbol=symbol, start_date=start.replace('-',''), end_date=end.replace('-',''), adjust="qfq")
        if df is not None:
             df = df.rename(columns={'date':'æ—¥æœŸ', 'open':'å¼€ç›˜', 'high':'æœ€é«˜', 'low':'æœ€ä½', 'close':'æ”¶ç›˜', 'volume':'æˆäº¤é‡', 'amount':'æˆäº¤é¢'})
        return df

    def _fetch_etf_data(self, code, start, end):
        import akshare as ak
        self._enforce_rate_limit()
        return ak.fund_etf_hist_em(symbol=code, period="daily", start_date=start.replace('-',''), end_date=end.replace('-',''), adjust="qfq")
        
    def _fetch_us_data(self, code, start, end):
        import akshare as ak
        self._enforce_rate_limit()
        df = ak.stock_us_daily(symbol=code.strip().upper(), adjust="qfq")
        if df is not None:
            df = df.rename(columns={'date':'æ—¥æœŸ', 'open':'å¼€ç›˜', 'high':'æœ€é«˜', 'low':'æœ€ä½', 'close':'æ”¶ç›˜', 'volume':'æˆäº¤é‡'})
            df['æ—¥æœŸ'] = pd.to_datetime(df['æ—¥æœŸ'])
            df = df[(df['æ—¥æœŸ'] >= pd.to_datetime(start)) & (df['æ—¥æœŸ'] <= pd.to_datetime(end))]
        return df

    def _fetch_hk_data(self, code, start, end):
        import akshare as ak
        self._enforce_rate_limit()
        code = code.lower().replace('hk', '').zfill(5)
        return ak.stock_hk_hist(symbol=code, period="daily", start_date=start.replace('-',''), end_date=end.replace('-',''), adjust="qfq")

    def _normalize_data(self, df, code):
        if df is None or df.empty: return df
        df = df.copy()
        mapping = {'æ—¥æœŸ': 'date', 'å¼€ç›˜': 'open', 'æ”¶ç›˜': 'close', 'æœ€é«˜': 'high', 'æœ€ä½': 'low', 'æˆäº¤é‡': 'volume', 'æˆäº¤é¢': 'amount', 'æ¶¨è·Œå¹…': 'pct_chg'}
        df = df.rename(columns=mapping)
        df['code'] = code
        for c in STANDARD_COLUMNS:
            if c not in df.columns: df[c] = 0
        return df[STANDARD_COLUMNS + ['code']]

    def get_realtime_quote(self, stock_code: str, source: str = "em") -> Optional[UnifiedRealtimeQuote]:
        if _is_us_code(stock_code): return None
        if _is_hk_code(stock_code): return None
        if _is_etf_code(stock_code): return self._get_etf_realtime_quote(stock_code)
        
        circuit_breaker = get_realtime_circuit_breaker()
        if not circuit_breaker.is_available(f"akshare_{source}"): return None
        
        try:
            if source == "sina": return self._get_sina_quote(stock_code)
            if source == "tencent": return self._get_tencent_quote(stock_code)
            return self._get_em_quote(stock_code)
        except Exception as e:
            circuit_breaker.record_failure(f"akshare_{source}", str(e))
            return None

    def _get_em_quote(self, stock_code):
        import akshare as ak
        circuit_breaker = get_realtime_circuit_breaker()
        current_time = time.time()
        if _realtime_cache['data'] is not None and current_time - _realtime_cache['timestamp'] < _realtime_cache['ttl']:
            df = _realtime_cache['data']
        else:
            self._enforce_rate_limit()
            df = ak.stock_zh_a_spot_em()
            _realtime_cache['data'] = df
            _realtime_cache['timestamp'] = current_time
            circuit_breaker.record_success("akshare_em")

        row = df[df['ä»£ç '] == stock_code]
        if row.empty: return None
        row = row.iloc[0]
        return UnifiedRealtimeQuote(
            code=stock_code, name=str(row.get('åç§°')), source=RealtimeSource.AKSHARE_EM,
            price=safe_float(row.get('æœ€æ–°ä»·')), change_pct=safe_float(row.get('æ¶¨è·Œå¹…')),
            volume=safe_int(row.get('æˆäº¤é‡')), amount=safe_float(row.get('æˆäº¤é¢')),
            volume_ratio=safe_float(row.get('é‡æ¯”')), turnover_rate=safe_float(row.get('æ¢æ‰‹ç‡')),
            pe_ratio=safe_float(row.get('å¸‚ç›ˆç‡-åŠ¨æ€')), total_mv=safe_float(row.get('æ€»å¸‚å€¼'))
        )

    def _get_sina_quote(self, stock_code):
        import requests
        symbol = f"sh{stock_code}" if stock_code.startswith(('6', '5', '9')) else f"sz{stock_code}"
        url = f"http://hq.sinajs.cn/list={symbol}"
        headers = {'Referer': 'http://finance.sina.com.cn'}
        self.random_sleep(0.1, 0.5) 
        resp = requests.get(url, headers=headers, timeout=5)
        if resp.status_code != 200: return None
        data = resp.text.split('="')[1].strip('";\n').split(',')
        if len(data) < 30: return None
        
        price = safe_float(data[3])
        pre = safe_float(data[2])
        pct = (price - pre) / pre * 100 if pre > 0 else 0
        return UnifiedRealtimeQuote(
            code=stock_code, name=data[0], source=RealtimeSource.AKSHARE_SINA,
            price=price, change_pct=pct, open_price=safe_float(data[1]),
            high=safe_float(data[4]), low=safe_float(data[5]),
            volume=safe_int(data[8]), amount=safe_float(data[9]), pre_close=pre
        )

    def _get_tencent_quote(self, stock_code):
        import requests
        symbol = f"sh{stock_code}" if stock_code.startswith(('6', '5', '9')) else f"sz{stock_code}"
        url = f"http://qt.gtimg.cn/q={symbol}"
        self.random_sleep(0.1, 0.5)
        resp = requests.get(url, timeout=5)
        if resp.status_code != 200: return None
        data = resp.text.split('="')[1].strip('";\n').split('~')
        if len(data) < 40: return None
        
        return UnifiedRealtimeQuote(
            code=stock_code, name=data[1], source=RealtimeSource.TENCENT,
            price=safe_float(data[3]), change_pct=safe_float(data[32]),
            volume=safe_int(data[6])*100, amount=safe_float(data[37])*10000,
            turnover_rate=safe_float(data[38]), pe_ratio=safe_float(data[39]),
            total_mv=safe_float(data[45])*100000000
        )

    def _get_etf_realtime_quote(self, stock_code):
        import akshare as ak
        current_time = time.time()
        if _etf_realtime_cache['data'] is not None and current_time - _etf_realtime_cache['timestamp'] < _etf_realtime_cache['ttl']:
            df = _etf_realtime_cache['data']
        else:
            self._enforce_rate_limit()
            df = ak.fund_etf_spot_em()
            _etf_realtime_cache['data'] = df
            _etf_realtime_cache['timestamp'] = current_time
            
        row = df[df['ä»£ç '] == stock_code]
        if row.empty: return None
        row = row.iloc[0]
        return UnifiedRealtimeQuote(
            code=stock_code, name=str(row.get('åç§°')), source=RealtimeSource.AKSHARE_EM,
            price=safe_float(row.get('æœ€æ–°ä»·')), change_pct=safe_float(row.get('æ¶¨è·Œå¹…'))
        )

    def get_chip_distribution(self, stock_code: str) -> Optional[ChipDistribution]:
        """è·å–ç­¹ç åˆ†å¸ƒ"""
        import akshare as ak
        
        # ğŸ”¥ æ ¹æ®é…ç½®åˆ¤æ–­æ˜¯å¦å¼€å¯ç­¹ç åŠŸèƒ½
        config = get_config()
        if not config.enable_chip_distribution: return None

        if _is_us_code(stock_code) or _is_etf_code(stock_code): return None
        
        try:
            self._enforce_rate_limit()
            df = ak.stock_cyq_em(symbol=stock_code)
            if df is None or df.empty: return None
            
            latest = df.iloc[-1]
            return ChipDistribution(
                code=stock_code,
                date=str(latest.get('æ—¥æœŸ', '')),
                profit_ratio=safe_float(latest.get('è·åˆ©æ¯”ä¾‹')),
                avg_cost=safe_float(latest.get('å¹³å‡æˆæœ¬')),
                concentration_90=safe_float(latest.get('90é›†ä¸­åº¦')),
                concentration_70=safe_float(latest.get('70é›†ä¸­åº¦'))
            )
        except Exception as e:
            logger.warning(f"ç­¹ç åˆ†å¸ƒè·å–å¤±è´¥ {stock_code}: {e}")
            return None

--------------------

#File: data_provider/efinance_fetcher.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
EfinanceFetcher - ä¼˜å…ˆæ•°æ®æº (Priority 0)
===================================

æ•°æ®æ¥æºï¼šä¸œæ–¹è´¢å¯Œçˆ¬è™«ï¼ˆé€šè¿‡ efinance åº“ï¼‰
ç‰¹ç‚¹ï¼šå…è´¹ã€æ— éœ€ Tokenã€æ•°æ®å…¨é¢ã€API ç®€æ´
ä»“åº“ï¼šhttps://github.com/Micro-sheep/efinance

ä¸ AkshareFetcher ç±»ä¼¼ï¼Œä½† efinance åº“ï¼š
1. API æ›´ç®€æ´æ˜“ç”¨
2. æ”¯æŒæ‰¹é‡è·å–æ•°æ®
3. æ›´ç¨³å®šçš„æ¥å£å°è£…

é˜²å°ç¦ç­–ç•¥ï¼š
1. æ¯æ¬¡è¯·æ±‚å‰éšæœºä¼‘çœ  1.5-3.0 ç§’
2. éšæœºè½®æ¢ User-Agent
3. ä½¿ç”¨ tenacity å®ç°æŒ‡æ•°é€€é¿é‡è¯•
4. ç†”æ–­å™¨æœºåˆ¶ï¼šè¿ç»­å¤±è´¥åè‡ªåŠ¨å†·å´
"""

import logging
import os
import random
import re
import time
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List

import pandas as pd
import requests  # å¼•å…¥ requests ä»¥æ•è·å¼‚å¸¸
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type,
    before_sleep_log,
)

from .base import BaseFetcher, DataFetchError, RateLimitError, STANDARD_COLUMNS
from .realtime_types import (
    UnifiedRealtimeQuote, RealtimeSource,
    get_realtime_circuit_breaker,
    safe_float, safe_int  # ä½¿ç”¨ç»Ÿä¸€çš„ç±»å‹è½¬æ¢å‡½æ•°
)


# ä¿ç•™æ—§çš„ç±»å‹åˆ«åï¼Œç”¨äºå‘åå…¼å®¹
@dataclass
class EfinanceRealtimeQuote:
    """
    å®æ—¶è¡Œæƒ…æ•°æ®ï¼ˆæ¥è‡ª efinanceï¼‰- å‘åå…¼å®¹åˆ«å
    
    æ–°ä»£ç å»ºè®®ä½¿ç”¨ UnifiedRealtimeQuote
    """
    code: str
    name: str = ""
    price: float = 0.0           # æœ€æ–°ä»·
    change_pct: float = 0.0      # æ¶¨è·Œå¹…(%)
    change_amount: float = 0.0   # æ¶¨è·Œé¢
    
    # é‡ä»·æŒ‡æ ‡
    volume: int = 0              # æˆäº¤é‡
    amount: float = 0.0          # æˆäº¤é¢
    turnover_rate: float = 0.0   # æ¢æ‰‹ç‡(%)
    amplitude: float = 0.0       # æŒ¯å¹…(%)
    
    # ä»·æ ¼åŒºé—´
    high: float = 0.0            # æœ€é«˜ä»·
    low: float = 0.0             # æœ€ä½ä»·
    open_price: float = 0.0      # å¼€ç›˜ä»·
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            'code': self.code,
            'name': self.name,
            'price': self.price,
            'change_pct': self.change_pct,
            'change_amount': self.change_amount,
            'volume': self.volume,
            'amount': self.amount,
            'turnover_rate': self.turnover_rate,
            'amplitude': self.amplitude,
            'high': self.high,
            'low': self.low,
            'open': self.open_price,
        }


logger = logging.getLogger(__name__)


# User-Agent æ± ï¼Œç”¨äºéšæœºè½®æ¢
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
]


# ç¼“å­˜å®æ—¶è¡Œæƒ…æ•°æ®ï¼ˆé¿å…é‡å¤è¯·æ±‚ï¼‰
# TTL è®¾ä¸º 10 åˆ†é’Ÿ (600ç§’)ï¼šæ‰¹é‡åˆ†æåœºæ™¯ä¸‹é¿å…é‡å¤æ‹‰å–
_realtime_cache: Dict[str, Any] = {
    'data': None,
    'timestamp': 0,
    'ttl': 600  # 10åˆ†é’Ÿç¼“å­˜æœ‰æ•ˆæœŸ
}


def _is_etf_code(stock_code: str) -> bool:
    """
    åˆ¤æ–­ä»£ç æ˜¯å¦ä¸º ETF åŸºé‡‘
    
    ETF ä»£ç è§„åˆ™ï¼š
    - ä¸Šäº¤æ‰€ ETF: 51xxxx, 52xxxx, 56xxxx, 58xxxx
    - æ·±äº¤æ‰€ ETF: 15xxxx, 16xxxx, 18xxxx
    
    Args:
        stock_code: è‚¡ç¥¨/åŸºé‡‘ä»£ç 
        
    Returns:
        True è¡¨ç¤ºæ˜¯ ETF ä»£ç ï¼ŒFalse è¡¨ç¤ºæ˜¯æ™®é€šè‚¡ç¥¨ä»£ç 
    """
    etf_prefixes = ('51', '52', '56', '58', '15', '16', '18')
    return stock_code.startswith(etf_prefixes) and len(stock_code) == 6


def _is_us_code(stock_code: str) -> bool:
    """
    åˆ¤æ–­ä»£ç æ˜¯å¦ä¸ºç¾è‚¡
    
    ç¾è‚¡ä»£ç è§„åˆ™ï¼š
    - 1-5ä¸ªå¤§å†™å­—æ¯ï¼Œå¦‚ 'AAPL', 'TSLA'
    - å¯èƒ½åŒ…å« '.'ï¼Œå¦‚ 'BRK.B'
    """
    code = stock_code.strip().upper()
    return bool(re.match(r'^[A-Z]{1,5}(\.[A-Z])?$', code))


class EfinanceFetcher(BaseFetcher):
    """
    Efinance æ•°æ®æºå®ç°
    
    ä¼˜å…ˆçº§ï¼š0ï¼ˆæœ€é«˜ï¼Œä¼˜å…ˆäº AkshareFetcherï¼‰
    æ•°æ®æ¥æºï¼šä¸œæ–¹è´¢å¯Œç½‘ï¼ˆé€šè¿‡ efinance åº“å°è£…ï¼‰
    ä»“åº“ï¼šhttps://github.com/Micro-sheep/efinance
    
    ä¸»è¦ APIï¼š
    - ef.stock.get_quote_history(): è·å–å†å² K çº¿æ•°æ®
    - ef.stock.get_base_info(): è·å–è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯
    - ef.stock.get_realtime_quotes(): è·å–å®æ—¶è¡Œæƒ…
    
    å…³é”®ç­–ç•¥ï¼š
    - æ¯æ¬¡è¯·æ±‚å‰éšæœºä¼‘çœ  1.5-3.0 ç§’
    - éšæœº User-Agent è½®æ¢
    - å¤±è´¥åæŒ‡æ•°é€€é¿é‡è¯•ï¼ˆæœ€å¤š3æ¬¡ï¼‰
    """
    
    name = "EfinanceFetcher"
    priority = int(os.getenv("EFINANCE_PRIORITY", "0"))  # æœ€é«˜ä¼˜å…ˆçº§ï¼Œæ’åœ¨ AkshareFetcher ä¹‹å‰
    
    def __init__(self, sleep_min: float = 1.5, sleep_max: float = 3.0):
        """
        åˆå§‹åŒ– EfinanceFetcher
        
        Args:
            sleep_min: æœ€å°ä¼‘çœ æ—¶é—´ï¼ˆç§’ï¼‰
            sleep_max: æœ€å¤§ä¼‘çœ æ—¶é—´ï¼ˆç§’ï¼‰
        """
        self.sleep_min = sleep_min
        self.sleep_max = sleep_max
        self._last_request_time: Optional[float] = None
    
    def _set_random_user_agent(self) -> None:
        """
        è®¾ç½®éšæœº User-Agent
        
        é€šè¿‡ä¿®æ”¹ requests Session çš„ headers å®ç°
        è¿™æ˜¯å…³é”®çš„åçˆ¬ç­–ç•¥ä¹‹ä¸€
        """
        try:
            random_ua = random.choice(USER_AGENTS)
            logger.debug(f"è®¾ç½® User-Agent: {random_ua[:50]}...")
        except Exception as e:
            logger.debug(f"è®¾ç½® User-Agent å¤±è´¥: {e}")
    
    def _enforce_rate_limit(self) -> None:
        """
        å¼ºåˆ¶æ‰§è¡Œé€Ÿç‡é™åˆ¶
        
        ç­–ç•¥ï¼š
        1. æ£€æŸ¥è·ç¦»ä¸Šæ¬¡è¯·æ±‚çš„æ—¶é—´é—´éš”
        2. å¦‚æœé—´éš”ä¸è¶³ï¼Œè¡¥å……ä¼‘çœ æ—¶é—´
        3. ç„¶åå†æ‰§è¡Œéšæœº jitter ä¼‘çœ 
        """
        if self._last_request_time is not None:
            elapsed = time.time() - self._last_request_time
            min_interval = self.sleep_min
            if elapsed < min_interval:
                additional_sleep = min_interval - elapsed
                logger.debug(f"è¡¥å……ä¼‘çœ  {additional_sleep:.2f} ç§’")
                time.sleep(additional_sleep)
        
        # æ‰§è¡Œéšæœº jitter ä¼‘çœ 
        self.random_sleep(self.sleep_min, self.sleep_max)
        self._last_request_time = time.time()
    
    @retry(
        stop=stop_after_attempt(5),  # å¢åŠ åˆ°5æ¬¡
        wait=wait_exponential(multiplier=1, min=4, max=60),  # å¢åŠ ç­‰å¾…æ—¶é—´ï¼š4, 8, 16...
        retry=retry_if_exception_type((
            ConnectionError,
            TimeoutError,
            requests.exceptions.RequestException,
            requests.exceptions.ConnectionError,
            requests.exceptions.ChunkedEncodingError
        )),
        before_sleep=before_sleep_log(logger, logging.WARNING),
    )
    def _fetch_raw_data(self, stock_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        """
        ä» efinance è·å–åŸå§‹æ•°æ®
        
        æ ¹æ®ä»£ç ç±»å‹è‡ªåŠ¨é€‰æ‹© APIï¼š
        - ç¾è‚¡ï¼šä¸æ”¯æŒï¼ŒæŠ›å‡ºå¼‚å¸¸è®© DataFetcherManager åˆ‡æ¢åˆ°å…¶ä»–æ•°æ®æº
        - æ™®é€šè‚¡ç¥¨ï¼šä½¿ç”¨ ef.stock.get_quote_history()
        - ETF åŸºé‡‘ï¼šä½¿ç”¨ ef.fund.get_quote_history()
        
        æµç¨‹ï¼š
        1. åˆ¤æ–­ä»£ç ç±»å‹ï¼ˆç¾è‚¡/è‚¡ç¥¨/ETFï¼‰
        2. è®¾ç½®éšæœº User-Agent
        3. æ‰§è¡Œé€Ÿç‡é™åˆ¶ï¼ˆéšæœºä¼‘çœ ï¼‰
        4. è°ƒç”¨å¯¹åº”çš„ efinance API
        5. å¤„ç†è¿”å›æ•°æ®
        """
        # ç¾è‚¡ä¸æ”¯æŒï¼ŒæŠ›å‡ºå¼‚å¸¸è®© DataFetcherManager åˆ‡æ¢åˆ° AkshareFetcher/YfinanceFetcher
        if _is_us_code(stock_code):
            raise DataFetchError(f"EfinanceFetcher ä¸æ”¯æŒç¾è‚¡ {stock_code}ï¼Œè¯·ä½¿ç”¨ AkshareFetcher æˆ– YfinanceFetcher")
        
        # æ ¹æ®ä»£ç ç±»å‹é€‰æ‹©ä¸åŒçš„è·å–æ–¹æ³•
        if _is_etf_code(stock_code):
            return self._fetch_etf_data(stock_code, start_date, end_date)
        else:
            return self._fetch_stock_data(stock_code, start_date, end_date)
    
    def _fetch_stock_data(self, stock_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        """
        è·å–æ™®é€š A è‚¡å†å²æ•°æ®
        
        æ•°æ®æ¥æºï¼šef.stock.get_quote_history()
        
        API å‚æ•°è¯´æ˜ï¼š
        - stock_codes: è‚¡ç¥¨ä»£ç 
        - beg: å¼€å§‹æ—¥æœŸï¼Œæ ¼å¼ 'YYYYMMDD'
        - end: ç»“æŸæ—¥æœŸï¼Œæ ¼å¼ 'YYYYMMDD'
        - klt: å‘¨æœŸï¼Œ101=æ—¥çº¿
        - fqt: å¤æƒæ–¹å¼ï¼Œ1=å‰å¤æƒ
        """
        import efinance as ef
        
        # é˜²å°ç¦ç­–ç•¥ 1: éšæœº User-Agent
        self._set_random_user_agent()
        
        # é˜²å°ç¦ç­–ç•¥ 2: å¼ºåˆ¶ä¼‘çœ 
        self._enforce_rate_limit()
        
        # æ ¼å¼åŒ–æ—¥æœŸï¼ˆefinance ä½¿ç”¨ YYYYMMDD æ ¼å¼ï¼‰
        beg_date = start_date.replace('-', '')
        end_date_fmt = end_date.replace('-', '')
        
        logger.info(f"[APIè°ƒç”¨] ef.stock.get_quote_history(stock_codes={stock_code}, "
                   f"beg={beg_date}, end={end_date_fmt}, klt=101, fqt=1)")
        
        try:
            import time as _time
            api_start = _time.time()
            
            # è°ƒç”¨ efinance è·å– A è‚¡æ—¥çº¿æ•°æ®
            # klt=101 è·å–æ—¥çº¿æ•°æ®
            # fqt=1 è·å–å‰å¤æƒæ•°æ®
            df = ef.stock.get_quote_history(
                stock_codes=stock_code,
                beg=beg_date,
                end=end_date_fmt,
                klt=101,  # æ—¥çº¿
                fqt=1     # å‰å¤æƒ
            )
            
            api_elapsed = _time.time() - api_start
            
            # è®°å½•è¿”å›æ•°æ®æ‘˜è¦
            if df is not None and not df.empty:
                logger.info(f"[APIè¿”å›] ef.stock.get_quote_history æˆåŠŸ: è¿”å› {len(df)} è¡Œæ•°æ®, è€—æ—¶ {api_elapsed:.2f}s")
                logger.info(f"[APIè¿”å›] åˆ—å: {list(df.columns)}")
                if 'æ—¥æœŸ' in df.columns:
                    logger.info(f"[APIè¿”å›] æ—¥æœŸèŒƒå›´: {df['æ—¥æœŸ'].iloc[0]} ~ {df['æ—¥æœŸ'].iloc[-1]}")
                logger.debug(f"[APIè¿”å›] æœ€æ–°3æ¡æ•°æ®:\n{df.tail(3).to_string()}")
            else:
                logger.warning(f"[APIè¿”å›] ef.stock.get_quote_history è¿”å›ç©ºæ•°æ®, è€—æ—¶ {api_elapsed:.2f}s")
            
            return df
            
        except Exception as e:
            error_msg = str(e).lower()
            
            # æ£€æµ‹åçˆ¬å°ç¦
            if any(keyword in error_msg for keyword in ['banned', 'blocked', 'é¢‘ç‡', 'rate', 'é™åˆ¶']):
                logger.warning(f"æ£€æµ‹åˆ°å¯èƒ½è¢«å°ç¦: {e}")
                raise RateLimitError(f"efinance å¯èƒ½è¢«é™æµ: {e}") from e
            
            raise DataFetchError(f"efinance è·å–æ•°æ®å¤±è´¥: {e}") from e
    
    def _fetch_etf_data(self, stock_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        """
        è·å– ETF åŸºé‡‘å†å²æ•°æ®
        
        æ•°æ®æ¥æºï¼šef.fund.get_quote_history()
        
        Args:
            stock_code: ETF ä»£ç ï¼Œå¦‚ '512400', '159883'
            start_date: å¼€å§‹æ—¥æœŸï¼Œæ ¼å¼ 'YYYY-MM-DD'
            end_date: ç»“æŸæ—¥æœŸï¼Œæ ¼å¼ 'YYYY-MM-DD'
            
        Returns:
            ETF å†å²æ•°æ® DataFrame
        """
        import efinance as ef
        
        # é˜²å°ç¦ç­–ç•¥ 1: éšæœº User-Agent
        self._set_random_user_agent()
        
        # é˜²å°ç¦ç­–ç•¥ 2: å¼ºåˆ¶ä¼‘çœ 
        self._enforce_rate_limit()
        
        # æ ¼å¼åŒ–æ—¥æœŸ
        beg_date = start_date.replace('-', '')
        end_date_fmt = end_date.replace('-', '')
        
        logger.info(f"[APIè°ƒç”¨] ef.fund.get_quote_history(fund_code={stock_code})")
        
        try:
            import time as _time
            api_start = _time.time()
            
            # è°ƒç”¨ efinance è·å– ETF æ—¥çº¿æ•°æ®
            # æ³¨æ„: ef.fund.get_quote_history ä¸æ”¯æŒ beg/end/klt/fqt å‚æ•°
            # å®ƒè¿”å›çš„æ˜¯ NAV æ•°æ®: æ—¥æœŸ, å•ä½å‡€å€¼, ç´¯è®¡å‡€å€¼, æ¶¨è·Œå¹…
            df = ef.fund.get_quote_history(fund_code=stock_code)
            
            # æ‰‹åŠ¨è¿‡æ»¤æ—¥æœŸ
            if df is not None and not df.empty and 'æ—¥æœŸ' in df.columns:
                # ç¡®ä¿æ—¥æœŸåˆ—æ˜¯å­—ç¬¦ä¸²æ ¼å¼ï¼Œä¸”æ ¼å¼åŒ¹é…ç­›é€‰æ¡ä»¶
                # ef è¿”å›çš„æ—¥æœŸé€šå¸¸æ˜¯ 'YYYY-MM-DD'
                mask = (df['æ—¥æœŸ'] >= start_date) & (df['æ—¥æœŸ'] <= end_date)
                df = df[mask].copy()
            
            api_elapsed = _time.time() - api_start
            
            # è®°å½•è¿”å›æ•°æ®æ‘˜è¦
            if df is not None and not df.empty:
                logger.info(f"[APIè¿”å›] ef.fund.get_quote_history æˆåŠŸ: è¿”å› {len(df)} è¡Œæ•°æ®, è€—æ—¶ {api_elapsed:.2f}s")
                logger.info(f"[APIè¿”å›] åˆ—å: {list(df.columns)}")
                if 'æ—¥æœŸ' in df.columns:
                    logger.info(f"[APIè¿”å›] æ—¥æœŸèŒƒå›´: {df['æ—¥æœŸ'].iloc[0]} ~ {df['æ—¥æœŸ'].iloc[-1]}")
                logger.debug(f"[APIè¿”å›] æœ€æ–°3æ¡æ•°æ®:\n{df.tail(3).to_string()}")
            else:
                logger.warning(f"[APIè¿”å›] ef.fund.get_quote_history è¿”å›ç©ºæ•°æ®, è€—æ—¶ {api_elapsed:.2f}s")
            
            return df
            
        except Exception as e:
            error_msg = str(e).lower()
            
            # æ£€æµ‹åçˆ¬å°ç¦
            if any(keyword in error_msg for keyword in ['banned', 'blocked', 'é¢‘ç‡', 'rate', 'é™åˆ¶']):
                logger.warning(f"æ£€æµ‹åˆ°å¯èƒ½è¢«å°ç¦: {e}")
                raise RateLimitError(f"efinance å¯èƒ½è¢«é™æµ: {e}") from e
            
            raise DataFetchError(f"efinance è·å– ETF æ•°æ®å¤±è´¥: {e}") from e
    
    def _normalize_data(self, df: pd.DataFrame, stock_code: str) -> pd.DataFrame:
        """
        æ ‡å‡†åŒ– efinance æ•°æ®
        
        efinance è¿”å›çš„åˆ—åï¼ˆä¸­æ–‡ï¼‰ï¼š
        è‚¡ç¥¨åç§°, è‚¡ç¥¨ä»£ç , æ—¥æœŸ, å¼€ç›˜, æ”¶ç›˜, æœ€é«˜, æœ€ä½, æˆäº¤é‡, æˆäº¤é¢, æŒ¯å¹…, æ¶¨è·Œå¹…, æ¶¨è·Œé¢, æ¢æ‰‹ç‡
        
        éœ€è¦æ˜ å°„åˆ°æ ‡å‡†åˆ—åï¼š
        date, open, high, low, close, volume, amount, pct_chg
        """
        df = df.copy()
        
        # åˆ—åæ˜ å°„ï¼ˆefinance ä¸­æ–‡åˆ—å -> æ ‡å‡†è‹±æ–‡åˆ—åï¼‰
        column_mapping = {
            'æ—¥æœŸ': 'date',
            'å¼€ç›˜': 'open',
            'æ”¶ç›˜': 'close',
            'æœ€é«˜': 'high',
            'æœ€ä½': 'low',
            'æˆäº¤é‡': 'volume',
            'æˆäº¤é¢': 'amount',
            'æ¶¨è·Œå¹…': 'pct_chg',
            'è‚¡ç¥¨ä»£ç ': 'code',
            'è‚¡ç¥¨åç§°': 'name',
            # ETF åŸºé‡‘å¯èƒ½çš„åˆ—å
            'åŸºé‡‘ä»£ç ': 'code',
            'åŸºé‡‘åç§°': 'name',
            'å•ä½å‡€å€¼': 'close',
        }
        
        # é‡å‘½ååˆ—
        df = df.rename(columns=column_mapping)
        
        # å¯¹äº ETF æ•°æ®ï¼ˆåªæœ‰ close/å•ä½å‡€å€¼ï¼‰ï¼Œè¡¥å…¨å…¶ä»– OHLC åˆ—
        # è¿™æ˜¯ä¸€ä¸ªè¿‘ä¼¼å¤„ç†ï¼Œå› ä¸º efinance åŸºé‡‘æ¥å£ä¸æä¾› OHLC æ•°æ®
        if 'close' in df.columns and 'open' not in df.columns:
            df['open'] = df['close']
            df['high'] = df['close']
            df['low'] = df['close']
            
        # è¡¥å…¨ volume å’Œ amountï¼Œå¦‚æœç¼ºå¤±
        if 'volume' not in df.columns:
            df['volume'] = 0
        if 'amount' not in df.columns:
            df['amount'] = 0

        
        # å¦‚æœæ²¡æœ‰ code åˆ—ï¼Œæ‰‹åŠ¨æ·»åŠ 
        if 'code' not in df.columns:
            df['code'] = stock_code
        
        # åªä¿ç•™éœ€è¦çš„åˆ—
        keep_cols = ['code'] + STANDARD_COLUMNS
        existing_cols = [col for col in keep_cols if col in df.columns]
        df = df[existing_cols]
        
        return df
    
    def get_realtime_quote(self, stock_code: str) -> Optional[EfinanceRealtimeQuote]:
        """
        è·å–å®æ—¶è¡Œæƒ…æ•°æ®
        
        æ•°æ®æ¥æºï¼šef.stock.get_realtime_quotes()
        
        Args:
            stock_code: è‚¡ç¥¨ä»£ç 
            
        Returns:
            UnifiedRealtimeQuote å¯¹è±¡ï¼Œè·å–å¤±è´¥è¿”å› None
        """
        import efinance as ef
        circuit_breaker = get_realtime_circuit_breaker()
        source_key = "efinance"
        
        # æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
        if not circuit_breaker.is_available(source_key):
            logger.warning(f"[ç†”æ–­] æ•°æ®æº {source_key} å¤„äºç†”æ–­çŠ¶æ€ï¼Œè·³è¿‡")
            return None
        
        try:
            # æ£€æŸ¥ç¼“å­˜
            current_time = time.time()
            if (_realtime_cache['data'] is not None and 
                current_time - _realtime_cache['timestamp'] < _realtime_cache['ttl']):
                df = _realtime_cache['data']
                cache_age = int(current_time - _realtime_cache['timestamp'])
                logger.debug(f"[ç¼“å­˜å‘½ä¸­] å®æ—¶è¡Œæƒ…(efinance) - ç¼“å­˜å¹´é¾„ {cache_age}s/{_realtime_cache['ttl']}s")
            else:
                # è§¦å‘å…¨é‡åˆ·æ–°
                logger.info(f"[ç¼“å­˜æœªå‘½ä¸­] è§¦å‘å…¨é‡åˆ·æ–° å®æ—¶è¡Œæƒ…(efinance)")
                # é˜²å°ç¦ç­–ç•¥
                self._set_random_user_agent()
                self._enforce_rate_limit()
                
                logger.info(f"[APIè°ƒç”¨] ef.stock.get_realtime_quotes() è·å–å®æ—¶è¡Œæƒ…...")
                import time as _time
                api_start = _time.time()
                
                # efinance çš„å®æ—¶è¡Œæƒ… API
                df = ef.stock.get_realtime_quotes()
                
                api_elapsed = _time.time() - api_start
                logger.info(f"[APIè¿”å›] ef.stock.get_realtime_quotes æˆåŠŸ: è¿”å› {len(df)} åªè‚¡ç¥¨, è€—æ—¶ {api_elapsed:.2f}s")
                circuit_breaker.record_success(source_key)
                
                # æ›´æ–°ç¼“å­˜
                _realtime_cache['data'] = df
                _realtime_cache['timestamp'] = current_time
                logger.info(f"[ç¼“å­˜æ›´æ–°] å®æ—¶è¡Œæƒ…(efinance) ç¼“å­˜å·²åˆ·æ–°ï¼ŒTTL={_realtime_cache['ttl']}s")
            
            # æŸ¥æ‰¾æŒ‡å®šè‚¡ç¥¨
            # efinance è¿”å›çš„åˆ—åå¯èƒ½æ˜¯ 'è‚¡ç¥¨ä»£ç ' æˆ– 'code'
            code_col = 'è‚¡ç¥¨ä»£ç ' if 'è‚¡ç¥¨ä»£ç ' in df.columns else 'code'
            row = df[df[code_col] == stock_code]
            if row.empty:
                logger.warning(f"[APIè¿”å›] æœªæ‰¾åˆ°è‚¡ç¥¨ {stock_code} çš„å®æ—¶è¡Œæƒ…")
                return None
            
            row = row.iloc[0]
            
            # ä½¿ç”¨ realtime_types.py ä¸­çš„ç»Ÿä¸€è½¬æ¢å‡½æ•°
            # è·å–åˆ—åï¼ˆå¯èƒ½æ˜¯ä¸­æ–‡æˆ–è‹±æ–‡ï¼‰
            name_col = 'è‚¡ç¥¨åç§°' if 'è‚¡ç¥¨åç§°' in df.columns else 'name'
            price_col = 'æœ€æ–°ä»·' if 'æœ€æ–°ä»·' in df.columns else 'price'
            pct_col = 'æ¶¨è·Œå¹…' if 'æ¶¨è·Œå¹…' in df.columns else 'pct_chg'
            chg_col = 'æ¶¨è·Œé¢' if 'æ¶¨è·Œé¢' in df.columns else 'change'
            vol_col = 'æˆäº¤é‡' if 'æˆäº¤é‡' in df.columns else 'volume'
            amt_col = 'æˆäº¤é¢' if 'æˆäº¤é¢' in df.columns else 'amount'
            turn_col = 'æ¢æ‰‹ç‡' if 'æ¢æ‰‹ç‡' in df.columns else 'turnover_rate'
            amp_col = 'æŒ¯å¹…' if 'æŒ¯å¹…' in df.columns else 'amplitude'
            high_col = 'æœ€é«˜' if 'æœ€é«˜' in df.columns else 'high'
            low_col = 'æœ€ä½' if 'æœ€ä½' in df.columns else 'low'
            open_col = 'å¼€ç›˜' if 'å¼€ç›˜' in df.columns else 'open'
            # efinance ä¹Ÿè¿”å›é‡æ¯”ã€å¸‚ç›ˆç‡ã€å¸‚å€¼ç­‰å­—æ®µ
            vol_ratio_col = 'é‡æ¯”' if 'é‡æ¯”' in df.columns else 'volume_ratio'
            pe_col = 'å¸‚ç›ˆç‡' if 'å¸‚ç›ˆç‡' in df.columns else 'pe_ratio'
            total_mv_col = 'æ€»å¸‚å€¼' if 'æ€»å¸‚å€¼' in df.columns else 'total_mv'
            circ_mv_col = 'æµé€šå¸‚å€¼' if 'æµé€šå¸‚å€¼' in df.columns else 'circ_mv'
            
            quote = UnifiedRealtimeQuote(
                code=stock_code,
                name=str(row.get(name_col, '')),
                source=RealtimeSource.EFINANCE,
                price=safe_float(row.get(price_col)),
                change_pct=safe_float(row.get(pct_col)),
                change_amount=safe_float(row.get(chg_col)),
                volume=safe_int(row.get(vol_col)),
                amount=safe_float(row.get(amt_col)),
                turnover_rate=safe_float(row.get(turn_col)),
                amplitude=safe_float(row.get(amp_col)),
                high=safe_float(row.get(high_col)),
                low=safe_float(row.get(low_col)),
                open_price=safe_float(row.get(open_col)),
                volume_ratio=safe_float(row.get(vol_ratio_col)),  # é‡æ¯”
                pe_ratio=safe_float(row.get(pe_col)),  # å¸‚ç›ˆç‡
                total_mv=safe_float(row.get(total_mv_col)),  # æ€»å¸‚å€¼
                circ_mv=safe_float(row.get(circ_mv_col)),  # æµé€šå¸‚å€¼
            )
            
            logger.info(f"[å®æ—¶è¡Œæƒ…-efinance] {stock_code} {quote.name}: ä»·æ ¼={quote.price}, æ¶¨è·Œ={quote.change_pct}%, "
                       f"é‡æ¯”={quote.volume_ratio}, æ¢æ‰‹ç‡={quote.turnover_rate}%")
            return quote
            
        except Exception as e:
            logger.error(f"[APIé”™è¯¯] è·å– {stock_code} å®æ—¶è¡Œæƒ…(efinance)å¤±è´¥: {e}")
            circuit_breaker.record_failure(source_key, str(e))
            return None
    
    def get_base_info(self, stock_code: str) -> Optional[Dict[str, Any]]:
        """
        è·å–è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯
        
        æ•°æ®æ¥æºï¼šef.stock.get_base_info()
        åŒ…å«ï¼šå¸‚ç›ˆç‡ã€å¸‚å‡€ç‡ã€æ‰€å¤„è¡Œä¸šã€æ€»å¸‚å€¼ã€æµé€šå¸‚å€¼ã€ROEã€å‡€åˆ©ç‡ç­‰
        
        Args:
            stock_code: è‚¡ç¥¨ä»£ç 
            
        Returns:
            åŒ…å«åŸºæœ¬ä¿¡æ¯çš„å­—å…¸ï¼Œè·å–å¤±è´¥è¿”å› None
        """
        import efinance as ef
        
        try:
            # é˜²å°ç¦ç­–ç•¥
            self._set_random_user_agent()
            self._enforce_rate_limit()
            
            logger.info(f"[APIè°ƒç”¨] ef.stock.get_base_info(stock_codes={stock_code}) è·å–åŸºæœ¬ä¿¡æ¯...")
            import time as _time
            api_start = _time.time()
            
            info = ef.stock.get_base_info(stock_code)
            
            api_elapsed = _time.time() - api_start
            logger.info(f"[APIè¿”å›] ef.stock.get_base_info æˆåŠŸ, è€—æ—¶ {api_elapsed:.2f}s")
            
            if info is None:
                logger.warning(f"[APIè¿”å›] æœªè·å–åˆ° {stock_code} çš„åŸºæœ¬ä¿¡æ¯")
                return None
            
            # è½¬æ¢ä¸ºå­—å…¸
            if isinstance(info, pd.Series):
                return info.to_dict()
            elif isinstance(info, pd.DataFrame):
                if not info.empty:
                    return info.iloc[0].to_dict()
            
            return None
            
        except Exception as e:
            logger.error(f"[APIé”™è¯¯] è·å– {stock_code} åŸºæœ¬ä¿¡æ¯å¤±è´¥: {e}")
            return None
    
    def get_belong_board(self, stock_code: str) -> Optional[pd.DataFrame]:
        """
        è·å–è‚¡ç¥¨æ‰€å±æ¿å—
        
        æ•°æ®æ¥æºï¼šef.stock.get_belong_board()
        
        Args:
            stock_code: è‚¡ç¥¨ä»£ç 
            
        Returns:
            æ‰€å±æ¿å— DataFrameï¼Œè·å–å¤±è´¥è¿”å› None
        """
        import efinance as ef
        
        try:
            # é˜²å°ç¦ç­–ç•¥
            self._set_random_user_agent()
            self._enforce_rate_limit()
            
            logger.info(f"[APIè°ƒç”¨] ef.stock.get_belong_board(stock_code={stock_code}) è·å–æ‰€å±æ¿å—...")
            import time as _time
            api_start = _time.time()
            
            df = ef.stock.get_belong_board(stock_code)
            
            api_elapsed = _time.time() - api_start
            
            if df is not None and not df.empty:
                logger.info(f"[APIè¿”å›] ef.stock.get_belong_board æˆåŠŸ: è¿”å› {len(df)} ä¸ªæ¿å—, è€—æ—¶ {api_elapsed:.2f}s")
                return df
            else:
                logger.warning(f"[APIè¿”å›] æœªè·å–åˆ° {stock_code} çš„æ¿å—ä¿¡æ¯")
                return None
                
        except Exception as e:
            logger.error(f"[APIé”™è¯¯] è·å– {stock_code} æ‰€å±æ¿å—å¤±è´¥: {e}")
            return None
    
    def get_enhanced_data(self, stock_code: str, days: int = 60) -> Dict[str, Any]:
        """
        è·å–å¢å¼ºæ•°æ®ï¼ˆå†å²Kçº¿ + å®æ—¶è¡Œæƒ… + åŸºæœ¬ä¿¡æ¯ï¼‰
        
        Args:
            stock_code: è‚¡ç¥¨ä»£ç 
            days: å†å²æ•°æ®å¤©æ•°
            
        Returns:
            åŒ…å«æ‰€æœ‰æ•°æ®çš„å­—å…¸
        """
        result = {
            'code': stock_code,
            'daily_data': None,
            'realtime_quote': None,
            'base_info': None,
            'belong_board': None,
        }
        
        # è·å–æ—¥çº¿æ•°æ®
        try:
            df = self.get_daily_data(stock_code, days=days)
            result['daily_data'] = df
        except Exception as e:
            logger.error(f"è·å– {stock_code} æ—¥çº¿æ•°æ®å¤±è´¥: {e}")
        
        # è·å–å®æ—¶è¡Œæƒ…
        result['realtime_quote'] = self.get_realtime_quote(stock_code)
        
        # è·å–åŸºæœ¬ä¿¡æ¯
        result['base_info'] = self.get_base_info(stock_code)
        
        # è·å–æ‰€å±æ¿å—
        result['belong_board'] = self.get_belong_board(stock_code)
        
        return result


if __name__ == "__main__":
    # æµ‹è¯•ä»£ç 
    logging.basicConfig(level=logging.DEBUG)
    
    fetcher = EfinanceFetcher()
    
    # æµ‹è¯•æ™®é€šè‚¡ç¥¨
    print("=" * 50)
    print("æµ‹è¯•æ™®é€šè‚¡ç¥¨æ•°æ®è·å– (efinance)")
    print("=" * 50)
    try:
        df = fetcher.get_daily_data('600519')  # èŒ…å°
        print(f"[è‚¡ç¥¨] è·å–æˆåŠŸï¼Œå…± {len(df)} æ¡æ•°æ®")
        print(df.tail())
    except Exception as e:
        print(f"[è‚¡ç¥¨] è·å–å¤±è´¥: {e}")
    
    # æµ‹è¯• ETF åŸºé‡‘
    print("\n" + "=" * 50)
    print("æµ‹è¯• ETF åŸºé‡‘æ•°æ®è·å– (efinance)")
    print("=" * 50)
    try:
        df = fetcher.get_daily_data('512400')  # æœ‰è‰²é¾™å¤´ETF
        print(f"[ETF] è·å–æˆåŠŸï¼Œå…± {len(df)} æ¡æ•°æ®")
        print(df.tail())
    except Exception as e:
        print(f"[ETF] è·å–å¤±è´¥: {e}")
    
    # æµ‹è¯•å®æ—¶è¡Œæƒ…
    print("\n" + "=" * 50)
    print("æµ‹è¯•å®æ—¶è¡Œæƒ…è·å– (efinance)")
    print("=" * 50)
    try:
        quote = fetcher.get_realtime_quote('600519')
        if quote:
            print(f"[å®æ—¶è¡Œæƒ…] {quote.name}: ä»·æ ¼={quote.price}, æ¶¨è·Œå¹…={quote.change_pct}%")
        else:
            print("[å®æ—¶è¡Œæƒ…] æœªè·å–åˆ°æ•°æ®")
    except Exception as e:
        print(f"[å®æ—¶è¡Œæƒ…] è·å–å¤±è´¥: {e}")
    
    # æµ‹è¯•åŸºæœ¬ä¿¡æ¯
    print("\n" + "=" * 50)
    print("æµ‹è¯•åŸºæœ¬ä¿¡æ¯è·å– (efinance)")
    print("=" * 50)
    try:
        info = fetcher.get_base_info('600519')
        if info:
            print(f"[åŸºæœ¬ä¿¡æ¯] å¸‚ç›ˆç‡={info.get('å¸‚ç›ˆç‡(åŠ¨)', 'N/A')}, å¸‚å‡€ç‡={info.get('å¸‚å‡€ç‡', 'N/A')}")
        else:
            print("[åŸºæœ¬ä¿¡æ¯] æœªè·å–åˆ°æ•°æ®")
    except Exception as e:
        print(f"[åŸºæœ¬ä¿¡æ¯] è·å–å¤±è´¥: {e}")

--------------------

#File: data_provider/__init__.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
æ•°æ®æºç­–ç•¥å±‚ - åŒ…åˆå§‹åŒ–
===================================

æœ¬åŒ…å®ç°ç­–ç•¥æ¨¡å¼ç®¡ç†å¤šä¸ªæ•°æ®æºï¼Œå®ç°ï¼š
1. ç»Ÿä¸€çš„æ•°æ®è·å–æ¥å£
2. è‡ªåŠ¨æ•…éšœåˆ‡æ¢
3. é˜²å°ç¦æµæ§ç­–ç•¥

æ•°æ®æºä¼˜å…ˆçº§ï¼ˆåŠ¨æ€è°ƒæ•´ï¼‰ï¼š
ã€é…ç½®äº† TUSHARE_TOKEN æ—¶ã€‘
1. TushareFetcher (Priority 0) - ğŸ”¥ æœ€é«˜ä¼˜å…ˆçº§ï¼ˆåŠ¨æ€æå‡ï¼‰
2. EfinanceFetcher (Priority 0) - åŒä¼˜å…ˆçº§
3. AkshareFetcher (Priority 1) - æ¥è‡ª akshare åº“
4. PytdxFetcher (Priority 2) - æ¥è‡ª pytdx åº“ï¼ˆé€šè¾¾ä¿¡ï¼‰
5. BaostockFetcher (Priority 3) - æ¥è‡ª baostock åº“
6. YfinanceFetcher (Priority 4) - æ¥è‡ª yfinance åº“

ã€æœªé…ç½® TUSHARE_TOKEN æ—¶ã€‘
1. EfinanceFetcher (Priority 0) - æœ€é«˜ä¼˜å…ˆçº§ï¼Œæ¥è‡ª efinance åº“
2. AkshareFetcher (Priority 1) - æ¥è‡ª akshare åº“
3. PytdxFetcher (Priority 2) - æ¥è‡ª pytdx åº“ï¼ˆé€šè¾¾ä¿¡ï¼‰
4. TushareFetcher (Priority 2) - æ¥è‡ª tushare åº“ï¼ˆä¸å¯ç”¨ï¼‰
5. BaostockFetcher (Priority 3) - æ¥è‡ª baostock åº“
6. YfinanceFetcher (Priority 4) - æ¥è‡ª yfinance åº“

æç¤ºï¼šä¼˜å…ˆçº§æ•°å­—è¶Šå°è¶Šä¼˜å…ˆï¼ŒåŒä¼˜å…ˆçº§æŒ‰åˆå§‹åŒ–é¡ºåºæ’åˆ—
"""

from .base import BaseFetcher, DataFetcherManager
from .efinance_fetcher import EfinanceFetcher
from .akshare_fetcher import AkshareFetcher
from .tushare_fetcher import TushareFetcher
from .pytdx_fetcher import PytdxFetcher
from .baostock_fetcher import BaostockFetcher
from .yfinance_fetcher import YfinanceFetcher

__all__ = [
    'BaseFetcher',
    'DataFetcherManager',
    'EfinanceFetcher',
    'AkshareFetcher',
    'TushareFetcher',
    'PytdxFetcher',
    'BaostockFetcher',
    'YfinanceFetcher',
]

--------------------

#File: data_provider/fundamental_fetcher.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
åŸºæœ¬é¢æ•°æ®è·å–å™¨ (F10)
===================================
èŒè´£ï¼šè·å–ä¸ªè‚¡çš„è´¢åŠ¡æ‘˜è¦ã€ä¼°å€¼æŒ‡æ ‡ã€ä¸šç»©é¢„æµ‹
é£æ§ï¼šä¸¥æ ¼é™åˆ¶è¯·æ±‚é¢‘ç‡ï¼Œé˜²æ­¢ IP è¢«å°
"""
import logging
import time
import random
from typing import Dict, Optional, Any
from functools import lru_cache

logger = logging.getLogger(__name__)

# ç®€å•çš„å†…å­˜ç¼“å­˜ï¼Œé¿å…çŸ­æ—¶é—´å†…é‡å¤è¯·æ±‚åŒä¸€åªè‚¡ç¥¨
# è€ƒè™‘åˆ° F10 æ•°æ®ä¸€å¤©å˜ä¸äº†ä¸€æ¬¡ï¼Œè¿™ä¸ªç¼“å­˜å¯ä»¥æ˜¯å…¨å±€çš„
_fundamental_cache = {}

class FundamentalFetcher:
    def __init__(self):
        # å¢åŠ éšæœºä¼‘çœ ï¼Œé˜²å°æ§
        self.sleep_min = 2.0  # æœ€å°ä¼‘çœ  2ç§’
        self.sleep_max = 4.0  # æœ€å¤§ä¼‘çœ  4ç§’

    def _random_sleep(self):
        """éšæœºä¼‘çœ ï¼Œæ¨¡æ‹Ÿäººç±»è¡Œä¸º"""
        t = random.uniform(self.sleep_min, self.sleep_max)
        time.sleep(t)

    def get_f10_data(self, code: str) -> Dict[str, Any]:
        """
        è·å–æ•´åˆåçš„ F10 æ•°æ®
        """
        # 1. æ£€æŸ¥ç¼“å­˜
        if code in _fundamental_cache:
            return _fundamental_cache[code]

        data = {
            "valuation": {},  # ä¼°å€¼ (ç›®å‰ä¸»è¦å¤ç”¨è¡Œæƒ…æ¥å£)
            "financial": {},  # è´¢åŠ¡
            "forecast": {}    # é¢„æµ‹
        }

        try:
            import akshare as ak
            
            # --- A. è·å–è´¢åŠ¡æ‘˜è¦ (åŒèŠ±é¡ºæ¥å£æ¯”è¾ƒå…¨) ---
            # å¿…é¡»ä¼‘çœ ï¼Œå¦åˆ™è¿ç»­è¯·æ±‚ä¼šè¢«ban
            self._random_sleep()
            try:
                # ç¤ºä¾‹æ¥å£ï¼šak.stock_financial_abstract_ths
                # æ³¨æ„ï¼šä¸åŒç‰ˆæœ¬ akshare æ¥å£åç§°å¯èƒ½å˜åŠ¨ï¼Œå»ºè®®åŠ  try-catch
                # symbol éœ€è¦æ˜¯ 6 ä½ä»£ç 
                df_fin = ak.stock_financial_abstract_ths(symbol=code)
                if df_fin is not None and not df_fin.empty:
                    # å–æœ€è¿‘ä¸€æœŸå¹´æŠ¥æˆ–å­£æŠ¥ï¼ˆé€šå¸¸æ˜¯æœ€åä¸€è¡Œæˆ–ç¬¬ä¸€è¡Œï¼Œéœ€ç¡®è®¤æ•°æ®é¡ºåºï¼‰
                    # akshare è¿™ä¸ªæ¥å£é€šå¸¸æŒ‰æŠ¥å‘ŠæœŸé™åºæˆ–å‡åº
                    # æˆ‘ä»¬å‡è®¾æœ€åä¸€è¡Œæ˜¯æœ€æ–°çš„ï¼ˆå…·ä½“è§†æ¥å£è¿”å›è€Œå®šï¼Œç¨³å¦¥èµ·è§æŒ‰æ—¥æœŸæ’åºï¼‰
                    # df_fin = df_fin.sort_values(by="æŠ¥å‘ŠæœŸ") 
                    latest = df_fin.iloc[-1]
                    
                    data["financial"] = {
                        "date": str(latest.get("æŠ¥å‘ŠæœŸ", "")),
                        "roe": str(latest.get("å‡€èµ„äº§æ”¶ç›Šç‡", "N/A")),
                        "net_profit_growth": str(latest.get("å‡€åˆ©æ¶¦åŒæ¯”å¢é•¿ç‡", "N/A")),
                        "revenue_growth": str(latest.get("è¥ä¸šæ€»æ”¶å…¥åŒæ¯”å¢é•¿ç‡", "N/A")),
                        "gross_margin": str(latest.get("é”€å”®æ¯›åˆ©ç‡", "N/A")),
                        "debt_ratio": str(latest.get("èµ„äº§è´Ÿå€ºç‡", "N/A"))
                    }
            except Exception as e:
                logger.warning(f"[{code}] è´¢åŠ¡æ•°æ®è·å–å¾®ç‘•: {e}")

            # --- B. è·å–ä¸šç»©é¢„æµ‹ (åŒèŠ±é¡º) ---
            self._random_sleep()
            try:
                # æ¥å£ï¼šak.stock_profit_forecast_ths
                df_fore = ak.stock_profit_forecast_ths(symbol=code)
                if df_fore is not None and not df_fore.empty:
                    # å–æœ€æ–°çš„å‡ æ¡æ±‡æ€»
                    summary = df_fore.head(1).to_dict('records')[0]
                    data["forecast"] = {
                        "rating": summary.get("è¯„çº§", "æ— "),
                        "target_price": summary.get("ç›®æ ‡ä»·æ ¼", "æ— "),
                        "avg_profit_change": summary.get("å¹³å‡å‡€åˆ©æ¶¦å˜åŠ¨å¹…", "N/A")
                    }
            except Exception as e:
                pass # é¢„æµ‹æ•°æ®æ²¡æœ‰ä¹Ÿæ— æ‰€è°“

            # å­˜å…¥ç¼“å­˜
            _fundamental_cache[code] = data
            logger.info(f"âœ… [{code}] F10 åŸºæœ¬é¢æ•°æ®è·å–æˆåŠŸ")
            
        except Exception as e:
            logger.error(f"âŒ [{code}] F10 æ•°æ®è·å–å¤±è´¥: {e}")
            # å¤±è´¥äº†ä¹Ÿè¿”å›ç©ºå­—å…¸ï¼Œä¸é˜»æ–­æµç¨‹
        
        return data

# å…¨å±€å•ä¾‹
_fetcher = FundamentalFetcher()

def get_fundamental_data(code: str) -> Dict[str, Any]:
    return _fetcher.get_f10_data(code)
--------------------

#File: data_provider/tushare_fetcher.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
TushareFetcher - å¤‡ç”¨æ•°æ®æº 1 (Priority 2)
===================================

æ•°æ®æ¥æºï¼šTushare Pro APIï¼ˆæŒ–åœ°å…”ï¼‰
ç‰¹ç‚¹ï¼šéœ€è¦ Tokenã€æœ‰è¯·æ±‚é…é¢é™åˆ¶
ä¼˜ç‚¹ï¼šæ•°æ®è´¨é‡é«˜ã€æ¥å£ç¨³å®š

æµæ§ç­–ç•¥ï¼š
1. å®ç°"æ¯åˆ†é’Ÿè°ƒç”¨è®¡æ•°å™¨"
2. è¶…è¿‡å…è´¹é…é¢ï¼ˆ80æ¬¡/åˆ†ï¼‰æ—¶ï¼Œå¼ºåˆ¶ä¼‘çœ åˆ°ä¸‹ä¸€åˆ†é’Ÿ
3. ä½¿ç”¨ tenacity å®ç°æŒ‡æ•°é€€é¿é‡è¯•
"""

import logging
import re
import time
from datetime import datetime
from typing import Optional, Tuple, List, Dict, Any

import pandas as pd
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type,
    before_sleep_log,
)

from .base import BaseFetcher, DataFetchError, RateLimitError, STANDARD_COLUMNS
from src.config import get_config
import os

logger = logging.getLogger(__name__)


def _is_us_code(stock_code: str) -> bool:
    """
    åˆ¤æ–­ä»£ç æ˜¯å¦ä¸ºç¾è‚¡
    
    ç¾è‚¡ä»£ç è§„åˆ™ï¼š
    - 1-5ä¸ªå¤§å†™å­—æ¯ï¼Œå¦‚ 'AAPL', 'TSLA'
    - å¯èƒ½åŒ…å« '.'ï¼Œå¦‚ 'BRK.B'
    """
    code = stock_code.strip().upper()
    return bool(re.match(r'^[A-Z]{1,5}(\.[A-Z])?$', code))


class TushareFetcher(BaseFetcher):
    """
    Tushare Pro æ•°æ®æºå®ç°
    
    ä¼˜å…ˆçº§ï¼š2
    æ•°æ®æ¥æºï¼šTushare Pro API
    
    å…³é”®ç­–ç•¥ï¼š
    - æ¯åˆ†é’Ÿè°ƒç”¨è®¡æ•°å™¨ï¼Œé˜²æ­¢è¶…å‡ºé…é¢
    - è¶…è¿‡ 80 æ¬¡/åˆ†é’Ÿæ—¶å¼ºåˆ¶ç­‰å¾…
    - å¤±è´¥åæŒ‡æ•°é€€é¿é‡è¯•
    
    é…é¢è¯´æ˜ï¼ˆTushare å…è´¹ç”¨æˆ·ï¼‰ï¼š
    - æ¯åˆ†é’Ÿæœ€å¤š 80 æ¬¡è¯·æ±‚
    - æ¯å¤©æœ€å¤š 500 æ¬¡è¯·æ±‚
    """
    
    name = "TushareFetcher"
    priority = int(os.getenv("TUSHARE_PRIORITY", "2"))  # é»˜è®¤ä¼˜å…ˆçº§ï¼Œä¼šåœ¨ __init__ ä¸­æ ¹æ®é…ç½®åŠ¨æ€è°ƒæ•´

    def __init__(self, rate_limit_per_minute: int = 80):
        """
        åˆå§‹åŒ– TushareFetcher

        Args:
            rate_limit_per_minute: æ¯åˆ†é’Ÿæœ€å¤§è¯·æ±‚æ•°ï¼ˆé»˜è®¤80ï¼ŒTushareå…è´¹é…é¢ï¼‰
        """
        self.rate_limit_per_minute = rate_limit_per_minute
        self._call_count = 0  # å½“å‰åˆ†é’Ÿå†…çš„è°ƒç”¨æ¬¡æ•°
        self._minute_start: Optional[float] = None  # å½“å‰è®¡æ•°å‘¨æœŸå¼€å§‹æ—¶é—´
        self._api: Optional[object] = None  # Tushare API å®ä¾‹

        # å°è¯•åˆå§‹åŒ– API
        self._init_api()

        # æ ¹æ® API åˆå§‹åŒ–ç»“æœåŠ¨æ€è°ƒæ•´ä¼˜å…ˆçº§
        self.priority = self._determine_priority()
    
    def _init_api(self) -> None:
        """
        åˆå§‹åŒ– Tushare API
        
        å¦‚æœ Token æœªé…ç½®ï¼Œæ­¤æ•°æ®æºå°†ä¸å¯ç”¨
        """
        config = get_config()
        
        if not config.tushare_token:
            logger.warning("Tushare Token æœªé…ç½®ï¼Œæ­¤æ•°æ®æºä¸å¯ç”¨")
            return
        
        try:
            import tushare as ts
            
            # è®¾ç½® Token
            ts.set_token(config.tushare_token)
            
            # è·å– API å®ä¾‹
            self._api = ts.pro_api()
            
            logger.info("Tushare API åˆå§‹åŒ–æˆåŠŸ")
            
        except Exception as e:
            logger.error(f"Tushare API åˆå§‹åŒ–å¤±è´¥: {e}")
            self._api = None

    def _determine_priority(self) -> int:
        """
        æ ¹æ® Token é…ç½®å’Œ API åˆå§‹åŒ–çŠ¶æ€ç¡®å®šä¼˜å…ˆçº§

        ç­–ç•¥ï¼š
        - Token é…ç½®ä¸” API åˆå§‹åŒ–æˆåŠŸï¼šä¼˜å…ˆçº§ -1ï¼ˆç»å¯¹æœ€é«˜ï¼Œä¼˜äº efinanceï¼‰
        - å…¶ä»–æƒ…å†µï¼šä¼˜å…ˆçº§ 2ï¼ˆé»˜è®¤ï¼‰

        Returns:
            ä¼˜å…ˆçº§æ•°å­—ï¼ˆ0=æœ€é«˜ï¼Œæ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šä½ï¼‰
        """
        config = get_config()

        if config.tushare_token and self._api is not None:
            # Token é…ç½®ä¸” API åˆå§‹åŒ–æˆåŠŸï¼Œæå‡ä¸ºæœ€é«˜ä¼˜å…ˆçº§
            logger.info("âœ… æ£€æµ‹åˆ° TUSHARE_TOKEN ä¸” API åˆå§‹åŒ–æˆåŠŸï¼ŒTushare æ•°æ®æºä¼˜å…ˆçº§æå‡ä¸ºæœ€é«˜ (Priority -1)")
            return -1

        # Token æœªé…ç½®æˆ– API åˆå§‹åŒ–å¤±è´¥ï¼Œä¿æŒé»˜è®¤ä¼˜å…ˆçº§
        return 2

    def is_available(self) -> bool:
        """
        æ£€æŸ¥æ•°æ®æºæ˜¯å¦å¯ç”¨

        Returns:
            True è¡¨ç¤ºå¯ç”¨ï¼ŒFalse è¡¨ç¤ºä¸å¯ç”¨
        """
        return self._api is not None

    def _check_rate_limit(self) -> None:
        """
        æ£€æŸ¥å¹¶æ‰§è¡Œé€Ÿç‡é™åˆ¶
        
        æµæ§ç­–ç•¥ï¼š
        1. æ£€æŸ¥æ˜¯å¦è¿›å…¥æ–°çš„ä¸€åˆ†é’Ÿ
        2. å¦‚æœæ˜¯ï¼Œé‡ç½®è®¡æ•°å™¨
        3. å¦‚æœå½“å‰åˆ†é’Ÿè°ƒç”¨æ¬¡æ•°è¶…è¿‡é™åˆ¶ï¼Œå¼ºåˆ¶ä¼‘çœ 
        """
        current_time = time.time()
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦é‡ç½®è®¡æ•°å™¨ï¼ˆæ–°çš„ä¸€åˆ†é’Ÿï¼‰
        if self._minute_start is None:
            self._minute_start = current_time
            self._call_count = 0
        elif current_time - self._minute_start >= 60:
            # å·²ç»è¿‡äº†ä¸€åˆ†é’Ÿï¼Œé‡ç½®è®¡æ•°å™¨
            self._minute_start = current_time
            self._call_count = 0
            logger.debug("é€Ÿç‡é™åˆ¶è®¡æ•°å™¨å·²é‡ç½®")
        
        # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é…é¢
        if self._call_count >= self.rate_limit_per_minute:
            # è®¡ç®—éœ€è¦ç­‰å¾…çš„æ—¶é—´ï¼ˆåˆ°ä¸‹ä¸€åˆ†é’Ÿï¼‰
            elapsed = current_time - self._minute_start
            sleep_time = max(0, 60 - elapsed) + 1  # +1 ç§’ç¼“å†²
            
            logger.warning(
                f"Tushare è¾¾åˆ°é€Ÿç‡é™åˆ¶ ({self._call_count}/{self.rate_limit_per_minute} æ¬¡/åˆ†é’Ÿ)ï¼Œ"
                f"ç­‰å¾… {sleep_time:.1f} ç§’..."
            )
            
            time.sleep(sleep_time)
            
            # é‡ç½®è®¡æ•°å™¨
            self._minute_start = time.time()
            self._call_count = 0
        
        # å¢åŠ è°ƒç”¨è®¡æ•°
        self._call_count += 1
        logger.debug(f"Tushare å½“å‰åˆ†é’Ÿè°ƒç”¨æ¬¡æ•°: {self._call_count}/{self.rate_limit_per_minute}")
    
    def _convert_stock_code(self, stock_code: str) -> str:
        """
        è½¬æ¢è‚¡ç¥¨ä»£ç ä¸º Tushare æ ¼å¼
        
        Tushare è¦æ±‚çš„æ ¼å¼ï¼š
        - æ²ªå¸‚ï¼š600519.SH
        - æ·±å¸‚ï¼š000001.SZ
        
        Args:
            stock_code: åŸå§‹ä»£ç ï¼Œå¦‚ '600519', '000001'
            
        Returns:
            Tushare æ ¼å¼ä»£ç ï¼Œå¦‚ '600519.SH', '000001.SZ'
        """
        code = stock_code.strip()
        
        # å·²ç»åŒ…å«åç¼€çš„æƒ…å†µ
        if '.' in code:
            return code.upper()
        
        # æ ¹æ®ä»£ç å‰ç¼€åˆ¤æ–­å¸‚åœº
        # æ²ªå¸‚ï¼š600xxx, 601xxx, 603xxx, 688xxx (ç§‘åˆ›æ¿)
        # æ·±å¸‚ï¼š000xxx, 002xxx, 300xxx (åˆ›ä¸šæ¿)
        if code.startswith(('600', '601', '603', '688')):
            return f"{code}.SH"
        elif code.startswith(('000', '002', '300')):
            return f"{code}.SZ"
        else:
            # é»˜è®¤å°è¯•æ·±å¸‚
            logger.warning(f"æ— æ³•ç¡®å®šè‚¡ç¥¨ {code} çš„å¸‚åœºï¼Œé»˜è®¤ä½¿ç”¨æ·±å¸‚")
            return f"{code}.SZ"
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=30),
        retry=retry_if_exception_type((ConnectionError, TimeoutError)),
        before_sleep=before_sleep_log(logger, logging.WARNING),
    )
    def _fetch_raw_data(self, stock_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        """
        ä» Tushare è·å–åŸå§‹æ•°æ®
        
        ä½¿ç”¨ daily() æ¥å£è·å–æ—¥çº¿æ•°æ®
        
        æµç¨‹ï¼š
        1. æ£€æŸ¥ API æ˜¯å¦å¯ç”¨
        2. æ£€æŸ¥æ˜¯å¦ä¸ºç¾è‚¡ï¼ˆä¸æ”¯æŒï¼‰
        3. æ‰§è¡Œé€Ÿç‡é™åˆ¶æ£€æŸ¥
        4. è½¬æ¢è‚¡ç¥¨ä»£ç æ ¼å¼
        5. è°ƒç”¨ API è·å–æ•°æ®
        """
        if self._api is None:
            raise DataFetchError("Tushare API æœªåˆå§‹åŒ–ï¼Œè¯·æ£€æŸ¥ Token é…ç½®")
        
        # ç¾è‚¡ä¸æ”¯æŒï¼ŒæŠ›å‡ºå¼‚å¸¸è®© DataFetcherManager åˆ‡æ¢åˆ°å…¶ä»–æ•°æ®æº
        if _is_us_code(stock_code):
            raise DataFetchError(f"TushareFetcher ä¸æ”¯æŒç¾è‚¡ {stock_code}ï¼Œè¯·ä½¿ç”¨ AkshareFetcher æˆ– YfinanceFetcher")
        
        # é€Ÿç‡é™åˆ¶æ£€æŸ¥
        self._check_rate_limit()
        
        # è½¬æ¢ä»£ç æ ¼å¼
        ts_code = self._convert_stock_code(stock_code)
        
        # è½¬æ¢æ—¥æœŸæ ¼å¼ï¼ˆTushare è¦æ±‚ YYYYMMDDï¼‰
        ts_start = start_date.replace('-', '')
        ts_end = end_date.replace('-', '')
        
        logger.debug(f"è°ƒç”¨ Tushare daily({ts_code}, {ts_start}, {ts_end})")
        
        try:
            # è°ƒç”¨ daily æ¥å£è·å–æ—¥çº¿æ•°æ®
            df = self._api.daily(
                ts_code=ts_code,
                start_date=ts_start,
                end_date=ts_end,
            )
            
            return df
            
        except Exception as e:
            error_msg = str(e).lower()
            
            # æ£€æµ‹é…é¢è¶…é™
            if any(keyword in error_msg for keyword in ['quota', 'é…é¢', 'limit', 'æƒé™']):
                logger.warning(f"Tushare é…é¢å¯èƒ½è¶…é™: {e}")
                raise RateLimitError(f"Tushare é…é¢è¶…é™: {e}") from e
            
            raise DataFetchError(f"Tushare è·å–æ•°æ®å¤±è´¥: {e}") from e
    
    def _normalize_data(self, df: pd.DataFrame, stock_code: str) -> pd.DataFrame:
        """
        æ ‡å‡†åŒ– Tushare æ•°æ®
        
        Tushare daily è¿”å›çš„åˆ—åï¼š
        ts_code, trade_date, open, high, low, close, pre_close, change, pct_chg, vol, amount
        
        éœ€è¦æ˜ å°„åˆ°æ ‡å‡†åˆ—åï¼š
        date, open, high, low, close, volume, amount, pct_chg
        """
        df = df.copy()
        
        # åˆ—åæ˜ å°„
        column_mapping = {
            'trade_date': 'date',
            'vol': 'volume',
            # open, high, low, close, amount, pct_chg åˆ—åç›¸åŒ
        }
        
        df = df.rename(columns=column_mapping)
        
        # è½¬æ¢æ—¥æœŸæ ¼å¼ï¼ˆYYYYMMDD -> YYYY-MM-DDï¼‰
        if 'date' in df.columns:
            df['date'] = pd.to_datetime(df['date'], format='%Y%m%d')
        
        # æˆäº¤é‡å•ä½è½¬æ¢ï¼ˆTushare çš„ vol å•ä½æ˜¯æ‰‹ï¼Œéœ€è¦è½¬æ¢ä¸ºè‚¡ï¼‰
        if 'volume' in df.columns:
            df['volume'] = df['volume'] * 100
        
        # æˆäº¤é¢å•ä½è½¬æ¢ï¼ˆTushare çš„ amount å•ä½æ˜¯åƒå…ƒï¼Œè½¬æ¢ä¸ºå…ƒï¼‰
        if 'amount' in df.columns:
            df['amount'] = df['amount'] * 1000
        
        # æ·»åŠ è‚¡ç¥¨ä»£ç åˆ—
        df['code'] = stock_code
        
        # åªä¿ç•™éœ€è¦çš„åˆ—
        keep_cols = ['code'] + STANDARD_COLUMNS
        existing_cols = [col for col in keep_cols if col in df.columns]
        df = df[existing_cols]
        
        return df

    def get_stock_name(self, stock_code: str) -> Optional[str]:
        """
        è·å–è‚¡ç¥¨åç§°
        
        ä½¿ç”¨ Tushare çš„ stock_basic æ¥å£è·å–è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯
        
        Args:
            stock_code: è‚¡ç¥¨ä»£ç 
            
        Returns:
            è‚¡ç¥¨åç§°ï¼Œå¤±è´¥è¿”å› None
        """
        if self._api is None:
            logger.warning("Tushare API æœªåˆå§‹åŒ–ï¼Œæ— æ³•è·å–è‚¡ç¥¨åç§°")
            return None
        
        # æ£€æŸ¥ç¼“å­˜
        if hasattr(self, '_stock_name_cache') and stock_code in self._stock_name_cache:
            return self._stock_name_cache[stock_code]
        
        # åˆå§‹åŒ–ç¼“å­˜
        if not hasattr(self, '_stock_name_cache'):
            self._stock_name_cache = {}
        
        try:
            # é€Ÿç‡é™åˆ¶æ£€æŸ¥
            self._check_rate_limit()
            
            # è½¬æ¢ä»£ç æ ¼å¼
            ts_code = self._convert_stock_code(stock_code)
            
            # è°ƒç”¨ stock_basic æ¥å£
            df = self._api.stock_basic(
                ts_code=ts_code,
                fields='ts_code,name'
            )
            
            if df is not None and not df.empty:
                name = df.iloc[0]['name']
                self._stock_name_cache[stock_code] = name
                logger.debug(f"Tushare è·å–è‚¡ç¥¨åç§°æˆåŠŸ: {stock_code} -> {name}")
                return name
            
        except Exception as e:
            logger.warning(f"Tushare è·å–è‚¡ç¥¨åç§°å¤±è´¥ {stock_code}: {e}")
        
        return None
    
    def get_stock_list(self) -> Optional[pd.DataFrame]:
        """
        è·å–è‚¡ç¥¨åˆ—è¡¨
        
        ä½¿ç”¨ Tushare çš„ stock_basic æ¥å£è·å–å…¨éƒ¨è‚¡ç¥¨åˆ—è¡¨
        
        Returns:
            åŒ…å« code, name åˆ—çš„ DataFrameï¼Œå¤±è´¥è¿”å› None
        """
        if self._api is None:
            logger.warning("Tushare API æœªåˆå§‹åŒ–ï¼Œæ— æ³•è·å–è‚¡ç¥¨åˆ—è¡¨")
            return None
        
        try:
            # é€Ÿç‡é™åˆ¶æ£€æŸ¥
            self._check_rate_limit()
            
            # è°ƒç”¨ stock_basic æ¥å£è·å–æ‰€æœ‰è‚¡ç¥¨
            df = self._api.stock_basic(
                exchange='',
                list_status='L',
                fields='ts_code,name,industry,area,market'
            )
            
            if df is not None and not df.empty:
                # è½¬æ¢ ts_code ä¸ºæ ‡å‡†ä»£ç æ ¼å¼
                df['code'] = df['ts_code'].apply(lambda x: x.split('.')[0])
                
                # æ›´æ–°ç¼“å­˜
                if not hasattr(self, '_stock_name_cache'):
                    self._stock_name_cache = {}
                for _, row in df.iterrows():
                    self._stock_name_cache[row['code']] = row['name']
                
                logger.info(f"Tushare è·å–è‚¡ç¥¨åˆ—è¡¨æˆåŠŸ: {len(df)} æ¡")
                return df[['code', 'name', 'industry', 'area', 'market']]
            
        except Exception as e:
            logger.warning(f"Tushare è·å–è‚¡ç¥¨åˆ—è¡¨å¤±è´¥: {e}")
        
        return None
    
    def get_realtime_quote(self, stock_code: str) -> Optional[dict]:
        """
        è·å–å®æ—¶è¡Œæƒ…

        ç­–ç•¥ï¼š
        1. ä¼˜å…ˆå°è¯• Pro æ¥å£ï¼ˆéœ€è¦2000ç§¯åˆ†ï¼‰ï¼šæ•°æ®å…¨ï¼Œç¨³å®šæ€§é«˜
        2. å¤±è´¥é™çº§åˆ°æ—§ç‰ˆæ¥å£ï¼šé—¨æ§›ä½ï¼Œæ•°æ®è¾ƒå°‘

        Args:
            stock_code: è‚¡ç¥¨ä»£ç 

        Returns:
            UnifiedRealtimeQuote å¯¹è±¡ï¼Œå¤±è´¥è¿”å› None
        """
        if self._api is None:
            return None

        from .realtime_types import (
            UnifiedRealtimeQuote, RealtimeSource,
            safe_float, safe_int
        )

        # é€Ÿç‡é™åˆ¶æ£€æŸ¥
        self._check_rate_limit()

        # å°è¯• Pro æ¥å£
        try:
            ts_code = self._convert_stock_code(stock_code)
            # å°è¯•è°ƒç”¨ Pro å®æ—¶æ¥å£ (éœ€è¦ç§¯åˆ†)
            df = self._api.quotation(ts_code=ts_code)

            if df is not None and not df.empty:
                row = df.iloc[0]
                logger.debug(f"Tushare Pro å®æ—¶è¡Œæƒ…è·å–æˆåŠŸ: {stock_code}")

                return UnifiedRealtimeQuote(
                    code=stock_code,
                    name=str(row.get('name', '')),
                    source=RealtimeSource.TUSHARE,
                    price=safe_float(row.get('price')),
                    change_pct=safe_float(row.get('pct_chg')),  # Pro æ¥å£é€šå¸¸ç›´æ¥è¿”å›æ¶¨è·Œå¹…
                    change_amount=safe_float(row.get('change')),
                    volume=safe_int(row.get('vol')),
                    amount=safe_float(row.get('amount')),
                    high=safe_float(row.get('high')),
                    low=safe_float(row.get('low')),
                    open_price=safe_float(row.get('open')),
                    pre_close=safe_float(row.get('pre_close')),
                    turnover_rate=safe_float(row.get('turnover_ratio')), # Pro æ¥å£å¯èƒ½æœ‰æ¢æ‰‹ç‡
                    pe_ratio=safe_float(row.get('pe')),
                    pb_ratio=safe_float(row.get('pb')),
                    total_mv=safe_float(row.get('total_mv')),
                )
        except Exception as e:
            # ä»…è®°å½•è°ƒè¯•æ—¥å¿—ï¼Œä¸æŠ¥é”™ï¼Œç»§ç»­å°è¯•é™çº§
            logger.debug(f"Tushare Pro å®æ—¶è¡Œæƒ…ä¸å¯ç”¨ (å¯èƒ½æ˜¯ç§¯åˆ†ä¸è¶³): {e}")

        # é™çº§ï¼šå°è¯•æ—§ç‰ˆæ¥å£
        try:
            import tushare as ts

            # Tushare æ—§ç‰ˆæ¥å£ä½¿ç”¨ 6 ä½ä»£ç 
            code_6 = stock_code.split('.')[0] if '.' in stock_code else stock_code

            # ç‰¹æ®Šå¤„ç†æŒ‡æ•°ä»£ç ï¼šæ—§ç‰ˆæ¥å£éœ€è¦å‰ç¼€ (sh000001, sz399001)
            # ç®€å•çš„æŒ‡æ•°åˆ¤æ–­é€»è¾‘
            if code_6 == '000001':  # ä¸Šè¯æŒ‡æ•°
                symbol = 'sh000001'
            elif code_6 == '399001': # æ·±è¯æˆæŒ‡
                symbol = 'sz399001'
            elif code_6 == '399006': # åˆ›ä¸šæ¿æŒ‡
                symbol = 'sz399006'
            elif code_6 == '000300': # æ²ªæ·±300
                symbol = 'sh000300'
            else:
                symbol = code_6

            # è°ƒç”¨æ—§ç‰ˆå®æ—¶æ¥å£ (ts.get_realtime_quotes)
            df = ts.get_realtime_quotes(symbol)

            if df is None or df.empty:
                return None

            row = df.iloc[0]

            # è®¡ç®—æ¶¨è·Œå¹…
            price = safe_float(row['price'])
            pre_close = safe_float(row['pre_close'])
            change_pct = 0.0
            change_amount = 0.0

            if price and pre_close and pre_close > 0:
                change_amount = price - pre_close
                change_pct = (change_amount / pre_close) * 100

            # æ„å»ºç»Ÿä¸€å¯¹è±¡
            return UnifiedRealtimeQuote(
                code=stock_code,
                name=str(row['name']),
                source=RealtimeSource.TUSHARE,
                price=price,
                change_pct=round(change_pct, 2),
                change_amount=round(change_amount, 2),
                volume=safe_int(row['volume']) // 100,  # è½¬æ¢ä¸ºæ‰‹
                amount=safe_float(row['amount']),
                high=safe_float(row['high']),
                low=safe_float(row['low']),
                open_price=safe_float(row['open']),
                pre_close=pre_close,
            )

        except Exception as e:
            logger.warning(f"Tushare (æ—§ç‰ˆ) è·å–å®æ—¶è¡Œæƒ…å¤±è´¥ {stock_code}: {e}")
            return None

    def get_main_indices(self) -> Optional[List[dict]]:
        """
        è·å–ä¸»è¦æŒ‡æ•°å®æ—¶è¡Œæƒ… (Tushare Pro)
        """
        if self._api is None:
            return None

        from .realtime_types import safe_float

        # æŒ‡æ•°æ˜ å°„ï¼šTushareä»£ç  -> åç§°
        indices_map = {
            '000001.SH': 'ä¸Šè¯æŒ‡æ•°',
            '399001.SZ': 'æ·±è¯æˆæŒ‡',
            '399006.SZ': 'åˆ›ä¸šæ¿æŒ‡',
            '000688.SH': 'ç§‘åˆ›50',
            '000016.SH': 'ä¸Šè¯50',
            '000300.SH': 'æ²ªæ·±300',
        }

        try:
            self._check_rate_limit()

            # Tushare index_daily è·å–å†å²æ•°æ®ï¼Œå®æ—¶æ•°æ®éœ€ç”¨å…¶ä»–æ¥å£æˆ–ä¼°ç®—
            # ç”±äº Tushare å…è´¹ç”¨æˆ·å¯èƒ½æ— æ³•è·å–æŒ‡æ•°å®æ—¶è¡Œæƒ…ï¼Œè¿™é‡Œä½œä¸ºå¤‡é€‰
            # ä½¿ç”¨ index_daily è·å–æœ€è¿‘äº¤æ˜“æ—¥æ•°æ®

            end_date = datetime.now().strftime('%Y%m%d')
            start_date = (datetime.now() - pd.Timedelta(days=5)).strftime('%Y%m%d')

            results = []

            # æ‰¹é‡è·å–æ‰€æœ‰æŒ‡æ•°æ•°æ®
            for ts_code, name in indices_map.items():
                try:
                    df = self._api.index_daily(ts_code=ts_code, start_date=start_date, end_date=end_date)
                    if df is not None and not df.empty:
                        row = df.iloc[0] # æœ€æ–°ä¸€å¤©

                        current = safe_float(row['close'])
                        prev_close = safe_float(row['pre_close'])

                        results.append({
                            'code': ts_code.split('.')[0], # å…¼å®¹ sh000001 æ ¼å¼éœ€è½¬æ¢ï¼Œè¿™é‡Œä¿æŒçº¯æ•°å­—
                            'name': name,
                            'current': current,
                            'change': safe_float(row['change']),
                            'change_pct': safe_float(row['pct_chg']),
                            'open': safe_float(row['open']),
                            'high': safe_float(row['high']),
                            'low': safe_float(row['low']),
                            'prev_close': prev_close,
                            'volume': safe_float(row['vol']),
                            'amount': safe_float(row['amount']) * 1000, # åƒå…ƒè½¬å…ƒ
                            'amplitude': 0.0 # Tushare index_daily ä¸ç›´æ¥è¿”å›æŒ¯å¹…
                        })
                except Exception as e:
                    logger.debug(f"Tushare è·å–æŒ‡æ•° {name} å¤±è´¥: {e}")
                    continue

            if results:
                return results
            else:
                logger.warning("[Tushare] æœªè·å–åˆ°æŒ‡æ•°è¡Œæƒ…æ•°æ®")

        except Exception as e:
            logger.error(f"[Tushare] è·å–æŒ‡æ•°è¡Œæƒ…å¤±è´¥: {e}")

        return None

    def get_market_stats(self) -> Optional[dict]:
        """
        è·å–å¸‚åœºæ¶¨è·Œç»Ÿè®¡ (Tushare Pro)
        """
        if self._api is None:
            return None

        try:
            self._check_rate_limit()

            # è·å–æœ€è¿‘äº¤æ˜“æ—¥ (è·å–è¿‡å»20å¤©ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿå†å²)
            start_date = (datetime.now() - pd.Timedelta(days=20)).strftime('%Y%m%d')
            trade_cal = self._api.trade_cal(exchange='', start_date=start_date, end_date=datetime.now().strftime('%Y%m%d'), is_open='1')

            if trade_cal is None or trade_cal.empty:
                return None

            # ç¡®ä¿æŒ‰æ—¥æœŸå‡åºæ’åˆ— (Tushareæœ‰æ—¶è¿”å›é™åº)
            trade_cal = trade_cal.sort_values('cal_date')

            # å°è¯•è·å–æœ€æ–°ä¸€å¤©çš„æ•°æ®
            last_date = trade_cal.iloc[-1]['cal_date']
            logger.info(f"[Tushare] Calendar suggests last trading date: {last_date}")

            # æ³¨æ„ï¼šæ¯æ—¥æŒ‡æ ‡æ¥å£ daily å¯èƒ½æ•°æ®é‡è¾ƒå¤§
            # å¦‚æœæ˜¯åœ¨ç›˜ä¸­è°ƒç”¨ï¼Œå½“å¤©çš„æ•°æ®å¯èƒ½è¿˜æœªç”Ÿæˆï¼Œå¯¼è‡´è¿”å›ç©ºæˆ–æå°‘æ•°æ®
            df = self._api.daily(trade_date=last_date)

            current_len = len(df) if df is not None else 0
            logger.info(f"[Tushare] Initial fetch for {last_date} returned {current_len} records")

            # å¦‚æœæ•°æ®è¿‡å°‘ï¼ˆ<100æ¡ï¼‰ï¼Œè¯´æ˜å½“å¤©æ•°æ®æœªå°±ç»ªï¼Œå°è¯•ä½¿ç”¨å‰ä¸€äº¤æ˜“æ—¥
            if df is None or len(df) < 100:
                if len(trade_cal) > 1:
                    prev_date = trade_cal.iloc[-2]['cal_date']
                    logger.warning(f"Data for {last_date} is incomplete (count={current_len}), falling back to {prev_date}")
                    last_date = prev_date
                    df = self._api.daily(trade_date=last_date)
                else:
                    logger.warning(f"[Tushare] {last_date} æ•°æ®ä¸è¶³ä¸”æ— å¯ç”¨å†å²äº¤æ˜“æ—¥")

            logger.info(f"Calculating stats using data from date: {last_date}")

            if df is not None and not df.empty:
                logger.info(f"[Tushare] ä½¿ç”¨äº¤æ˜“æ—¥ {last_date} è¿›è¡Œå¸‚åœºç»Ÿè®¡åˆ†æ")
                up_count = len(df[df['pct_chg'] > 0])
                down_count = len(df[df['pct_chg'] < 0])
                flat_count = len(df[df['pct_chg'] == 0])

                # æ¶¨åœè·Œåœä¼°ç®— (9.9%é˜ˆå€¼)
                limit_up = len(df[df['pct_chg'] >= 9.9])
                limit_down = len(df[df['pct_chg'] <= -9.9])

                total_amount = df['amount'].sum() * 1000 / 1e8 # åƒå…ƒ -> å…ƒ -> äº¿å…ƒ

                return {
                    'up_count': up_count,
                    'down_count': down_count,
                    'flat_count': flat_count,
                    'limit_up_count': limit_up,
                    'limit_down_count': limit_down,
                    'total_amount': total_amount
                }
            else:
                logger.warning("[Tushare] è·å–å¸‚åœºç»Ÿè®¡æ•°æ®ä¸ºç©º")

        except Exception as e:
            logger.error(f"[Tushare] è·å–å¸‚åœºç»Ÿè®¡å¤±è´¥: {e}")

        return None

    def get_sector_rankings(self, n: int = 5) -> Optional[Tuple[list, list]]:
        """
        è·å–æ¿å—æ¶¨è·Œæ¦œ (Tushare Pro)
        """
        # Tushare è·å–æ¿å—æ•°æ®è¾ƒå¤æ‚ï¼Œæš‚æ—¶è¿”å› Noneï¼Œè®© AkShare å¤„ç†
        return None


if __name__ == "__main__":
    # æµ‹è¯•ä»£ç 
    logging.basicConfig(level=logging.DEBUG)
    
    fetcher = TushareFetcher()
    
    try:
        # æµ‹è¯•å†å²æ•°æ®
        df = fetcher.get_daily_data('600519')  # èŒ…å°
        print(f"è·å–æˆåŠŸï¼Œå…± {len(df)} æ¡æ•°æ®")
        print(df.tail())
        
        # æµ‹è¯•è‚¡ç¥¨åç§°
        name = fetcher.get_stock_name('600519')
        print(f"è‚¡ç¥¨åç§°: {name}")
        
    except Exception as e:
        print(f"è·å–å¤±è´¥: {e}")

--------------------

#File: data_provider/market_monitor.py
--------------------
# src/data_provider/market_monitor.py
# -*- coding: utf-8 -*-

import akshare as ak
import logging
import time
from typing import Dict, Any

logger = logging.getLogger(__name__)

class MarketMonitor:
    """
    ä¸“é—¨ç”¨äºä¸ªè‚¡åˆ†ææ—¶çš„ã€å¤§ç›˜ç¯å¢ƒå¿«ç…§ã€‘è·å–
    ç‰¹æ€§ï¼šå¸¦å†…å­˜ç¼“å­˜ï¼Œé˜²æ­¢å¤šçº¿ç¨‹å¹¶å‘åˆ†ææ—¶é¢‘ç¹è¯·æ±‚å¯¼è‡´è¢«å°IP
    """
    
    def __init__(self):
        self._cache_data = None
        self._last_fetch_time = 0
        self._cache_duration = 60  # ç¼“å­˜æœ‰æ•ˆæœŸ 60 ç§’

    def get_market_snapshot(self) -> Dict[str, Any]:
        """
        è·å–å¤§ç›˜æ ¸å¿ƒæ•°æ® (æŒ‡æ•°æ¶¨è·Œ + æ€»æˆäº¤é¢)
        """
        # 1. æ£€æŸ¥ç¼“å­˜ (é˜²æ­¢å¤šçº¿ç¨‹ç¬é—´æ‰“çˆ†æ¥å£)
        if self._cache_data and (time.time() - self._last_fetch_time < self._cache_duration):
            return self._cache_data

        try:
            # logger.info("ğŸ“¡ [Market] æ­£åœ¨åˆ·æ–°å¤§ç›˜æŒ‡æ•°æ•°æ®...")
            
            # === ä¿®å¤ç‚¹ï¼šæ”¹ç”¨æ–°æµªæºï¼Œå®ƒæœ€ç¨³å®šä¸”ä¸éœ€è¦å¤æ‚å‚æ•° ===
            # è¿”å›åˆ—åŒ…å«ï¼šä»£ç , åç§°, æœ€æ–°ä»·, æ¶¨è·Œé¢, æ¶¨è·Œå¹…, æˆäº¤é‡, æˆäº¤é¢...
            df_index = ak.stock_zh_index_spot_sina()
            
            # ç›®æ ‡æ ¸å¿ƒæŒ‡æ•°
            target_indices = ['ä¸Šè¯æŒ‡æ•°', 'æ·±è¯æˆæŒ‡', 'åˆ›ä¸šæ¿æŒ‡']
            
            indices_data = []
            total_amount_raw = 0.0
            
            for _, row in df_index.iterrows():
                name = row['åç§°']
                
                # 1. æå–æ ¸å¿ƒæŒ‡æ•°æ¶¨è·Œ
                if name in target_indices:
                    try:
                        change_pct = float(row['æ¶¨è·Œå¹…'])
                        close = float(row['æœ€æ–°ä»·'])
                        indices_data.append({
                            'name': name,
                            'change_pct': change_pct,
                            'close': close
                        })
                    except:
                        continue

                # 2. ç´¯åŠ ä¸¤å¸‚æ€»æˆäº¤é¢ 
                # æ–°æµªæ¥å£é‡Œï¼šä¸Šè¯æŒ‡æ•° + æ·±è¯æˆæŒ‡ çš„æˆäº¤é¢ = ä¸¤å¸‚æ€»æˆäº¤
                if name in ['ä¸Šè¯æŒ‡æ•°', 'æ·±è¯æˆæŒ‡']:
                    try:
                        amount = float(row['æˆäº¤é¢'])
                        total_amount_raw += amount
                    except:
                        pass

            # å•ä½è½¬æ¢ï¼šå…ƒ -> äº¿
            total_volume_yi = round(total_amount_raw / 100000000, 2)
            
            result = {
                'success': True,
                'total_volume': total_volume_yi,
                'indices': indices_data
            }

            # å†™å…¥ç¼“å­˜
            self._cache_data = result
            self._last_fetch_time = time.time()
            
            # logger.info(f"âœ… å¤§ç›˜æ•°æ®å·²æ›´æ–°: {total_volume_yi}äº¿")
            return result

        except Exception as e:
            logger.warning(f"âŒ å¤§ç›˜æŒ‡æ•°è·å–å¤±è´¥ (ä½¿ç”¨ç¼“å­˜æˆ–ç©ºå€¼): {e}")
            # å¦‚æœè¯·æ±‚å¤±è´¥ä½†æœ‰æ—§ç¼“å­˜ï¼Œä¼˜å…ˆè¿”å›æ—§ç¼“å­˜
            if self._cache_data:
                return self._cache_data
            return {'success': False, 'error': str(e)}

# å®ä¾‹åŒ–å¹¶å¯¼å‡º
market_monitor = MarketMonitor()
--------------------

#File: data_provider/baostock_fetcher.py
--------------------
# -*- coding: utf-8 -*-
import logging
import re
import os
import threading
import atexit
from contextlib import contextmanager
from typing import Optional
import pandas as pd
from tenacity import retry, stop_after_attempt, wait_exponential

from .base import BaseFetcher, DataFetchError, STANDARD_COLUMNS

logger = logging.getLogger(__name__)

# === å…¨å±€é” ===
_BS_LOCK = threading.Lock()
# === å…¨å±€ç™»å½•çŠ¶æ€æ ‡è®° ===
_BS_LOGGED_IN = False

def _cleanup_baostock():
    """ç¨‹åºé€€å‡ºæ—¶æ¸…ç†è¿æ¥"""
    import baostock as bs
    try:
        bs.logout()
    except:
        pass

# æ³¨å†Œé€€å‡ºæ—¶çš„æ¸…ç†å‡½æ•°
atexit.register(_cleanup_baostock)

def _is_us_code(stock_code: str) -> bool:
    return bool(re.match(r'^[A-Z]{1,5}(\.[A-Z])?$', stock_code.strip().upper()))

class BaostockFetcher(BaseFetcher):
    name = "BaostockFetcher"
    priority = 0
    
    def __init__(self):
        self._bs_module = None
    
    def _get_baostock(self):
        if self._bs_module is None:
            import baostock as bs
            self._bs_module = bs
        return self._bs_module
    
    @contextmanager
    def _baostock_session(self):
        """
        ç®¡ç† Baostock ä¼šè¯ (é•¿è¿æ¥æ¨¡å¼)
        """
        global _BS_LOGGED_IN
        
        # åŠ é”é˜²æ­¢å¤šçº¿ç¨‹ç«äº‰
        with _BS_LOCK:
            bs = self._get_baostock()
            
            # å¦‚æœæ²¡ç™»å½•ï¼Œæˆ–è€…è¿æ¥ä¼¼ä¹æ–­äº†ï¼Œå°è¯•ç™»å½•
            if not _BS_LOGGED_IN:
                try:
                    lg = bs.login()
                    if lg.error_code == '0':
                        _BS_LOGGED_IN = True
                        logger.info(f"[Baostock] ç™»å½•æˆåŠŸ")
                    else:
                        logger.warning(f"[Baostock] ç™»å½•å¤±è´¥: {lg.error_msg}")
                except Exception as e:
                    logger.warning(f"[Baostock] ç™»å½•å¼‚å¸¸: {e}")

            # ç›´æ¥ yield bsï¼Œä¸è¦åœ¨ finally é‡Œ logoutï¼
            yield bs
            
            # æ³¨æ„ï¼šè¿™é‡Œå»æ‰äº† logout()ï¼Œä¿æŒè¿æ¥æ´»è·ƒ
            # åªæœ‰åœ¨ç¨‹åºå½»åº•é€€å‡ºæ—¶ (atexit) æ‰æ‰§è¡Œ logout

    def _convert_code(self, code: str) -> str:
        code = code.strip()
        if '.' in code: return code.lower()
        if code.startswith(('6', '5', '9', '688')): return f"sh.{code}"
        else: return f"sz.{code}"

    @retry(stop=stop_after_attempt(2), wait=wait_exponential(multiplier=1, min=2, max=5))
    def _fetch_raw_data(self, stock_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        if _is_us_code(stock_code): return pd.DataFrame()
        bs_code = self._convert_code(stock_code)
        
        with self._baostock_session() as bs:
            # å°è¯•è·å–æ•°æ®
            rs = bs.query_history_k_data_plus(
                code=bs_code,
                fields="date,open,high,low,close,volume,amount,pctChg",
                start_date=start_date,
                end_date=end_date,
                frequency="d",
                adjustflag="2"
            )
            
            # å¦‚æœæŸ¥è¯¢å¤±è´¥ï¼ˆå¯èƒ½æ˜¯è¿æ¥è¶…æ—¶ï¼‰ï¼Œå°è¯•å¼ºåˆ¶é‡è¿ä¸€æ¬¡
            if rs.error_code != '0':
                logger.warning(f"[Baostock] è·å– {stock_code} å¤±è´¥: {rs.error_msg}ï¼Œå°è¯•é‡è¿...")
                global _BS_LOGGED_IN
                try:
                    bs.logout()
                except: pass
                _BS_LOGGED_IN = False # æ ‡è®°ä¸ºæœªç™»å½•ï¼Œä¸‹æ¬¡å¾ªç¯ä¼šè‡ªåŠ¨é‡ç™»
                return pd.DataFrame()
            
            data_list = []
            while rs.next():
                data_list.append(rs.get_row_data())
            
            if not data_list: 
                return pd.DataFrame()
                
            return pd.DataFrame(data_list, columns=rs.fields)

    def _normalize_data(self, df: pd.DataFrame, stock_code: str) -> pd.DataFrame:
        if df.empty: return df
        df = df.copy()
        df = df.rename(columns={'pctChg': 'pct_chg'})
        for col in ['open', 'high', 'low', 'close', 'volume', 'amount', 'pct_chg']:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
        df['code'] = stock_code
        for col in STANDARD_COLUMNS:
            if col not in df.columns: df[col] = 0
        return df[STANDARD_COLUMNS + ['code']]

    def get_stock_name(self, stock_code: str) -> Optional[str]:
        try:
            bs_code = self._convert_code(stock_code)
            with self._baostock_session() as bs:
                rs = bs.query_stock_basic(code=bs_code)
                if rs.error_code == '0' and rs.next():
                    row = rs.get_row_data()
                    if len(row) > 1: return row[1]
        except: pass
        return None

--------------------

#File: data_provider/pytdx_fetcher.py
--------------------
# -*- coding: utf-8 -*-
import logging
import re
import os
import threading
import pandas as pd
from contextlib import contextmanager
from typing import Optional, List, Tuple
from tenacity import retry, stop_after_attempt, wait_exponential

from .base import BaseFetcher, DataFetchError, STANDARD_COLUMNS

logger = logging.getLogger(__name__)

# === å…¨å±€é”ï¼šPytdx åœ¨é«˜å¹¶å‘ä¸‹ä¹Ÿå®¹æ˜“å‡ºç° Socket ç«äº‰ï¼ŒåŠ é”ä¿å¹³å®‰ ===
_PYTDX_LOCK = threading.Lock()

def _is_us_code(stock_code: str) -> bool:
    return bool(re.match(r'^[A-Z]{1,5}(\.[A-Z])?$', stock_code.strip().upper()))

class PytdxFetcher(BaseFetcher):
    name = "PytdxFetcher"
    priority = int(os.getenv("PYTDX_PRIORITY", "1"))
    
    DEFAULT_HOSTS = [
        ("119.147.212.81", 7709),
        ("112.74.214.43", 7727),
        ("221.231.141.60", 7709),
        ("101.227.73.20", 7709), 
        ("14.215.128.18", 7709),
    ]
    
    def __init__(self, hosts: Optional[List[Tuple[str, int]]] = None):
        self._hosts = hosts or self.DEFAULT_HOSTS
        self._current_host_idx = 0
        self._stock_list_cache = None
        self._stock_name_cache = {}
    
    def _get_pytdx(self):
        try:
            from pytdx.hq import TdxHq_API
            return TdxHq_API
        except ImportError:
            return None
    
    @contextmanager
    def _pytdx_session(self):
        # ğŸ”¥ å…³é”®ä¿®æ”¹ï¼šåŠ é”
        with _PYTDX_LOCK:
            TdxHq_API = self._get_pytdx()
            if TdxHq_API is None: raise DataFetchError("pytdxæœªå®‰è£…")
            
            api = TdxHq_API()
            connected = False
            
            try:
                for i in range(len(self._hosts)):
                    host_idx = (self._current_host_idx + i) % len(self._hosts)
                    host, port = self._hosts[host_idx]
                    try:
                        if api.connect(host, port, time_out=5):
                            connected = True
                            self._current_host_idx = host_idx
                            break
                    except: continue
                
                if not connected: raise DataFetchError("æ— æ³•è¿æ¥é€šè¾¾ä¿¡æœåŠ¡å™¨")
                yield api
                
            finally:
                try: api.disconnect()
                except: pass
    
    def _get_market_code(self, stock_code: str) -> Tuple[int, str]:
        code = stock_code.strip()
        if code.startswith(('60', '68')): return 1, code
        return 0, code
    
    @retry(stop=stop_after_attempt(2))
    def _fetch_raw_data(self, stock_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        if _is_us_code(stock_code): return pd.DataFrame()
        market, code = self._get_market_code(stock_code)
        
        # ä¼°ç®—æ•°é‡ï¼Œå®å¤šå‹¿å°‘
        count = 800 
        
        with self._pytdx_session() as api:
            data = api.get_security_bars(9, market, code, 0, count) # 9=æ—¥çº¿
            if not data: return pd.DataFrame()
            
            df = api.to_df(data)
            df['datetime'] = pd.to_datetime(df['datetime'])
            df = df[(df['datetime'] >= start_date) & (df['datetime'] <= end_date)]
            return df
    
    def _normalize_data(self, df: pd.DataFrame, stock_code: str) -> pd.DataFrame:
        if df.empty: return df
        df = df.copy()
        df = df.rename(columns={'datetime': 'date', 'vol': 'volume'})
        
        if 'pct_chg' not in df.columns and 'close' in df.columns:
            df['pct_chg'] = df['close'].pct_change() * 100
            df['pct_chg'] = df['pct_chg'].fillna(0).round(2)
            
        df['code'] = stock_code
        for col in STANDARD_COLUMNS:
            if col not in df.columns: df[col] = 0
        return df[STANDARD_COLUMNS + ['code']]

    def get_stock_name(self, stock_code: str) -> Optional[str]:
        if stock_code in self._stock_name_cache: return self._stock_name_cache[stock_code]
        try:
            market, code = self._get_market_code(stock_code)
            with self._pytdx_session() as api:
                # ç®€å•ç¼“å­˜ç­–ç•¥
                if not self._stock_list_cache:
                    sz = api.get_security_list(0, 0)
                    sh = api.get_security_list(1, 0)
                    self._stock_list_cache = {}
                    for s in (sz or []) + (sh or []):
                        self._stock_list_cache[s['code']] = s['name']
                
                name = self._stock_list_cache.get(code)
                if name:
                    self._stock_name_cache[stock_code] = name
                    return name
        except: pass
        return None

--------------------

#File: data_provider/base.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
æ•°æ®æºåŸºç±»ä¸ç®¡ç†å™¨
===================================
"""

import logging
import random
import time
from abc import ABC, abstractmethod
from datetime import datetime
from typing import Optional, List, Tuple, Dict, Any

import pandas as pd
from tenacity import retry, stop_after_attempt, wait_exponential

logger = logging.getLogger(__name__)

STANDARD_COLUMNS = ['date', 'open', 'high', 'low', 'close', 'volume', 'amount', 'pct_chg']

class DataFetchError(Exception): pass
class RateLimitError(DataFetchError): pass
class DataSourceUnavailableError(DataFetchError): pass

class BaseFetcher(ABC):
    name: str = "BaseFetcher"
    priority: int = 99
    
    @abstractmethod
    def _fetch_raw_data(self, stock_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        pass
    
    @abstractmethod
    def _normalize_data(self, df: pd.DataFrame, stock_code: str) -> pd.DataFrame:
        pass

    def get_main_indices(self) -> Optional[List[Dict[str, Any]]]: return None
    def get_market_stats(self) -> Optional[Dict[str, Any]]: return None
    def get_sector_rankings(self, n: int = 5) -> Optional[Tuple[List[Dict], List[Dict]]]: return None
    def get_chip_distribution(self, stock_code: str): return None
    def get_stock_name(self, stock_code: str): return None
    def get_stock_list(self): return None

    def get_daily_data(self, stock_code: str, start_date: Optional[str] = None, end_date: Optional[str] = None, days: int = 30) -> pd.DataFrame:
        if end_date is None: end_date = datetime.now().strftime('%Y-%m-%d')
        if start_date is None:
            from datetime import timedelta
            start_dt = datetime.strptime(end_date, '%Y-%m-%d') - timedelta(days=days * 2 + 20)
            start_date = start_dt.strftime('%Y-%m-%d')
        
        try:
            raw_df = self._fetch_raw_data(stock_code, start_date, end_date)
            if raw_df is None or raw_df.empty:
                raise DataFetchError(f"[{self.name}] æœªè·å–åˆ°æ•°æ®")
            
            df = self._normalize_data(raw_df, stock_code)
            df = self._clean_data(df)
            df = self._calculate_indicators(df)
            
            logger.info(f"âœ… [{self.name}] {stock_code} è·å–æˆåŠŸ ({len(df)}æ¡)")
            return df
        except Exception as e:
            raise DataFetchError(f"[{self.name}] {stock_code}: {str(e)}") from e
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()
        if 'date' in df.columns: 
            df['date'] = pd.to_datetime(df['date'])
            if df['date'].dt.tz is not None:
                df['date'] = df['date'].dt.tz_localize(None)

        for col in ['open', 'high', 'low', 'close', 'volume', 'amount', 'pct_chg']:
            if col in df.columns: df[col] = pd.to_numeric(df[col], errors='coerce')
        
        df = df.dropna(subset=['close'])
        df = df.sort_values('date', ascending=True).reset_index(drop=True)
        return df
    
    def _calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        if len(df) < 5: return df
        df = df.copy()
        df['ma5'] = df['close'].rolling(window=5).mean()
        df['ma10'] = df['close'].rolling(window=10).mean()
        df['ma20'] = df['close'].rolling(window=20).mean()
        avg_vol = df['volume'].rolling(window=5).mean().shift(1)
        df['volume_ratio'] = df['volume'] / avg_vol
        df['volume_ratio'] = df['volume_ratio'].fillna(1.0).round(2)
        return df
    
    @staticmethod
    def random_sleep(min_seconds: float = 1.0, max_seconds: float = 3.0) -> None:
        time.sleep(random.uniform(min_seconds, max_seconds))


class DataFetcherManager:
    def __init__(self, fetchers: Optional[List[BaseFetcher]] = None):
        self._fetchers: List[BaseFetcher] = []
        self._chip_cache = {} 
        self._stock_name_cache = {}
        self._init_default_fetchers()
    
    def _init_default_fetchers(self) -> None:
        from .efinance_fetcher import EfinanceFetcher
        from .akshare_fetcher import AkshareFetcher
        from .tushare_fetcher import TushareFetcher
        from .pytdx_fetcher import PytdxFetcher
        from .baostock_fetcher import BaostockFetcher
        from .yfinance_fetcher import YfinanceFetcher
        
        akshare = AkshareFetcher()
        efinance = EfinanceFetcher()
        baostock = BaostockFetcher()
        tushare = TushareFetcher()
        yfinance = YfinanceFetcher()
        pytdx = PytdxFetcher()
        
        # æ¨èé¡ºåº
        akshare.priority = 0
        efinance.priority = 1
        baostock.priority = 2
        tushare.priority = 3
        yfinance.priority = 4
        pytdx.priority = 5

        self._fetchers = [akshare, efinance, baostock, tushare, yfinance, pytdx]
        self._fetchers.sort(key=lambda f: f.priority)
        
        logger.info(f"ğŸš€ æ•°æ®æºåŠ è½½é¡ºåº: {', '.join([f.name for f in self._fetchers])}")

    def get_daily_data(self, stock_code: str, **kwargs) -> Tuple[pd.DataFrame, str]:
        errors = []
        for fetcher in self._fetchers:
            try:
                df = fetcher.get_daily_data(stock_code, **kwargs)
                if df is not None and not df.empty:
                    return df, fetcher.name
            except Exception as e:
                errors.append(f"{fetcher.name}: {e}")
                continue
        logger.error(f"âŒ æ‰€æœ‰æ•°æ®æºå‡å¤±è´¥ {stock_code}: {errors}")
        raise DataFetchError(f"æ‰€æœ‰æºå¤±è´¥: {stock_code}")
    
    def get_merged_data(self, code: str, days: int = 120) -> pd.DataFrame:
        """
        ã€æ ¸å¿ƒæ–¹æ³•ã€‘è·å–"ç¼åˆå"çš„ K çº¿æ•°æ®
        é€»è¾‘ï¼šæœ¬åœ°æ•°æ®åº“å†å² + å®æ—¶è¡Œæƒ…å¿«ç…§ = åŒ…å«ä»Šå¤©çš„å®Œæ•´ DataFrame
        """
        # 1. å°è¯•ä»æœ¬åœ°æ•°æ®åº“è¯»å–å†å²åº•åº§
        from src.storage import get_db
        db = get_db()
        df_history = db.get_stock_history_df(code, days=days)
        
        # å¦‚æœæ•°æ®åº“å®Œå…¨æ²¡æ•°æ®ï¼ˆæ–°å…³æ³¨çš„è‚¡ï¼‰ï¼Œåªèƒ½èµ°è€è·¯å­å»ç½‘ä¸ŠæŠ“å…¨é‡
        if df_history.empty:
            logger.info(f"[{code}] æœ¬åœ°æ— æ•°æ®ï¼Œæ‰§è¡Œå…¨é‡æŠ“å–...")
            df_new, _ = self.get_daily_data(code, days=days)
            return df_new

        # 2. è·å–å®æ—¶è¡Œæƒ…å¿«ç…§ (Snapshot)
        realtime_quote = self.get_realtime_quote(code)
        if not realtime_quote:
            logger.warning(f"[{code}] æ— æ³•è·å–å®æ—¶è¡Œæƒ…ï¼Œä»…è¿”å›å†å²æ•°æ®")
            return df_history

        # 3. åˆ¤æ–­æ˜¯å¦éœ€è¦ç¼åˆ
        # é€»è¾‘ï¼šå¦‚æœå®æ—¶è¡Œæƒ…çš„æ—¥æœŸ > å†å²æ•°æ®çš„æœ€åä¸€å¤©ï¼Œè¯´æ˜æ˜¯æ–°çš„ä¸€å¤©ï¼ˆæˆ–è€…ä»Šå¤©æ˜¯äº¤æ˜“æ—¥ä¸”æ­£åœ¨ç›˜ä¸­ï¼‰
        try:
            if not df_history.empty:
                last_date = df_history.iloc[-1]['date'].date()
                today_date = datetime.now().date()
                
                # ç®€å•åˆ¤æ–­ï¼šå¦‚æœå†å²æ•°æ®çš„æœ€åä¸€å¤©ä¸æ˜¯ä»Šå¤©ï¼Œå°è¯•ç¼åˆ
                if last_date < today_date:
                    # æ„é€ ä»Šå¤©çš„ K çº¿è¡Œ (Mock Bar)
                    today_row = self._create_mock_bar(realtime_quote, df_history)
                    if today_row is not None:
                        # æ‹¼æ¥åˆ°æœ€å
                        df_merged = pd.concat([df_history, today_row], ignore_index=True)
                        return df_merged
        except Exception as e:
            logger.error(f"[{code}] æ•°æ®ç¼åˆåˆ¤æ–­å¼‚å¸¸: {e}")
        
        # å¦‚æœæ— éœ€ç¼åˆï¼Œç›´æ¥è¿”å›å†å²
        return df_history

    def _create_mock_bar(self, quote, df_history: pd.DataFrame) -> Optional[pd.DataFrame]:
        """
        æ„é€ "è™šæ‹Ÿ K çº¿" (Mock Bar)
        åœ¨æ­¤å¤„è§£å†³ç›˜ä¸­æˆäº¤é‡å¤±çœŸçš„é—®é¢˜
        """
        try:
            # 1. åŸºç¡€æ•°æ®æ˜ å°„
            now = datetime.now()
            # è½¬æ¢æ—¶é—´ï¼šå¦‚æœç°åœ¨æ˜¯ç›˜å‰(æ¯”å¦‚9:25å‰)ï¼Œä¸è¦ç”Ÿæˆä»Šå¤©çš„Kçº¿
            if now.hour < 9 or (now.hour == 9 and now.minute < 25):
                return None

            # 2. æ ¸å¿ƒï¼šæˆäº¤é‡é¢„æµ‹ (Virtual Volume)
            # å…¬å¼ï¼šå½“å‰é‡ / (å·²å¼€ç›˜åˆ†é’Ÿæ•° / 240)
            current_volume = quote.volume if quote.volume else 0
            predicted_volume = current_volume 
            
            # è®¡ç®—å¼€ç›˜åˆ†é’Ÿæ•° (Aè‚¡: 9:30-11:30, 13:00-15:00)
            minutes_elapsed = 0
            if 9 <= now.hour < 15:
                # è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ä¼°ç®—ï¼Œè¶³å¤Ÿç”¨äºé‡æ¯”åˆ†æ
                morning_minutes = max(0, min(120, (now.hour - 9) * 60 + now.minute - 30)) if now.hour < 12 else 120
                afternoon_minutes = max(0, min(120, (now.hour - 13) * 60 + now.minute)) if now.hour >= 13 else 0
                minutes_elapsed = morning_minutes + afternoon_minutes
                
                # åªæœ‰åœ¨å¼€ç›˜åè¶…è¿‡10åˆ†é’Ÿæ‰åšé¢„æµ‹ï¼Œä¸”é˜²æ­¢é™¤é›¶
                if minutes_elapsed > 10:
                    projection_factor = 240 / minutes_elapsed
                    predicted_volume = current_volume * projection_factor
            
            # 3. æ„é€  DataFrame è¡Œ
            data = {
                'date': [pd.Timestamp(now.date())],
                'open': [quote.open_price],
                'high': [quote.high],
                'low': [quote.low],
                'close': [quote.price],
                'volume': [predicted_volume], # ä½¿ç”¨é¢„æµ‹é‡ç”¨äºæŒ‡æ ‡è®¡ç®—
                'amount': [quote.amount],
                'pct_chg': [quote.change_pct],
                'volume_ratio': [quote.volume_ratio if quote.volume_ratio else 0.0] # æ˜¾å¼ä¼ é€’é‡æ¯”
            }
            return pd.DataFrame(data)
            
        except Exception as e:
            logger.error(f"æ„é€ è™šæ‹ŸKçº¿å¤±è´¥: {e}")
            return None

    def prefetch_realtime_quotes(self, stock_codes: List[str]) -> int:
        from src.config import get_config
        if not get_config().enable_realtime_quote: return 0
        if len(stock_codes) < 5: return 0
        try:
            self.get_realtime_quote(stock_codes[0])
            return len(stock_codes)
        except: return 0

    def get_realtime_quote(self, stock_code: str):
        from .akshare_fetcher import _is_us_code
        from src.config import get_config
        
        config = get_config()
        if not config.enable_realtime_quote: return None
        
        if _is_us_code(stock_code):
            for f in self._fetchers:
                if f.name == 'YfinanceFetcher' and hasattr(f, 'get_realtime_quote'):
                    return f.get_realtime_quote(stock_code)
            return None

        # ğŸ”¥ è¯»å–é…ç½®ä¸­çš„ä¼˜å…ˆçº§
        priorities = config.realtime_source_priority.split(',')
        
        for source in priorities:
            source = source.strip()
            try:
                if 'akshare' in source:
                    fetcher = next((f for f in self._fetchers if f.name == 'AkshareFetcher'), None)
                    if fetcher:
                        sub_source = source.split('_')[1] if '_' in source else 'sina'
                        q = fetcher.get_realtime_quote(stock_code, source=sub_source)
                        if q: return q
                elif source == 'efinance':
                    fetcher = next((f for f in self._fetchers if f.name == 'EfinanceFetcher'), None)
                    if fetcher:
                        q = fetcher.get_realtime_quote(stock_code)
                        if q: return q
            except Exception: continue
        return None

    def get_chip_distribution(self, stock_code: str):
        from .realtime_types import get_chip_circuit_breaker
        from src.config import get_config
        
        # ğŸ”¥ è¯»å–é…ç½®ä¸­çš„å¼€å…³
        if not get_config().enable_chip_distribution: return None
        if stock_code in self._chip_cache: return self._chip_cache[stock_code]
        
        circuit_breaker = get_chip_circuit_breaker()
        for fetcher in self._fetchers:
            source_key = f"{fetcher.name}_chip"
            if not circuit_breaker.is_available(source_key): continue
            
            if hasattr(fetcher, 'get_chip_distribution'):
                try:
                    chip = fetcher.get_chip_distribution(stock_code)
                    if chip:
                        circuit_breaker.record_success(source_key)
                        self._chip_cache[stock_code] = chip
                        return chip
                except Exception as e:
                    circuit_breaker.record_failure(source_key, str(e))
                    continue
        return None

    def get_stock_name(self, stock_code: str) -> Optional[str]:
        if stock_code in self._stock_name_cache: return self._stock_name_cache[stock_code]
        q = self.get_realtime_quote(stock_code)
        if q and q.name:
            self._stock_name_cache[stock_code] = q.name
            return q.name
        for f in self._fetchers:
            if hasattr(f, 'get_stock_name'):
                try:
                    name = f.get_stock_name(stock_code)
                    if name:
                        self._stock_name_cache[stock_code] = name
                        return name
                except: continue
        return stock_code
        
    def batch_get_stock_names(self, stock_codes: List[str]) -> Dict[str, str]:
        res = {}
        for code in stock_codes:
            name = self.get_stock_name(code)
            if name: res[code] = name
        return res
    
    def get_main_indices(self):
        for f in self._fetchers:
            try:
                res = f.get_main_indices()
                if res: return res
            except: continue
        return []

    def get_market_stats(self):
        for f in self._fetchers:
            try:
                res = f.get_market_stats()
                if res: return res
            except: continue
        return {}

    def get_sector_rankings(self, n=5):
        for f in self._fetchers:
            try:
                res = f.get_sector_rankings(n)
                if res: return res
            except: continue
        return [], []

--------------------

#File: web/services.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Web æœåŠ¡å±‚ - ä¸šåŠ¡é€»è¾‘
===================================

èŒè´£ï¼š
1. é…ç½®ç®¡ç†æœåŠ¡ (ConfigService)
2. åˆ†æä»»åŠ¡æœåŠ¡ (AnalysisService)
"""

from __future__ import annotations

import os
import re
import logging
import threading
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from typing import Optional, Dict, Any, List, Union

from src.enums import ReportType
from src.storage import get_db
from bot.models import BotMessage

logger = logging.getLogger(__name__)

# ============================================================
# é…ç½®ç®¡ç†æœåŠ¡
# ============================================================

_ENV_PATH = os.getenv("ENV_FILE", ".env")

_STOCK_LIST_RE = re.compile(
    r"^(?P<prefix>\s*STOCK_LIST\s*=\s*)(?P<value>.*?)(?P<suffix>\s*)$"
)


class ConfigService:
    """
    é…ç½®ç®¡ç†æœåŠ¡
    
    è´Ÿè´£ .env æ–‡ä»¶ä¸­ STOCK_LIST çš„è¯»å†™æ“ä½œ
    """
    
    def __init__(self, env_path: Optional[str] = None):
        self.env_path = env_path or _ENV_PATH
    
    def read_env_text(self) -> str:
        """è¯»å– .env æ–‡ä»¶å†…å®¹"""
        try:
            with open(self.env_path, "r", encoding="utf-8") as f:
                return f.read()
        except FileNotFoundError:
            return ""
    
    def write_env_text(self, text: str) -> None:
        """å†™å…¥ .env æ–‡ä»¶å†…å®¹"""
        with open(self.env_path, "w", encoding="utf-8") as f:
            f.write(text)
    
    def get_stock_list(self) -> str:
        """è·å–å½“å‰è‡ªé€‰è‚¡åˆ—è¡¨å­—ç¬¦ä¸²"""
        env_text = self.read_env_text()
        return self._extract_stock_list(env_text)
    
    def set_stock_list(self, stock_list: str) -> str:
        """
        è®¾ç½®è‡ªé€‰è‚¡åˆ—è¡¨
        
        Args:
            stock_list: è‚¡ç¥¨ä»£ç å­—ç¬¦ä¸²ï¼ˆé€—å·æˆ–æ¢è¡Œåˆ†éš”ï¼‰
            
        Returns:
            è§„èŒƒåŒ–åçš„è‚¡ç¥¨åˆ—è¡¨å­—ç¬¦ä¸²
        """
        env_text = self.read_env_text()
        normalized = self._normalize_stock_list(stock_list)
        updated = self._update_stock_list(env_text, normalized)
        self.write_env_text(updated)
        return normalized
    
    def get_env_filename(self) -> str:
        """è·å– .env æ–‡ä»¶å"""
        return os.path.basename(self.env_path)
    
    def _extract_stock_list(self, env_text: str) -> str:
        """ä»ç¯å¢ƒæ–‡ä»¶ä¸­æå– STOCK_LIST å€¼"""
        for line in env_text.splitlines():
            m = _STOCK_LIST_RE.match(line)
            if m:
                raw = m.group("value").strip()
                # å»é™¤å¼•å·
                if (raw.startswith('"') and raw.endswith('"')) or \
                   (raw.startswith("'") and raw.endswith("'")):
                    raw = raw[1:-1]
                return raw
        return ""
    
    def _normalize_stock_list(self, value: str) -> str:
        """è§„èŒƒåŒ–è‚¡ç¥¨åˆ—è¡¨æ ¼å¼"""
        parts = [p.strip() for p in value.replace("\n", ",").split(",")]
        parts = [p for p in parts if p]
        return ",".join(parts)
    
    def _update_stock_list(self, env_text: str, new_value: str) -> str:
        """æ›´æ–°ç¯å¢ƒæ–‡ä»¶ä¸­çš„ STOCK_LIST"""
        lines = env_text.splitlines(keepends=False)
        out_lines: List[str] = []
        replaced = False
        
        for line in lines:
            m = _STOCK_LIST_RE.match(line)
            if not m:
                out_lines.append(line)
                continue
            
            out_lines.append(f"{m.group('prefix')}{new_value}{m.group('suffix')}")
            replaced = True
        
        if not replaced:
            if out_lines and out_lines[-1].strip() != "":
                out_lines.append("")
            out_lines.append(f"STOCK_LIST={new_value}")
        
        trailing_newline = env_text.endswith("\n") if env_text else True
        out = "\n".join(out_lines)
        return out + ("\n" if trailing_newline else "")


# ============================================================
# åˆ†æä»»åŠ¡æœåŠ¡
# ============================================================

class AnalysisService:
    """
    åˆ†æä»»åŠ¡æœåŠ¡
    
    è´Ÿè´£ï¼š
    1. ç®¡ç†å¼‚æ­¥åˆ†æä»»åŠ¡
    2. æ‰§è¡Œè‚¡ç¥¨åˆ†æ
    3. è§¦å‘é€šçŸ¥æ¨é€
    """
    
    _instance: Optional['AnalysisService'] = None
    _lock = threading.Lock()
    
    def __init__(self, max_workers: int = 3):
        self._executor: Optional[ThreadPoolExecutor] = None
        self._max_workers = max_workers
        self._tasks: Dict[str, Dict[str, Any]] = {}
        self._tasks_lock = threading.Lock()
    
    @classmethod
    def get_instance(cls) -> 'AnalysisService':
        """è·å–å•ä¾‹å®ä¾‹"""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = cls()
        return cls._instance
    
    @property
    def executor(self) -> ThreadPoolExecutor:
        """è·å–æˆ–åˆ›å»ºçº¿ç¨‹æ± """
        if self._executor is None:
            self._executor = ThreadPoolExecutor(
                max_workers=self._max_workers,
                thread_name_prefix="analysis_"
            )
        return self._executor
    
    def submit_analysis(
        self, 
        code: str, 
        report_type: Union[ReportType, str] = ReportType.SIMPLE,
        source_message: Optional[BotMessage] = None,
        save_context_snapshot: Optional[bool] = None
    ) -> Dict[str, Any]:
        """
        æäº¤å¼‚æ­¥åˆ†æä»»åŠ¡
        
        Args:
            code: è‚¡ç¥¨ä»£ç 
            report_type: æŠ¥å‘Šç±»å‹æšä¸¾
            
        Returns:
            ä»»åŠ¡ä¿¡æ¯å­—å…¸
        """
        # ç¡®ä¿ report_type æ˜¯æšä¸¾ç±»å‹
        if isinstance(report_type, str):
            report_type = ReportType.from_str(report_type)
        
        task_id = f"{code}_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"
        
        # æäº¤åˆ°çº¿ç¨‹æ± 
        self.executor.submit(
            self._run_analysis,
            code,
            task_id,
            report_type,
            source_message,
            save_context_snapshot
        )
        
        logger.info(f"[AnalysisService] å·²æäº¤è‚¡ç¥¨ {code} çš„åˆ†æä»»åŠ¡, task_id={task_id}, report_type={report_type.value}")
        
        return {
            "success": True,
            "message": "åˆ†æä»»åŠ¡å·²æäº¤ï¼Œå°†å¼‚æ­¥æ‰§è¡Œå¹¶æ¨é€é€šçŸ¥",
            "code": code,
            "task_id": task_id,
            "report_type": report_type.value
        }
    
    def get_task_status(self, task_id: str) -> Optional[Dict[str, Any]]:
        """è·å–ä»»åŠ¡çŠ¶æ€"""
        with self._tasks_lock:
            return self._tasks.get(task_id)
    
    def list_tasks(self, limit: int = 20) -> List[Dict[str, Any]]:
        """åˆ—å‡ºæœ€è¿‘çš„ä»»åŠ¡"""
        with self._tasks_lock:
            tasks = list(self._tasks.values())
        # æŒ‰å¼€å§‹æ—¶é—´å€’åº
        tasks.sort(key=lambda x: x.get('start_time', ''), reverse=True)
        return tasks[:limit]

    def get_analysis_history(
        self,
        code: Optional[str] = None,
        query_id: Optional[str] = None,
        days: int = 30,
        limit: int = 50
    ) -> List[Dict[str, Any]]:
        """
        è·å–åˆ†æå†å²è®°å½•
        """
        db = get_db()
        records = db.get_analysis_history(code=code, query_id=query_id, days=days, limit=limit)
        return [r.to_dict() for r in records]
    
    def _run_analysis(
        self, 
        code: str, 
        task_id: str, 
        report_type: ReportType = ReportType.SIMPLE,
        source_message: Optional[BotMessage] = None,
        save_context_snapshot: Optional[bool] = None
    ) -> Dict[str, Any]:
        """
        æ‰§è¡Œå•åªè‚¡ç¥¨åˆ†æ
        
        å†…éƒ¨æ–¹æ³•ï¼Œåœ¨çº¿ç¨‹æ± ä¸­è¿è¡Œ
        
        Args:
            code: è‚¡ç¥¨ä»£ç 
            task_id: ä»»åŠ¡ID
            report_type: æŠ¥å‘Šç±»å‹æšä¸¾
        """
        # åˆå§‹åŒ–ä»»åŠ¡çŠ¶æ€
        with self._tasks_lock:
            self._tasks[task_id] = {
                "task_id": task_id,
                "code": code,
                "status": "running",
                "start_time": datetime.now().isoformat(),
                "result": None,
                "error": None,
                "report_type": report_type.value
            }
        
        try:
            # å»¶è¿Ÿå¯¼å…¥é¿å…å¾ªç¯ä¾èµ–
            from src.config import get_config
            from main import StockAnalysisPipeline
            
            logger.info(f"[AnalysisService] å¼€å§‹åˆ†æè‚¡ç¥¨: {code}")
            
            # åˆ›å»ºåˆ†æç®¡é“
            config = get_config()
            pipeline = StockAnalysisPipeline(
                config=config,
                max_workers=1,
                source_message=source_message,
                query_id=task_id,
                query_source="web",
                save_context_snapshot=save_context_snapshot
            )
            
            # æ‰§è¡Œå•åªè‚¡ç¥¨åˆ†æï¼ˆå¯ç”¨å•è‚¡æ¨é€ï¼‰
            result = pipeline.process_single_stock(
                code=code,
                skip_analysis=False,
                single_stock_notify=True,
                report_type=report_type
            )
            
            if result:
                result_data = {
                    "code": result.code,
                    "name": result.name,
                    "sentiment_score": result.sentiment_score,
                    "operation_advice": result.operation_advice,
                    "trend_prediction": result.trend_prediction,
                    "analysis_summary": result.analysis_summary,
                }
                
                with self._tasks_lock:
                    self._tasks[task_id].update({
                        "status": "completed",
                        "end_time": datetime.now().isoformat(),
                        "result": result_data
                    })
                
                logger.info(f"[AnalysisService] è‚¡ç¥¨ {code} åˆ†æå®Œæˆ: {result.operation_advice}")
                return {"success": True, "task_id": task_id, "result": result_data}
            else:
                with self._tasks_lock:
                    self._tasks[task_id].update({
                        "status": "failed",
                        "end_time": datetime.now().isoformat(),
                        "error": "åˆ†æè¿”å›ç©ºç»“æœ"
                    })
                
                logger.warning(f"[AnalysisService] è‚¡ç¥¨ {code} åˆ†æå¤±è´¥: è¿”å›ç©ºç»“æœ")
                return {"success": False, "task_id": task_id, "error": "åˆ†æè¿”å›ç©ºç»“æœ"}
                
        except Exception as e:
            error_msg = str(e)
            logger.error(f"[AnalysisService] è‚¡ç¥¨ {code} åˆ†æå¼‚å¸¸: {error_msg}")
            
            with self._tasks_lock:
                self._tasks[task_id].update({
                    "status": "failed",
                    "end_time": datetime.now().isoformat(),
                    "error": error_msg
                })
            
            return {"success": False, "task_id": task_id, "error": error_msg}


# ============================================================
# ä¾¿æ·å‡½æ•°
# ============================================================

def get_config_service() -> ConfigService:
    """è·å–é…ç½®æœåŠ¡å®ä¾‹"""
    return ConfigService()


def get_analysis_service() -> AnalysisService:
    """è·å–åˆ†ææœåŠ¡å•ä¾‹"""
    return AnalysisService.get_instance()

--------------------

#File: web/server.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Web æœåŠ¡å™¨æ ¸å¿ƒ
===================================

èŒè´£ï¼š
1. å¯åŠ¨ HTTP æœåŠ¡å™¨
2. å¤„ç†è¯·æ±‚åˆ†å‘
3. æä¾›åå°è¿è¡Œæ¥å£
"""

from __future__ import annotations

import logging
import threading
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
from typing import Optional, Type

from web.router import Router, get_router

logger = logging.getLogger(__name__)


# ============================================================
# HTTP è¯·æ±‚å¤„ç†å™¨
# ============================================================

class WebRequestHandler(BaseHTTPRequestHandler):
    """
    HTTP è¯·æ±‚å¤„ç†å™¨
    
    å°†è¯·æ±‚åˆ†å‘åˆ°è·¯ç”±å™¨å¤„ç†
    """
    
    # ç±»çº§åˆ«çš„è·¯ç”±å™¨å¼•ç”¨
    router: Router = None  # type: ignore
    
    def do_GET(self) -> None:
        """å¤„ç† GET è¯·æ±‚"""
        self.router.dispatch(self, "GET")
    
    def do_POST(self) -> None:
        """å¤„ç† POST è¯·æ±‚"""
        self.router.dispatch_post(self)
    
    def log_message(self, fmt: str, *args) -> None:
        """è‡ªå®šä¹‰æ—¥å¿—æ ¼å¼ï¼ˆä½¿ç”¨ logging è€Œé stderrï¼‰"""
        # å¯ä»¥å–æ¶ˆæ³¨é‡Šä»¥å¯ç”¨è¯·æ±‚æ—¥å¿—
        # logger.debug(f"[WebServer] {self.address_string()} - {fmt % args}")
        pass


# ============================================================
# Web æœåŠ¡å™¨
# ============================================================

class WebServer:
    """
    Web æœåŠ¡å™¨
    
    å°è£… ThreadingHTTPServerï¼Œæä¾›ä¾¿æ·çš„å¯åŠ¨å’Œç®¡ç†æ¥å£
    
    ä½¿ç”¨æ–¹å¼ï¼š
        # å‰å°è¿è¡Œ
        server = WebServer(host="127.0.0.1", port=8000)
        server.run()
        
        # åå°è¿è¡Œ
        server = WebServer(host="127.0.0.1", port=8000)
        server.start_background()
    """
    
    def __init__(
        self,
        host: str = "127.0.0.1",
        port: int = 8000,
        router: Optional[Router] = None
    ):
        """
        åˆå§‹åŒ– Web æœåŠ¡å™¨
        
        Args:
            host: ç›‘å¬åœ°å€
            port: ç›‘å¬ç«¯å£
            router: è·¯ç”±å™¨å®ä¾‹ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä½¿ç”¨å…¨å±€è·¯ç”±ï¼‰
        """
        self.host = host
        self.port = port
        self.router = router or get_router()
        
        self._server: Optional[ThreadingHTTPServer] = None
        self._thread: Optional[threading.Thread] = None
    
    @property
    def address(self) -> str:
        """æœåŠ¡å™¨åœ°å€"""
        return f"http://{self.host}:{self.port}"
    
    def _create_handler_class(self) -> Type[WebRequestHandler]:
        """åˆ›å»ºå¸¦è·¯ç”±å™¨å¼•ç”¨çš„å¤„ç†å™¨ç±»"""
        router = self.router
        
        class Handler(WebRequestHandler):
            pass
        
        Handler.router = router
        return Handler
    
    def _create_server(self) -> ThreadingHTTPServer:
        """åˆ›å»º HTTP æœåŠ¡å™¨å®ä¾‹"""
        handler_class = self._create_handler_class()
        return ThreadingHTTPServer((self.host, self.port), handler_class)
    
    def run(self) -> None:
        """
        å‰å°è¿è¡ŒæœåŠ¡å™¨ï¼ˆé˜»å¡ï¼‰
        
        æŒ‰ Ctrl+C é€€å‡º
        """
        self._server = self._create_server()
        
        logger.info(f"WebUI æœåŠ¡å¯åŠ¨: {self.address}")
        print(f"WebUI æœåŠ¡å¯åŠ¨: {self.address}")
        
        # æ‰“å°è·¯ç”±åˆ—è¡¨
        routes = self.router.list_routes()
        if routes:
            logger.info("å·²æ³¨å†Œè·¯ç”±:")
            for method, path, desc in routes:
                logger.info(f"  {method:6} {path:20} - {desc}")
        
        try:
            self._server.serve_forever()
        except KeyboardInterrupt:
            logger.info("æ”¶åˆ°é€€å‡ºä¿¡å·ï¼ŒæœåŠ¡å™¨å…³é—­")
        finally:
            self._server.server_close()
            self._server = None
    
    def start_background(self) -> threading.Thread:
        """
        åå°è¿è¡ŒæœåŠ¡å™¨ï¼ˆéé˜»å¡ï¼‰
        
        Returns:
            æœåŠ¡å™¨çº¿ç¨‹
        """
        self._server = self._create_server()
        
        def serve():
            logger.info(f"WebUI å·²å¯åŠ¨: {self.address}")
            print(f"WebUI å·²å¯åŠ¨: {self.address}")
            try:
                self._server.serve_forever()
            except Exception as e:
                logger.error(f"WebUI å‘ç”Ÿé”™è¯¯: {e}")
            finally:
                if self._server:
                    self._server.server_close()
        
        self._thread = threading.Thread(target=serve, daemon=True)
        self._thread.start()
        return self._thread
    
    def stop(self) -> None:
        """åœæ­¢æœåŠ¡å™¨"""
        if self._server:
            self._server.shutdown()
            self._server.server_close()
            self._server = None
            logger.info("WebUI æœåŠ¡å·²åœæ­¢")
    
    def is_running(self) -> bool:
        """æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦è¿è¡Œä¸­"""
        return self._server is not None


# ============================================================
# ä¾¿æ·å‡½æ•°
# ============================================================

def run_server_in_thread(
    host: str = "127.0.0.1",
    port: int = 8000,
    router: Optional[Router] = None
) -> threading.Thread:
    """
    åœ¨åå°çº¿ç¨‹å¯åŠ¨ WebUI æœåŠ¡å™¨
    
    Args:
        host: ç›‘å¬åœ°å€
        port: ç›‘å¬ç«¯å£
        router: è·¯ç”±å™¨å®ä¾‹ï¼ˆå¯é€‰ï¼‰
        
    Returns:
        æœåŠ¡å™¨çº¿ç¨‹
    """
    server = WebServer(host=host, port=port, router=router)
    return server.start_background()


def run_server(
    host: str = "127.0.0.1",
    port: int = 8000,
    router: Optional[Router] = None
) -> None:
    """
    å‰å°è¿è¡Œ WebUI æœåŠ¡å™¨ï¼ˆé˜»å¡ï¼‰
    
    Args:
        host: ç›‘å¬åœ°å€
        port: ç›‘å¬ç«¯å£
        router: è·¯ç”±å™¨å®ä¾‹ï¼ˆå¯é€‰ï¼‰
    """
    server = WebServer(host=host, port=port, router=router)
    server.run()

--------------------

#File: web/handlers.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Web å¤„ç†å™¨å±‚ - è¯·æ±‚å¤„ç†
===================================

èŒè´£ï¼š
1. å¤„ç†å„ç±» HTTP è¯·æ±‚
2. è°ƒç”¨æœåŠ¡å±‚æ‰§è¡Œä¸šåŠ¡é€»è¾‘
3. è¿”å›å“åº”æ•°æ®

å¤„ç†å™¨åˆ†ç±»ï¼š
- PageHandler: é¡µé¢è¯·æ±‚å¤„ç†
- ApiHandler: API æ¥å£å¤„ç†
"""

from __future__ import annotations

import json
import re
import logging
from http import HTTPStatus
from datetime import datetime
from typing import Dict, Any, Optional, TYPE_CHECKING

from web.services import get_config_service, get_analysis_service
from web.templates import render_config_page
from src.enums import ReportType

if TYPE_CHECKING:
    from http.server import BaseHTTPRequestHandler

logger = logging.getLogger(__name__)


# ============================================================
# å“åº”è¾…åŠ©ç±»
# ============================================================

class Response:
    """HTTP å“åº”å°è£…"""
    
    def __init__(
        self,
        body: bytes,
        status: HTTPStatus = HTTPStatus.OK,
        content_type: str = "text/html; charset=utf-8"
    ):
        self.body = body
        self.status = status
        self.content_type = content_type
    
    def send(self, handler: 'BaseHTTPRequestHandler') -> None:
        """å‘é€å“åº”åˆ°å®¢æˆ·ç«¯"""
        handler.send_response(self.status)
        handler.send_header("Content-Type", self.content_type)
        handler.send_header("Content-Length", str(len(self.body)))
        handler.end_headers()
        handler.wfile.write(self.body)


class JsonResponse(Response):
    """JSON å“åº”å°è£…"""
    
    def __init__(
        self,
        data: Dict[str, Any],
        status: HTTPStatus = HTTPStatus.OK
    ):
        body = json.dumps(data, ensure_ascii=False, indent=2).encode("utf-8")
        super().__init__(
            body=body,
            status=status,
            content_type="application/json; charset=utf-8"
        )


class HtmlResponse(Response):
    """HTML å“åº”å°è£…"""
    
    def __init__(
        self,
        body: bytes,
        status: HTTPStatus = HTTPStatus.OK
    ):
        super().__init__(
            body=body,
            status=status,
            content_type="text/html; charset=utf-8"
        )


# ============================================================
# é¡µé¢å¤„ç†å™¨
# ============================================================

class PageHandler:
    """é¡µé¢è¯·æ±‚å¤„ç†å™¨"""
    
    def __init__(self):
        self.config_service = get_config_service()
    
    def handle_index(self) -> Response:
        """å¤„ç†é¦–é¡µè¯·æ±‚ GET /"""
        stock_list = self.config_service.get_stock_list()
        env_filename = self.config_service.get_env_filename()
        body = render_config_page(stock_list, env_filename)
        return HtmlResponse(body)
    
    def handle_update(self, form_data: Dict[str, list]) -> Response:
        """
        å¤„ç†é…ç½®æ›´æ–° POST /update
        
        Args:
            form_data: è¡¨å•æ•°æ®
        """
        stock_list = form_data.get("stock_list", [""])[0]
        normalized = self.config_service.set_stock_list(stock_list)
        env_filename = self.config_service.get_env_filename()
        body = render_config_page(normalized, env_filename, message="å·²ä¿å­˜")
        return HtmlResponse(body)


# ============================================================
# API å¤„ç†å™¨
# ============================================================

class ApiHandler:
    """API è¯·æ±‚å¤„ç†å™¨"""
    
    def __init__(self):
        self.analysis_service = get_analysis_service()
    
    def handle_health(self) -> Response:
        """
        å¥åº·æ£€æŸ¥ GET /health
        
        è¿”å›:
            {
                "status": "ok",
                "timestamp": "2026-01-19T10:30:00",
                "service": "stock-analysis-webui"
            }
        """
        data = {
            "status": "ok",
            "timestamp": datetime.now().isoformat(),
            "service": "stock-analysis-webui"
        }
        return JsonResponse(data)
    
    def handle_analysis(self, query: Dict[str, list]) -> Response:
        """
        è§¦å‘è‚¡ç¥¨åˆ†æ GET /analysis?code=xxx
        
        Args:
            query: URL æŸ¥è¯¢å‚æ•°
            
        è¿”å›:
            {
                "success": true,
                "message": "åˆ†æä»»åŠ¡å·²æäº¤",
                "code": "600519",
                "task_id": "600519_20260119_103000"
            }
        """
        # è·å–è‚¡ç¥¨ä»£ç å‚æ•°
        code_list = query.get("code", [])
        if not code_list or not code_list[0].strip():
            return JsonResponse(
                {"success": False, "error": "ç¼ºå°‘å¿…å¡«å‚æ•°: code (è‚¡ç¥¨ä»£ç )"},
                status=HTTPStatus.BAD_REQUEST
            )
        
        code = code_list[0].strip()

        # éªŒè¯è‚¡ç¥¨ä»£ç æ ¼å¼ï¼šAè‚¡(6ä½æ•°å­—) / æ¸¯è‚¡(HK+5ä½æ•°å­—) / ç¾è‚¡(1-5ä¸ªå¤§å†™å­—æ¯+.+2ä¸ªåç¼€å­—æ¯)
        code = code.upper()
        is_a_stock = re.match(r'^\d{6}$', code)
        is_hk_stock = re.match(r'^HK\d{5}$', code)
        is_us_stock = re.match(r'^[A-Z]{1,5}(\.[A-Z]{1,2})?$', code.upper())

        if not (is_a_stock or is_hk_stock or is_us_stock):
            return JsonResponse(
                {"success": False, "error": f"æ— æ•ˆçš„è‚¡ç¥¨ä»£ç æ ¼å¼: {code} (Aè‚¡6ä½æ•°å­— / æ¸¯è‚¡HK+5ä½æ•°å­— / ç¾è‚¡1-5ä¸ªå­—æ¯)"},
                status=HTTPStatus.BAD_REQUEST
            )
        
        # è·å–æŠ¥å‘Šç±»å‹å‚æ•°ï¼ˆé»˜è®¤ç²¾ç®€æŠ¥å‘Šï¼‰
        report_type_str = query.get("report_type", ["simple"])[0]
        report_type = ReportType.from_str(report_type_str)
        
        # æ˜¯å¦ä¿å­˜ä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆå¯é€‰ï¼Œé»˜è®¤è¯»å–é…ç½®ï¼‰
        save_snapshot = None
        if "save_context_snapshot" in query:
            save_snapshot = self._parse_bool(query.get("save_context_snapshot", [""])[0])

        # æäº¤å¼‚æ­¥åˆ†æä»»åŠ¡
        try:
            result = self.analysis_service.submit_analysis(
                code,
                report_type=report_type,
                save_context_snapshot=save_snapshot
            )
            return JsonResponse(result)
        except Exception as e:
            logger.error(f"[ApiHandler] æäº¤åˆ†æä»»åŠ¡å¤±è´¥: {e}")
            return JsonResponse(
                {"success": False, "error": f"æäº¤ä»»åŠ¡å¤±è´¥: {str(e)}"},
                status=HTTPStatus.INTERNAL_SERVER_ERROR
            )

    def handle_analysis_history(self, query: Dict[str, list]) -> Response:
        """
        æŸ¥è¯¢åˆ†æå†å² GET /analysis/history

        Args:
            query: URL æŸ¥è¯¢å‚æ•° (code, query_id, days, limit)
        """
        code = query.get("code", [""])[0].strip() or None
        query_id = query.get("query_id", [""])[0].strip() or None

        try:
            days = int(query.get("days", ["30"])[0])
        except ValueError:
            days = 30

        try:
            limit = int(query.get("limit", ["50"])[0])
        except ValueError:
            limit = 50

        history = self.analysis_service.get_analysis_history(
            code=code,
            query_id=query_id,
            days=days,
            limit=limit
        )

        return JsonResponse({
            "success": True,
            "records": history,
            "count": len(history)
        })

    @staticmethod
    def _parse_bool(value: str) -> Optional[bool]:
        """
        è§£æå¸ƒå°”å‚æ•°
        """
        text = (value or "").strip().lower()
        if text in {"1", "true", "yes", "y", "on"}:
            return True
        if text in {"0", "false", "no", "n", "off"}:
            return False
        return None
    
    def handle_tasks(self, query: Dict[str, list]) -> Response:
        """
        æŸ¥è¯¢ä»»åŠ¡åˆ—è¡¨ GET /tasks
        
        Args:
            query: URL æŸ¥è¯¢å‚æ•° (å¯é€‰ limit)
            
        è¿”å›:
            {
                "success": true,
                "tasks": [...]
            }
        """
        limit_list = query.get("limit", ["20"])
        try:
            limit = int(limit_list[0])
        except ValueError:
            limit = 20
        
        tasks = self.analysis_service.list_tasks(limit=limit)
        return JsonResponse({"success": True, "tasks": tasks})
    
    def handle_task_status(self, query: Dict[str, list]) -> Response:
        """
        æŸ¥è¯¢å•ä¸ªä»»åŠ¡çŠ¶æ€ GET /task?id=xxx
        
        Args:
            query: URL æŸ¥è¯¢å‚æ•°
        """
        task_id_list = query.get("id", [])
        if not task_id_list or not task_id_list[0].strip():
            return JsonResponse(
                {"success": False, "error": "ç¼ºå°‘å¿…å¡«å‚æ•°: id (ä»»åŠ¡ID)"},
                status=HTTPStatus.BAD_REQUEST
            )
        
        task_id = task_id_list[0].strip()
        task = self.analysis_service.get_task_status(task_id)
        
        if task is None:
            return JsonResponse(
                {"success": False, "error": f"ä»»åŠ¡ä¸å­˜åœ¨: {task_id}"},
                status=HTTPStatus.NOT_FOUND
            )
        
        return JsonResponse({"success": True, "task": task})


# ============================================================
# Bot Webhook å¤„ç†å™¨
# ============================================================

class BotHandler:
    """
    æœºå™¨äºº Webhook å¤„ç†å™¨
    
    å¤„ç†å„å¹³å°çš„æœºå™¨äººå›è°ƒè¯·æ±‚ã€‚
    """
    
    def handle_webhook(self, platform: str, form_data: Dict[str, list], headers: Dict[str, str], body: bytes) -> Response:
        """
        å¤„ç† Webhook è¯·æ±‚
        
        Args:
            platform: å¹³å°åç§° (feishu, dingtalk, wecom, telegram)
            form_data: POST æ•°æ®ï¼ˆå·²è§£æï¼‰
            headers: HTTP è¯·æ±‚å¤´
            body: åŸå§‹è¯·æ±‚ä½“
            
        Returns:
            Response å¯¹è±¡
        """
        try:
            from bot.handler import handle_webhook
            from bot.models import WebhookResponse
            
            # è°ƒç”¨ bot æ¨¡å—å¤„ç†
            webhook_response = handle_webhook(platform, headers, body)
            
            # è½¬æ¢ä¸º web å“åº”
            return JsonResponse(
                webhook_response.body,
                status=HTTPStatus(webhook_response.status_code)
            )
            
        except ImportError as e:
            logger.error(f"[BotHandler] Bot æ¨¡å—æœªæ­£ç¡®å®‰è£…: {e}")
            return JsonResponse(
                {"error": "Bot module not available"},
                status=HTTPStatus.INTERNAL_SERVER_ERROR
            )
        except Exception as e:
            logger.error(f"[BotHandler] å¤„ç† {platform} Webhook å¤±è´¥: {e}")
            return JsonResponse(
                {"error": str(e)},
                status=HTTPStatus.INTERNAL_SERVER_ERROR
            )


# ============================================================
# å¤„ç†å™¨å·¥å‚
# ============================================================

_page_handler: PageHandler | None = None
_api_handler: ApiHandler | None = None
_bot_handler: BotHandler | None = None


def get_page_handler() -> PageHandler:
    """è·å–é¡µé¢å¤„ç†å™¨å®ä¾‹"""
    global _page_handler
    if _page_handler is None:
        _page_handler = PageHandler()
    return _page_handler


def get_api_handler() -> ApiHandler:
    """è·å– API å¤„ç†å™¨å®ä¾‹"""
    global _api_handler
    if _api_handler is None:
        _api_handler = ApiHandler()
    return _api_handler


def get_bot_handler() -> BotHandler:
    """è·å– Bot å¤„ç†å™¨å®ä¾‹"""
    global _bot_handler
    if _bot_handler is None:
        _bot_handler = BotHandler()
    return _bot_handler

--------------------

#File: web/__init__.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Web æœåŠ¡æ¨¡å—
===================================

åˆ†å±‚æ¶æ„ï¼š
- server.py    - HTTP æœåŠ¡å™¨æ ¸å¿ƒ
- router.py    - è·¯ç”±åˆ†å‘
- handlers.py  - è¯·æ±‚å¤„ç†å™¨
- services.py  - ä¸šåŠ¡æœåŠ¡å±‚
- templates.py - HTML æ¨¡æ¿

ä½¿ç”¨æ–¹å¼ï¼š
    from web import run_server_in_thread, WebServer
    
    # åå°å¯åŠ¨
    run_server_in_thread(host="127.0.0.1", port=8000)
    
    # å‰å°å¯åŠ¨
    server = WebServer(host="127.0.0.1", port=8000)
    server.run()
"""

from web.server import WebServer, run_server_in_thread

__all__ = [
    'WebServer',
    'run_server_in_thread',
]

--------------------

#File: web/templates.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Web æ¨¡æ¿å±‚ - HTML é¡µé¢ç”Ÿæˆ
===================================

èŒè´£ï¼š
1. ç”Ÿæˆ HTML é¡µé¢
2. ç®¡ç† CSS æ ·å¼
3. æä¾›å¯å¤ç”¨çš„é¡µé¢ç»„ä»¶
"""

from __future__ import annotations

import html
from typing import Optional


# ============================================================
# CSS æ ·å¼å®šä¹‰
# ============================================================

BASE_CSS = """
:root {
    --primary: #2563eb;
    --primary-hover: #1d4ed8;
    --bg: #f8fafc;
    --card: #ffffff;
    --text: #1e293b;
    --text-light: #64748b;
    --border: #e2e8f0;
    --success: #10b981;
    --error: #ef4444;
    --warning: #f59e0b;
}

* {
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    background-color: var(--bg);
    color: var(--text);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    padding: 20px;
}

.container {
    background: var(--card);
    padding: 2rem;
    border-radius: 1rem;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    width: 100%;
    max-width: 500px;
}

h2 {
    margin-top: 0;
    color: var(--text);
    font-size: 1.5rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.subtitle {
    color: var(--text-light);
    font-size: 0.875rem;
    margin-bottom: 2rem;
    line-height: 1.5;
}

.code-badge {
    background: #f1f5f9;
    padding: 0.2rem 0.4rem;
    border-radius: 0.25rem;
    font-family: monospace;
    color: var(--primary);
}

.form-group {
    margin-bottom: 1.5rem;
}

label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: var(--text);
}

textarea, input[type="text"] {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--border);
    border-radius: 0.5rem;
    font-family: monospace;
    font-size: 0.875rem;
    line-height: 1.5;
    resize: vertical;
    transition: border-color 0.2s, box-shadow 0.2s;
}

textarea:focus, input[type="text"]:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

button {
    background-color: var(--primary);
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    border-radius: 0.5rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    width: 100%;
    font-size: 1rem;
}

button:hover {
    background-color: var(--primary-hover);
    transform: translateY(-1px);
}

button:active {
    transform: translateY(0);
}

.btn-secondary {
    background-color: var(--text-light);
}

.btn-secondary:hover {
    background-color: var(--text);
}

.footer {
    margin-top: 2rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border);
    color: var(--text-light);
    font-size: 0.75rem;
    text-align: center;
}

/* Toast Notification */
.toast {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(100px);
    background: white;
    border-left: 4px solid var(--success);
    padding: 1rem 1.5rem;
    border-radius: 0.5rem;
    box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
    display: flex;
    align-items: center;
    gap: 0.75rem;
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    opacity: 0;
    z-index: 1000;
}

.toast.show {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
}

.toast.error {
    border-left-color: var(--error);
}

.toast.warning {
    border-left-color: var(--warning);
}

/* Helper classes */
.text-muted {
    font-size: 0.75rem;
    color: var(--text-light);
    margin-top: 0.5rem;
}

.mt-2 { margin-top: 0.5rem; }
.mt-4 { margin-top: 1rem; }
.mb-2 { margin-bottom: 0.5rem; }
.mb-4 { margin-bottom: 1rem; }

/* Section divider */
.section-divider {
    margin: 2rem 0;
    border: none;
    border-top: 1px solid var(--border);
}

/* Analysis section */
.analysis-section {
    margin-top: 1.5rem;
    padding-top: 1.5rem;
    border-top: 1px solid var(--border);
}

.analysis-section h3 {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: var(--text);
}

.input-group {
    display: flex;
    gap: 0.5rem;
}

.input-group input {
    flex: 1;
    resize: none;
}

.input-group button {
    width: auto;
    padding: 0.75rem 1.25rem;
    white-space: nowrap;
}

.report-select {
    padding: 0.75rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: 0.5rem;
    font-size: 0.8rem;
    background: white;
    color: var(--text);
    cursor: pointer;
    min-width: 110px;
    transition: border-color 0.2s, box-shadow 0.2s;
}

.report-select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.btn-analysis {
    background-color: var(--success);
}

.btn-analysis:hover {
    background-color: #059669;
}

.btn-analysis:disabled {
    background-color: var(--text-light);
    cursor: not-allowed;
    transform: none;
}

/* Result box */
.result-box {
    margin-top: 1rem;
    padding: 1rem;
    border-radius: 0.5rem;
    font-size: 0.875rem;
    display: none;
}

.result-box.show {
    display: block;
}

.result-box.success {
    background-color: #ecfdf5;
    border: 1px solid #a7f3d0;
    color: #065f46;
}

.result-box.error {
    background-color: #fef2f2;
    border: 1px solid #fecaca;
    color: #991b1b;
}

.result-box.loading {
    background-color: #eff6ff;
    border: 1px solid #bfdbfe;
    color: #1e40af;
}

.spinner {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 2px solid currentColor;
    border-right-color: transparent;
    border-radius: 50%;
    animation: spin 0.75s linear infinite;
    margin-right: 0.5rem;
    vertical-align: middle;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Task List Container */
.task-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    max-height: 400px;
    overflow-y: auto;
}

.task-list:empty::after {
    content: 'æš‚æ— ä»»åŠ¡';
    display: block;
    text-align: center;
    color: var(--text-light);
    font-size: 0.8rem;
    padding: 1rem;
}

/* Task Card - Compact */
.task-card {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.6rem 0.75rem;
    background: var(--bg);
    border-radius: 0.5rem;
    border: 1px solid var(--border);
    font-size: 0.8rem;
    transition: all 0.2s;
}

.task-card:hover {
    border-color: var(--primary);
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.task-card.running {
    border-color: var(--primary);
    background: linear-gradient(135deg, #eff6ff 0%, #f8fafc 100%);
}

.task-card.completed {
    border-color: var(--success);
    background: linear-gradient(135deg, #ecfdf5 0%, #f8fafc 100%);
}

.task-card.failed {
    border-color: var(--error);
    background: linear-gradient(135deg, #fef2f2 0%, #f8fafc 100%);
}

/* Task Status Icon */
.task-status {
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    flex-shrink: 0;
    font-size: 0.9rem;
}

.task-card.running .task-status {
    background: var(--primary);
    color: white;
}

.task-card.completed .task-status {
    background: var(--success);
    color: white;
}

.task-card.failed .task-status {
    background: var(--error);
    color: white;
}

.task-card.pending .task-status {
    background: var(--border);
    color: var(--text-light);
}

/* Task Main Info */
.task-main {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
}

.task-title {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 600;
    color: var(--text);
}

.task-title .code {
    font-family: monospace;
    background: rgba(0,0,0,0.05);
    padding: 0.1rem 0.3rem;
    border-radius: 0.25rem;
}

.task-title .name {
    color: var(--text-light);
    font-weight: 400;
    font-size: 0.75rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.task-meta {
    display: flex;
    gap: 0.75rem;
    font-size: 0.7rem;
    color: var(--text-light);
}

.task-meta span {
    display: flex;
    align-items: center;
    gap: 0.2rem;
}

/* Task Result Badge */
.task-result {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.15rem;
    flex-shrink: 0;
}

.task-advice {
    font-weight: 600;
    font-size: 0.75rem;
    padding: 0.15rem 0.4rem;
    border-radius: 0.25rem;
    background: var(--primary);
    color: white;
}

.task-advice.buy { background: #059669; }
.task-advice.sell { background: #dc2626; }
.task-advice.hold { background: #d97706; }
.task-advice.wait { background: #6b7280; }

.task-score {
    font-size: 0.7rem;
    color: var(--text-light);
}

/* Task Actions */
.task-actions {
    display: flex;
    gap: 0.25rem;
    flex-shrink: 0;
}

.task-btn {
    width: 24px;
    height: 24px;
    padding: 0;
    border-radius: 0.25rem;
    background: transparent;
    color: var(--text-light);
    font-size: 0.75rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

.task-btn:hover {
    background: rgba(0,0,0,0.05);
    color: var(--text);
    transform: none;
}

/* Spinner in task */
.task-card .spinner {
    width: 12px;
    height: 12px;
    border-width: 1.5px;
    margin: 0;
}

/* Empty state hint */
.task-hint {
    text-align: center;
    padding: 0.75rem;
    color: var(--text-light);
    font-size: 0.75rem;
    background: var(--bg);
    border-radius: 0.375rem;
}

/* Task detail expand */
.task-detail {
    display: none;
    padding: 0.5rem 0.75rem;
    padding-left: 3rem;
    background: rgba(0,0,0,0.02);
    border-radius: 0 0 0.5rem 0.5rem;
    margin-top: -0.5rem;
    font-size: 0.75rem;
    border: 1px solid var(--border);
    border-top: none;
}

.task-detail.show {
    display: block;
}

.task-detail-row {
    display: flex;
    justify-content: space-between;
    padding: 0.25rem 0;
}

.task-detail-row .label {
    color: var(--text-light);
}

.task-detail-summary {
    margin-top: 0.5rem;
    padding: 0.5rem;
    background: white;
    border-radius: 0.25rem;
    line-height: 1.4;
}
"""


# ============================================================
# é¡µé¢æ¨¡æ¿
# ============================================================

def render_base(
    title: str,
    content: str,
    extra_css: str = "",
    extra_js: str = ""
) -> str:
    """
    æ¸²æŸ“åŸºç¡€ HTML æ¨¡æ¿
    
    Args:
        title: é¡µé¢æ ‡é¢˜
        content: é¡µé¢å†…å®¹ HTML
        extra_css: é¢å¤–çš„ CSS æ ·å¼
        extra_js: é¢å¤–çš„ JavaScript
    """
    return f"""<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{html.escape(title)}</title>
  <style>{BASE_CSS}{extra_css}</style>
</head>
<body>
  {content}
  {extra_js}
</body>
</html>"""


def render_toast(message: str, toast_type: str = "success") -> str:
    """
    æ¸²æŸ“ Toast é€šçŸ¥
    
    Args:
        message: é€šçŸ¥æ¶ˆæ¯
        toast_type: ç±»å‹ (success, error, warning)
    """
    icon_map = {
        "success": "âœ…",
        "error": "âŒ",
        "warning": "âš ï¸"
    }
    icon = icon_map.get(toast_type, "â„¹ï¸")
    type_class = f" {toast_type}" if toast_type != "success" else ""
    
    return f"""
    <div id="toast" class="toast show{type_class}">
        <span class="icon">{icon}</span> {html.escape(message)}
    </div>
    <script>
        setTimeout(() => {{
            document.getElementById('toast').classList.remove('show');
        }}, 3000);
    </script>
    """


def render_config_page(
    stock_list: str,
    env_filename: str,
    message: Optional[str] = None
) -> bytes:
    """
    æ¸²æŸ“é…ç½®é¡µé¢
    
    Args:
        stock_list: å½“å‰è‡ªé€‰è‚¡åˆ—è¡¨
        env_filename: ç¯å¢ƒæ–‡ä»¶å
        message: å¯é€‰çš„æç¤ºæ¶ˆæ¯
    """
    safe_value = html.escape(stock_list)
    toast_html = render_toast(message) if message else ""
    
    # åˆ†æç»„ä»¶çš„ JavaScript - æ”¯æŒå¤šä»»åŠ¡
    analysis_js = """
<script>
(function() {
    const codeInput = document.getElementById('analysis_code');
    const submitBtn = document.getElementById('analysis_btn');
    const taskList = document.getElementById('task_list');
    const reportTypeSelect = document.getElementById('report_type');
    
    // ä»»åŠ¡ç®¡ç†
    const tasks = new Map(); // taskId -> {task, pollCount}
    let pollInterval = null;
    const MAX_POLL_COUNT = 120; // 6 åˆ†é’Ÿè¶…æ—¶ï¼š120 * 3000ms = 360000ms
    const POLL_INTERVAL_MS = 3000;
    const MAX_TASKS_DISPLAY = 10;
    
    // å…è®¸è¾“å…¥æ•°å­—å’Œå­—æ¯å’Œç‚¹ï¼ˆæ”¯æŒæ¸¯è‚¡ HKxxxxx æ ¼å¼ ç¾è‚¡AAPL/BRK.Bï¼‰
    codeInput.addEventListener('input', function(e) {
        // è½¬å¤§å†™ï¼Œåªä¿ç•™å­—æ¯å’Œæ•°å­—å’Œç‚¹
        this.value = this.value.toUpperCase().replace(/[^A-Z0-9.]/g, '');
        if (this.value.length > 8) {
            this.value = this.value.slice(0, 8);
        }
        updateButtonState();
    });
    
    // å›è½¦æäº¤
    codeInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            if (!submitBtn.disabled) {
                submitAnalysis();
            }
        }
    });
    
    // æ›´æ–°æŒ‰é’®çŠ¶æ€ - æ”¯æŒ Aè‚¡(6ä½æ•°å­—) æˆ– æ¸¯è‚¡(HK+5ä½æ•°å­—)
    function updateButtonState() {
        const code = codeInput.value.trim();
        const isAStock = /^\\d{6}$/.test(code);           // Aè‚¡: 600519
        const isHKStock = /^HK\\d{5}$/.test(code);        // æ¸¯è‚¡: HK00700
        const isUSStock =  /^[A-Z]{1,5}(\.[A-Z]{1,2})?$/.test(code); // ç¾è‚¡: AAPL

        submitBtn.disabled = !(isAStock || isHKStock || isUSStock);
    }
    
    // æ ¼å¼åŒ–æ—¶é—´
    function formatTime(isoString) {
        if (!isoString) return '-';
        const date = new Date(isoString);
        return date.toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit', second: '2-digit'});
    }
    
    // è®¡ç®—è€—æ—¶
    function calcDuration(start, end) {
        if (!start) return '-';
        const startTime = new Date(start).getTime();
        const endTime = end ? new Date(end).getTime() : Date.now();
        const seconds = Math.floor((endTime - startTime) / 1000);
        if (seconds < 60) return seconds + 's';
        const minutes = Math.floor(seconds / 60);
        const remainSec = seconds % 60;
        return minutes + 'm' + remainSec + 's';
    }
    
    // è·å–å»ºè®®æ ·å¼ç±»
    function getAdviceClass(advice) {
        if (!advice) return '';
        if (advice.includes('ä¹°') || advice.includes('åŠ ä»“')) return 'buy';
        if (advice.includes('å–') || advice.includes('å‡ä»“')) return 'sell';
        if (advice.includes('æŒæœ‰')) return 'hold';
        return 'wait';
    }
    
    // æ¸²æŸ“å•ä¸ªä»»åŠ¡å¡ç‰‡
    function renderTaskCard(taskId, taskData) {
        const task = taskData.task || {};
        const status = task.status || 'pending';
        const code = task.code || taskId.split('_')[0];
        const result = task.result || {};
        
        let statusIcon = 'â³';
        let statusText = 'ç­‰å¾…ä¸­';
        if (status === 'running') { statusIcon = '<span class="spinner"></span>'; statusText = 'åˆ†æä¸­'; }
        else if (status === 'completed') { statusIcon = 'âœ“'; statusText = 'å®Œæˆ'; }
        else if (status === 'failed') { statusIcon = 'âœ—'; statusText = 'å¤±è´¥'; }
        
        let resultHtml = '';
        if (status === 'completed' && result.operation_advice) {
            const adviceClass = getAdviceClass(result.operation_advice);
            resultHtml = '<div class="task-result">' +
                '<span class="task-advice ' + adviceClass + '">' + result.operation_advice + '</span>' +
                '<span class="task-score">' + (result.sentiment_score || '-') + 'åˆ†</span>' +
                '</div>';
        } else if (status === 'failed') {
            resultHtml = '<div class="task-result"><span class="task-advice sell">å¤±è´¥</span></div>';
        }
        
        let detailHtml = '';
        if (status === 'completed') {
            detailHtml = '<div class="task-detail" id="detail_' + taskId + '">' +
                '<div class="task-detail-row"><span class="label">è¶‹åŠ¿</span><span>' + (result.trend_prediction || '-') + '</span></div>' +
                (result.analysis_summary ? '<div class="task-detail-summary">' + result.analysis_summary.substring(0, 100) + '...</div>' : '') +
                '</div>';
        }
        
        return '<div class="task-card ' + status + '" id="task_' + taskId + '" onclick="toggleDetail(\\''+taskId+'\\')">' +
            '<div class="task-status">' + statusIcon + '</div>' +
            '<div class="task-main">' +
                '<div class="task-title">' +
                    '<span class="code">' + code + '</span>' +
                    '<span class="name">' + (result.name || code) + '</span>' +
                '</div>' +
                '<div class="task-meta">' +
                    '<span>â± ' + formatTime(task.start_time) + '</span>' +
                    '<span>â³ ' + calcDuration(task.start_time, task.end_time) + '</span>' +
                    '<span>' + (task.report_type === 'full' ? 'ğŸ“Šå®Œæ•´' : 'ğŸ“ç²¾ç®€') + '</span>' +
                '</div>' +
            '</div>' +
            resultHtml +
            '<div class="task-actions">' +
                '<button class="task-btn" onclick="event.stopPropagation();removeTask(\\''+taskId+'\\')">Ã—</button>' +
            '</div>' +
        '</div>' + detailHtml;
    }
    
    // æ¸²æŸ“æ‰€æœ‰ä»»åŠ¡
    function renderAllTasks() {
        if (tasks.size === 0) {
            taskList.innerHTML = '<div class="task-hint">ğŸ’¡ è¾“å…¥è‚¡ç¥¨ä»£ç å¼€å§‹åˆ†æ</div>';
            return;
        }
        
        let html = '';
        const sortedTasks = Array.from(tasks.entries())
            .sort((a, b) => (b[1].task?.start_time || '').localeCompare(a[1].task?.start_time || ''));
        
        sortedTasks.slice(0, MAX_TASKS_DISPLAY).forEach(([taskId, taskData]) => {
            html += renderTaskCard(taskId, taskData);
        });
        
        if (sortedTasks.length > MAX_TASKS_DISPLAY) {
            html += '<div class="task-hint">... è¿˜æœ‰ ' + (sortedTasks.length - MAX_TASKS_DISPLAY) + ' ä¸ªä»»åŠ¡</div>';
        }
        
        taskList.innerHTML = html;
    }
    
    // åˆ‡æ¢è¯¦æƒ…æ˜¾ç¤º
    window.toggleDetail = function(taskId) {
        const detail = document.getElementById('detail_' + taskId);
        if (detail) {
            detail.classList.toggle('show');
        }
    };
    
    // ç§»é™¤ä»»åŠ¡
    window.removeTask = function(taskId) {
        tasks.delete(taskId);
        renderAllTasks();
        checkStopPolling();
    };
    
    // è½®è¯¢æ‰€æœ‰è¿è¡Œä¸­çš„ä»»åŠ¡
    function pollAllTasks() {
        let hasRunning = false;
        
        tasks.forEach((taskData, taskId) => {
            const status = taskData.task?.status;
            if (status === 'running' || status === 'pending' || !status) {
                hasRunning = true;
                taskData.pollCount = (taskData.pollCount || 0) + 1;
                
                if (taskData.pollCount > MAX_POLL_COUNT) {
                    taskData.task = taskData.task || {};
                    taskData.task.status = 'failed';
                    taskData.task.error = 'è½®è¯¢è¶…æ—¶';
                    return;
                }
                
                fetch('/task?id=' + encodeURIComponent(taskId))
                    .then(r => r.json())
                    .then(data => {
                        if (data.success && data.task) {
                            taskData.task = data.task;
                            renderAllTasks();
                        }
                    })
                    .catch(() => {});
            }
        });
        
        if (!hasRunning) {
            checkStopPolling();
        }
    }
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦åœæ­¢è½®è¯¢
    function checkStopPolling() {
        let hasRunning = false;
        tasks.forEach((taskData) => {
            const status = taskData.task?.status;
            if (status === 'running' || status === 'pending' || !status) {
                hasRunning = true;
            }
        });
        
        if (!hasRunning && pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
        }
    }
    
    // å¼€å§‹è½®è¯¢
    function startPolling() {
        if (!pollInterval) {
            pollInterval = setInterval(pollAllTasks, POLL_INTERVAL_MS);
        }
    }
    
    // æäº¤åˆ†æ
    window.submitAnalysis = function() {
        const code = codeInput.value.trim();
        const isAStock = /^\d{6}$/.test(code);
        const isHKStock = /^HK\d{5}$/.test(code);
        const isUSStock = /^[A-Z]{1,5}(\.[A-Z]{1,2})?$/.test(code);

        if (!(isAStock || isHKStock || isUSStock)) {
            return;
        }
        
        submitBtn.disabled = true;
        submitBtn.textContent = 'æäº¤ä¸­...';

        const reportType = reportTypeSelect.value;
        fetch('/analysis?code=' + encodeURIComponent(code) + '&report_type=' + encodeURIComponent(reportType))
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const taskId = data.task_id;
                    tasks.set(taskId, {
                        task: {
                            code: code,
                            status: 'running',
                            start_time: new Date().toISOString(),
                            report_type: reportType
                        },
                        pollCount: 0
                    });
                    
                    renderAllTasks();
                    startPolling();
                    codeInput.value = '';
                    
                    // ç«‹å³è½®è¯¢ä¸€æ¬¡
                    setTimeout(() => {
                        fetch('/task?id=' + encodeURIComponent(taskId))
                            .then(r => r.json())
                            .then(d => {
                                if (d.success && d.task) {
                                    tasks.get(taskId).task = d.task;
                                    renderAllTasks();
                                }
                            });
                    }, 500);
                } else {
                    alert('æäº¤å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                }
            })
            .catch(error => {
                alert('è¯·æ±‚å¤±è´¥: ' + error.message);
            })
            .finally(() => {
                submitBtn.disabled = false;
                submitBtn.textContent = 'ğŸš€ åˆ†æ';
                updateButtonState();
            });
    };
    
    // åˆå§‹åŒ–
    updateButtonState();
    renderAllTasks();
})();
</script>
"""
    
    content = f"""
  <div class="container">
    <h2>ğŸ“ˆ Aè‚¡/æ¸¯è‚¡/ç¾è‚¡åˆ†æ</h2>
    
    <!-- å¿«é€Ÿåˆ†æåŒºåŸŸ -->
    <div class="analysis-section" style="margin-top: 0; padding-top: 0; border-top: none;">
      <div class="form-group" style="margin-bottom: 0.75rem;">
        <div class="input-group">
          <input 
              type="text" 
              id="analysis_code" 
              placeholder="Aè‚¡ 600519 / æ¸¯è‚¡ HK00700 / ç¾è‚¡ AAPL"
              maxlength="8"
              autocomplete="off"
          />
          <select id="report_type" class="report-select" title="é€‰æ‹©æŠ¥å‘Šç±»å‹">
            <option value="simple">ğŸ“ ç²¾ç®€æŠ¥å‘Š</option>
            <option value="full">ğŸ“Š å®Œæ•´æŠ¥å‘Š</option>
          </select>
          <button type="button" id="analysis_btn" class="btn-analysis" onclick="submitAnalysis()" disabled>
            ğŸš€ åˆ†æ
          </button>
        </div>
      </div>
      
      <!-- ä»»åŠ¡åˆ—è¡¨ -->
      <div id="task_list" class="task-list"></div>
    </div>
    
    <hr class="section-divider">
    
    <!-- è‡ªé€‰è‚¡é…ç½®åŒºåŸŸ -->
    <form method="post" action="/update">
      <div class="form-group">
        <label for="stock_list">ğŸ“‹ è‡ªé€‰è‚¡åˆ—è¡¨ <span class="code-badge">{html.escape(env_filename)}</span></label>
        <p>ä»…ç”¨äºæœ¬åœ°ç¯å¢ƒ (127.0.0.1) â€¢ å®‰å…¨ä¿®æ”¹ .env é…ç½®</p>
        <textarea 
            id="stock_list" 
            name="stock_list" 
            rows="4" 
            placeholder="ä¾‹å¦‚: 600519, 000001 (é€—å·æˆ–æ¢è¡Œåˆ†éš”)"
        >{safe_value}</textarea>
      </div>
      <button type="submit">ğŸ’¾ ä¿å­˜</button>
    </form>
    
    <div class="footer">
      <p>API: <code>/health</code> Â· <code>/analysis?code=xxx</code> Â· <code>/tasks</code></p>
    </div>
  </div>
  
  {toast_html}
  {analysis_js}
"""
    
    page = render_base(
        title="A/Hè‚¡è‡ªé€‰é…ç½® | WebUI",
        content=content
    )
    return page.encode("utf-8")


def render_error_page(
    status_code: int,
    message: str,
    details: Optional[str] = None
) -> bytes:
    """
    æ¸²æŸ“é”™è¯¯é¡µé¢
    
    Args:
        status_code: HTTP çŠ¶æ€ç 
        message: é”™è¯¯æ¶ˆæ¯
        details: è¯¦ç»†ä¿¡æ¯
    """
    details_html = f"<p class='text-muted'>{html.escape(details)}</p>" if details else ""
    
    content = f"""
  <div class="container" style="text-align: center;">
    <h2>ğŸ˜µ {status_code}</h2>
    <p>{html.escape(message)}</p>
    {details_html}
    <a href="/" style="color: var(--primary); text-decoration: none;">â† è¿”å›é¦–é¡µ</a>
  </div>
"""
    
    page = render_base(
        title=f"é”™è¯¯ {status_code}",
        content=content
    )
    return page.encode("utf-8")

--------------------

#File: web/router.py
--------------------
# -*- coding: utf-8 -*-
"""
===================================
Web è·¯ç”±å±‚ - è¯·æ±‚åˆ†å‘
===================================

èŒè´£ï¼š
1. è§£æè¯·æ±‚è·¯å¾„
2. åˆ†å‘åˆ°å¯¹åº”çš„å¤„ç†å™¨
3. æ”¯æŒè·¯ç”±æ³¨å†Œå’Œæ‰©å±•
"""

from __future__ import annotations

import logging
from http import HTTPStatus
from typing import Callable, Dict, List, Optional, TYPE_CHECKING, Tuple
from urllib.parse import parse_qs, urlparse

from web.handlers import (
    Response, HtmlResponse, JsonResponse,
    get_page_handler, get_api_handler, get_bot_handler
)
from web.templates import render_error_page

if TYPE_CHECKING:
    from http.server import BaseHTTPRequestHandler

logger = logging.getLogger(__name__)


# ============================================================
# è·¯ç”±å®šä¹‰
# ============================================================

# è·¯ç”±å¤„ç†å‡½æ•°ç±»å‹: (query_params) -> Response
RouteHandler = Callable[[Dict[str, list]], Response]


class Route:
    """è·¯ç”±å®šä¹‰"""
    
    def __init__(
        self,
        path: str,
        method: str,
        handler: RouteHandler,
        description: str = ""
    ):
        self.path = path
        self.method = method.upper()
        self.handler = handler
        self.description = description


class Router:
    """
    è·¯ç”±ç®¡ç†å™¨
    
    è´Ÿè´£ï¼š
    1. æ³¨å†Œè·¯ç”±
    2. åŒ¹é…è¯·æ±‚è·¯å¾„
    3. åˆ†å‘åˆ°å¤„ç†å™¨
    """
    
    def __init__(self):
        self._routes: Dict[str, Dict[str, Route]] = {}  # {path: {method: Route}}
    
    def register(
        self,
        path: str,
        method: str,
        handler: RouteHandler,
        description: str = ""
    ) -> None:
        """
        æ³¨å†Œè·¯ç”±
        
        Args:
            path: è·¯ç”±è·¯å¾„
            method: HTTP æ–¹æ³• (GET, POST, etc.)
            handler: å¤„ç†å‡½æ•°
            description: è·¯ç”±æè¿°
        """
        method = method.upper()
        if path not in self._routes:
            self._routes[path] = {}
        
        self._routes[path][method] = Route(path, method, handler, description)
        logger.debug(f"[Router] æ³¨å†Œè·¯ç”±: {method} {path}")
    
    def get(self, path: str, description: str = "") -> Callable:
        """è£…é¥°å™¨ï¼šæ³¨å†Œ GET è·¯ç”±"""
        def decorator(handler: RouteHandler) -> RouteHandler:
            self.register(path, "GET", handler, description)
            return handler
        return decorator
    
    def post(self, path: str, description: str = "") -> Callable:
        """è£…é¥°å™¨ï¼šæ³¨å†Œ POST è·¯ç”±"""
        def decorator(handler: RouteHandler) -> RouteHandler:
            self.register(path, "POST", handler, description)
            return handler
        return decorator
    
    def match(self, path: str, method: str) -> Optional[Route]:
        """
        åŒ¹é…è·¯ç”±
        
        Args:
            path: è¯·æ±‚è·¯å¾„
            method: HTTP æ–¹æ³•
            
        Returns:
            åŒ¹é…çš„è·¯ç”±ï¼Œæˆ– None
        """
        method = method.upper()
        routes_for_path = self._routes.get(path)
        
        if routes_for_path is None:
            return None
        
        return routes_for_path.get(method)
    
    def dispatch(
        self,
        request_handler: 'BaseHTTPRequestHandler',
        method: str
    ) -> None:
        """
        åˆ†å‘è¯·æ±‚
        
        Args:
            request_handler: HTTP è¯·æ±‚å¤„ç†å™¨
            method: HTTP æ–¹æ³•
        """
        # è§£æ URL
        parsed = urlparse(request_handler.path)
        path = parsed.path
        query = parse_qs(parsed.query)
        
        # å¤„ç†æ ¹è·¯å¾„
        if path == "":
            path = "/"
        
        # åŒ¹é…è·¯ç”±
        route = self.match(path, method)
        
        if route is None:
            # 404 Not Found
            self._send_not_found(request_handler, path)
            return
        
        try:
            # è°ƒç”¨å¤„ç†å™¨
            response = route.handler(query)
            response.send(request_handler)
            
        except Exception as e:
            logger.error(f"[Router] å¤„ç†è¯·æ±‚å¤±è´¥: {method} {path} - {e}")
            self._send_error(request_handler, str(e))
    
    def dispatch_post(
        self,
        request_handler: 'BaseHTTPRequestHandler'
    ) -> None:
        """
        åˆ†å‘ POST è¯·æ±‚ï¼ˆéœ€è¦è¯»å– bodyï¼‰
        
        Args:
            request_handler: HTTP è¯·æ±‚å¤„ç†å™¨
        """
        parsed = urlparse(request_handler.path)
        path = parsed.path
        
        # è¯»å– POST bodyï¼ˆä¿ç•™åŸå§‹å­—èŠ‚ç”¨äº Bot Webhookï¼‰
        content_length = int(request_handler.headers.get("Content-Length", "0") or "0")
        raw_body_bytes = request_handler.rfile.read(content_length)
        raw_body = raw_body_bytes.decode("utf-8", errors="replace")
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯ Bot Webhook è·¯ç”±
        if path.startswith("/bot/"):
            self._dispatch_bot_webhook(request_handler, path, raw_body_bytes)
            return
        
        # æ™®é€š POST è¯·æ±‚
        form_data = parse_qs(raw_body)
        
        # åŒ¹é…è·¯ç”±
        route = self.match(path, "POST")
        
        if route is None:
            self._send_not_found(request_handler, path)
            return
        
        try:
            # è°ƒç”¨å¤„ç†å™¨ï¼ˆä¼ å…¥ form_dataï¼‰
            response = route.handler(form_data)
            response.send(request_handler)
            
        except Exception as e:
            logger.error(f"[Router] å¤„ç† POST è¯·æ±‚å¤±è´¥: {path} - {e}")
            self._send_error(request_handler, str(e))
    
    def _dispatch_bot_webhook(
        self,
        request_handler: 'BaseHTTPRequestHandler',
        path: str,
        body: bytes
    ) -> None:
        """
        åˆ†å‘ Bot Webhook è¯·æ±‚
        
        Bot Webhook éœ€è¦åŸå§‹ body å’Œ headersï¼Œä¸æ™®é€šè·¯ç”±å¤„ç†ä¸åŒã€‚
        
        Args:
            request_handler: HTTP è¯·æ±‚å¤„ç†å™¨
            path: è¯·æ±‚è·¯å¾„
            body: åŸå§‹è¯·æ±‚ä½“å­—èŠ‚
        """
        # æå–å¹³å°åç§°ï¼š/bot/feishu -> feishu
        parts = path.strip('/').split('/')
        if len(parts) < 2:
            self._send_not_found(request_handler, path)
            return
        
        platform = parts[1]
        
        # è·å–è¯·æ±‚å¤´
        headers = {key: value for key, value in request_handler.headers.items()}
        
        try:
            bot_handler = get_bot_handler()
            response = bot_handler.handle_webhook(platform, {}, headers, body)
            response.send(request_handler)
            
        except Exception as e:
            logger.error(f"[Router] å¤„ç† Bot Webhook å¤±è´¥: {path} - {e}")
            self._send_error(request_handler, str(e))
    
    def list_routes(self) -> List[Tuple[str, str, str]]:
        """
        åˆ—å‡ºæ‰€æœ‰è·¯ç”±
        
        Returns:
            [(method, path, description), ...]
        """
        routes = []
        for path, methods in self._routes.items():
            for method, route in methods.items():
                routes.append((method, path, route.description))
        return sorted(routes, key=lambda x: (x[1], x[0]))
    
    def _send_not_found(
        self,
        request_handler: 'BaseHTTPRequestHandler',
        path: str
    ) -> None:
        """å‘é€ 404 å“åº”"""
        body = render_error_page(404, "é¡µé¢æœªæ‰¾åˆ°", f"è·¯å¾„ {path} ä¸å­˜åœ¨")
        response = HtmlResponse(body, status=HTTPStatus.NOT_FOUND)
        response.send(request_handler)
    
    def _send_error(
        self,
        request_handler: 'BaseHTTPRequestHandler',
        message: str
    ) -> None:
        """å‘é€ 500 å“åº”"""
        body = render_error_page(500, "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", message)
        response = HtmlResponse(body, status=HTTPStatus.INTERNAL_SERVER_ERROR)
        response.send(request_handler)


# ============================================================
# é»˜è®¤è·¯ç”±æ³¨å†Œ
# ============================================================

def create_default_router() -> Router:
    """åˆ›å»ºå¹¶é…ç½®é»˜è®¤è·¯ç”±"""
    router = Router()
    
    # è·å–å¤„ç†å™¨
    page_handler = get_page_handler()
    api_handler = get_api_handler()
    
    # === é¡µé¢è·¯ç”± ===
    router.register(
        "/", "GET",
        lambda q: page_handler.handle_index(),
        "é…ç½®é¦–é¡µ"
    )
    
    router.register(
        "/update", "POST",
        lambda form: page_handler.handle_update(form),
        "æ›´æ–°é…ç½®"
    )
    
    # === API è·¯ç”± ===
    router.register(
        "/health", "GET",
        lambda q: api_handler.handle_health(),
        "å¥åº·æ£€æŸ¥"
    )
    
    router.register(
        "/analysis", "GET",
        lambda q: api_handler.handle_analysis(q),
        "è§¦å‘è‚¡ç¥¨åˆ†æ"
    )

    router.register(
        "/analysis/history", "GET",
        lambda q: api_handler.handle_analysis_history(q),
        "æŸ¥è¯¢åˆ†æå†å²"
    )
    
    router.register(
        "/tasks", "GET",
        lambda q: api_handler.handle_tasks(q),
        "æŸ¥è¯¢ä»»åŠ¡åˆ—è¡¨"
    )
    
    router.register(
        "/task", "GET",
        lambda q: api_handler.handle_task_status(q),
        "æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€"
    )
    
    # === Bot Webhook è·¯ç”± ===
    # æ³¨æ„ï¼šBot Webhook è·¯ç”±åœ¨ dispatch_post ä¸­ç‰¹æ®Šå¤„ç†
    # è¿™é‡Œåªæ˜¯ä¸ºäº†åœ¨è·¯ç”±åˆ—è¡¨ä¸­æ˜¾ç¤º
    # å®é™…è¯·æ±‚ä¼šè¢« _dispatch_bot_webhook æ–¹æ³•å¤„ç†
    
    # é£ä¹¦æœºå™¨äºº Webhook
    router.register(
        "/bot/feishu", "POST",
        lambda form: JsonResponse({"error": "Use POST with JSON body"}),
        "é£ä¹¦æœºå™¨äºº Webhook"
    )
    
    # é’‰é’‰æœºå™¨äºº Webhook
    router.register(
        "/bot/dingtalk", "POST",
        lambda form: JsonResponse({"error": "Use POST with JSON body"}),
        "é’‰é’‰æœºå™¨äºº Webhook"
    )
    
    # ä¼ä¸šå¾®ä¿¡æœºå™¨äºº Webhookï¼ˆå¼€å‘ä¸­ï¼‰
    # router.register(
    #     "/bot/wecom", "POST",
    #     lambda form: JsonResponse({"error": "Use POST with JSON body"}),
    #     "ä¼ä¸šå¾®ä¿¡æœºå™¨äºº Webhook"
    # )
    
    # Telegram æœºå™¨äºº Webhookï¼ˆå¼€å‘ä¸­ï¼‰
    # router.register(
    #     "/bot/telegram", "POST",
    #     lambda form: JsonResponse({"error": "Use POST with JSON body"}),
    #     "Telegram æœºå™¨äºº Webhook"
    # )
    
    return router


# å…¨å±€é»˜è®¤è·¯ç”±å®ä¾‹
_default_router: Router | None = None


def get_router() -> Router:
    """è·å–é»˜è®¤è·¯ç”±å®ä¾‹"""
    global _default_router
    if _default_router is None:
        _default_router = create_default_router()
    return _default_router

--------------------
